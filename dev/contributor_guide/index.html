<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contributor Guide ¬∑ XCALibre.jl</title><meta name="title" content="Contributor Guide ¬∑ XCALibre.jl"/><meta property="og:title" content="Contributor Guide ¬∑ XCALibre.jl"/><meta property="twitter:title" content="Contributor Guide ¬∑ XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../examples/04_2d-inflow-using-Flux/">Advanced: Inflow condition using Machine Learning (<code>Flux.jl</code>)</a></li><li><a class="tocitem" href="../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li><li><a class="tocitem" href="../examples/06_2d-laplace-solver/">Validation: Laplace Solver in 2D Solid Medium</a></li><li><a class="tocitem" href="../examples/07_2d-bump-komegaSST/">Verification: 2D bump <span>$k-\omega$</span> SST</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../user_guide/0_introduction_and_workflow/">Introduction</a></li><li><a class="tocitem" href="../user_guide/1_preprocessing/">Pre-processing</a></li><li><a class="tocitem" href="../user_guide/2_physics_and_models/">Physics and models</a></li><li><a class="tocitem" href="../user_guide/3_numerical_setup/">Numerical setup</a></li><li><a class="tocitem" href="../user_guide/4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../user_guide/5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li class="is-active"><a class="tocitem" href>Contributor Guide</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Some-guidelines"><span>Some guidelines</span></a></li><li><a class="tocitem" href="#Module-organisation"><span>Module organisation</span></a></li><li><a class="tocitem" href="#Key-types-and-structures"><span>Key types and structures</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Implementing-new-models"><span>Implementing new models</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Contributor Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Contributor Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/contributor_guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Contributor-Guide"><a class="docs-heading-anchor" href="#Contributor-Guide">Contributor Guide</a><a id="Contributor-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Contributor-Guide" title="Permalink"></a></h1><p><em>Guidelines and practical information for contributing to XCALibre.jl</em></p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><hr/><p>In time, our ambition is to document the internal API completely, however, this will take some time and it is an ongoing process. Since XCALibre.jl uses a modular approach and the current functionality covers a good portion of the CFD stack, those interested in working with the internal API should be able to work from existing implementations. In this page we provide key information for those users who want to customise, refine, improve, or extend XCALibre.jl.</p><p>From its humble beginning as a 1D diffusion example code to explore the features of the Julia programming language (and speed claims which turned out to be true üòÑ), XCALibre.jl was meant to be shared and used to help students understand the Finite Volume Method and as an entry point to explore the implementation details underpinning CFD. As the code base has grown, this original purpose remains. However, XCALibre.jl is now a more complete CFD software stack which can be used by both researchers and students to test out new ideas, even on complex geometry with acceptable performance. XCALibre.jl will hopefully continue to grow and offer more functionality as it has been the case since work on XCALibre.jl started. In the sharing spirit of open-source software we also welcome code contributions, and we hope to make this process as simple as possible. However, we ask contributors to follow a few guidelines to ensure that we grow XCALibre.jl in a sustainable and maintainable manner.</p><h2 id="Some-guidelines"><a class="docs-heading-anchor" href="#Some-guidelines">Some guidelines</a><a id="Some-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Some-guidelines" title="Permalink"></a></h2><hr/><p>To help use keep the codebase consistent and allow us to merge future Pull Requests (PRs) more easily, we kindly request that contributors adhere to some basic guidelines. We are trying to strike a balance between consistency and ease of contribution by aiming not to be overly demanding on contributors. A minimum set of guidelines is provided below (subject to review as the codebase evolves), in no particular order:</p><h3 id="Code-style"><a class="docs-heading-anchor" href="#Code-style">Code style</a><a id="Code-style-1"></a><a class="docs-heading-anchor-permalink" href="#Code-style" title="Permalink"></a></h3><ul><li>Follow the <a href="https://docs.julialang.org/en/v1/manual/style-guide/">style guide</a> recommended in the official Julia documentation</li><li>Use camel case format for custom types e.g. <code>MyType</code></li><li>We prefer easy-to-read function names e.g. use <code>calculate_flux</code> over <code>calf</code> or similar. All in lower case and words separated with an underscore</li><li>For internal variables feel free to use Unicode symbols, or camel case identifiers. However, please refrain from doing this for any top-level or user-facing API variables.</li><li>Although Julia allows some impressive one-liners, please avoid. These can be hard to reason sometimes, aim to strike a balance between succinctness and clarity. </li></ul><h3 id="Code-contribution"><a class="docs-heading-anchor" href="#Code-contribution">Code contribution</a><a id="Code-contribution-1"></a><a class="docs-heading-anchor-permalink" href="#Code-contribution" title="Permalink"></a></h3><ul><li>Please open a PR for any code contributions against our <code>main</code> branch if your are contributing top level functionality that builds on existing code e.g. a new turbulence model or a new boundary condition (these contributions will typically be included inside one of the existing sub modules)</li><li>For contributions that may require code reorganisation please do get in touch to ensure this aligns with any planned changes (open an issue). PRs will likely be requested against the current <code>dev</code> branch</li><li>Ideally, all contributions will also include basic documentation and tests.</li></ul><h3 id="Help-wanted"><a class="docs-heading-anchor" href="#Help-wanted">Help wanted</a><a id="Help-wanted-1"></a><a class="docs-heading-anchor-permalink" href="#Help-wanted" title="Permalink"></a></h3><ul><li>If you have specific expertise in MPI or Multi-GPU implementation and wish to get involved please get in touch.</li></ul><h2 id="Module-organisation"><a class="docs-heading-anchor" href="#Module-organisation">Module organisation</a><a id="Module-organisation-1"></a><a class="docs-heading-anchor-permalink" href="#Module-organisation" title="Permalink"></a></h2><hr/><table><tr><th style="text-align: left">Module</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">XCALibre.Mesh</td><td style="text-align: left">This module defines all types required to construct the mesh object used by the flow solvers. Two main mesh types are used <code>Mesh2</code> and <code>Mesh3</code> used for 2D and 3D simulations, respectively. Some access functions are also included in this module.</td></tr><tr><td style="text-align: left">XCALibre.Fields</td><td style="text-align: left">This module defines the fields used to hold and represent the flow variable. Scalar, vector and tensor fields are defined e.g. <code>ScalarField</code>, etc. Information is stored at cell centres. These fields also have face variant where information is stored at face centres e.g. <code>FaceVectorField</code>. These fields are generally used to store fluxes. A limited set of field operations are also defined e.g. <code>getfield</code> to allow indexing field object directly.</td></tr><tr><td style="text-align: left">XCALibre.ModelFramework</td><td style="text-align: left">This module provides the framework used to define scalar and vector model equations whilst storing information about the operators used. The data structure also defines sparse matrices used to store discretisation information.</td></tr><tr><td style="text-align: left">XCALibre.Discretise</td><td style="text-align: left">This module defines the various operators needed to represent each terms in a model equation and the main discretisation loop that linearises each term according to the schemes available. Boundary conditions are also implemented in this module.</td></tr><tr><td style="text-align: left">XCALibre.Solve</td><td style="text-align: left">This module includes all functions and logic needed to solve the linear system of equations that follows the equation discretisation. The internal API to solve these systems of equations is included in this module.</td></tr><tr><td style="text-align: left">XCALibre.Calculate</td><td style="text-align: left">Implementation of functions use to carry out calculations essential to the implementation of flow solvers is included in this module. This includes interpolation of variables from cell centroid to cell faces, gradient calculation, surface normals, etc.</td></tr><tr><td style="text-align: left">XCALibre.ModelPhysics</td><td style="text-align: left">This module includes the implementations of all the physical models i.e. fluid, turbulence and energy models.</td></tr><tr><td style="text-align: left">XCALibre.Simulate</td><td style="text-align: left">This model contains information needed to set up a simulation, including the <a href="../reference/#XCALibre.Simulate.Configuration"><code>Configuration</code></a> type used by all flow solvers.</td></tr><tr><td style="text-align: left">XCALibre.Solvers</td><td style="text-align: left">Implementations of the SIMPLE and PISO flow solvers from steady and unsteady solutions, including their compressible variant.</td></tr><tr><td style="text-align: left">XCALibre.Postprocess</td><td style="text-align: left">A limited set of functions for postprocessing are implemented in this module.</td></tr><tr><td style="text-align: left">XCALibre.IOFormats</td><td style="text-align: left">Functionality to write simulation results to VTK or OpenFOAM output files are implemented in this module.</td></tr><tr><td style="text-align: left">XCALibre.FoamMesh</td><td style="text-align: left">Stand alone module to parse, process (geometry calculation) and import OpenFOAM mesh files into XCALibre.jl</td></tr><tr><td style="text-align: left">XCALibre.UNV3</td><td style="text-align: left">Stand alone module to parse, process (geometry calculation) and import UNV (3D) mesh files into XCALibre.jl</td></tr><tr><td style="text-align: left">XCALibre.UNV2</td><td style="text-align: left">Stand alone module to parse, process (geometry calculation) and import UNV (2D) mesh files into XCALibre.jl</td></tr></table><h2 id="Key-types-and-structures"><a class="docs-heading-anchor" href="#Key-types-and-structures">Key types and structures</a><a id="Key-types-and-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Key-types-and-structures" title="Permalink"></a></h2><hr/><h3 id="Mesh-type-and-format"><a class="docs-heading-anchor" href="#Mesh-type-and-format">Mesh type and  format</a><a id="Mesh-type-and-format-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-type-and-format" title="Permalink"></a></h3><p>The definitions of the data structures used to define <code>Mesh3</code> objects is given below. Note that for succinctness only 3D structures are shown since all the 2D structures are identical. The type is only used for dispatching solvers to operate in 2D or 3D. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Mesh3-contributor_guide" href="#XCALibre.Mesh.Mesh3-contributor_guide"><code>XCALibre.Mesh.Mesh3</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Mesh3{VC, VI, VF&lt;:AbstractArray{&lt;:Face3D}, VB, VN, SV3, UR} &lt;: AbstractMesh
    cells::VC           # vector of cells
    cell_nodes::VI      # vector of indices to access cell nodes
    cell_faces::VI      # vector of indices to access cell faces
    cell_neighbours::VI # vector of indices to access cell neighbours
    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )
    faces::VF           # vector of faces
    face_nodes::VI      # vector of indices to access face nodes
    boundaries::VB      # vector of boundaries
    nodes::VN           # vector of nodes
    node_cells::VI      # vector of indices to access node cells
    get_float::SV3      # store mesh float type
    get_int::UR         # store mesh integer type
    boundary_cellsID::VI # vector of indices of boundary cell IDs
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Mesh/Mesh_0_types.jl#L151-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Node-contributor_guide" href="#XCALibre.Mesh.Node-contributor_guide"><code>XCALibre.Mesh.Node</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Node{SV3&lt;:SVector{3,&lt;:AbstractFloat}, UR&lt;:UnitRange{&lt;:Integer}}
    coords::SV3     # node coordinates
    cells_range::UR # range to access neighbour cells in Mesh3.node_cells
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Mesh/Mesh_0_types.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Face3D-contributor_guide" href="#XCALibre.Mesh.Face3D-contributor_guide"><code>XCALibre.Mesh.Face3D</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Face3D{
    F&lt;:AbstractFloat, 
    SV2&lt;:SVector{2,&lt;:Integer},
    SV3&lt;:SVector{3,F}, 
    UR&lt;:UnitRange{&lt;:Integer}
    }
    
    nodes_range::UR # range to access face nodes in Mesh3.face_nodes
    ownerCells::SV2 # IDs of face owner cells (always 2)
    centre::SV3     # coordinates of face centre
    normal::SV3     # face normal unit vector
    e::SV3          # unit vector in the direction between owner cells
    area::F         # face area
    delta::F        # distance between owner cells centres
    weight::F       # linear interpolation weight
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Mesh/Mesh_0_types.jl#L82-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Cell-contributor_guide" href="#XCALibre.Mesh.Cell-contributor_guide"><code>XCALibre.Mesh.Cell</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Cell{F&lt;:AbstractFloat, SV3&lt;:SVector{3,F},UR&lt;:UnitRange{&lt;:Integer}}
    centre::SV3     # coordinate of cell centroid
    volume::F       # cell volume
    nodes_range::UR # range to access cell nodes in Mesh3.cell_nodes
    faces_range::UR # range to access cell faces info (faces, neighbours cells, etc.)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Mesh/Mesh_0_types.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Boundary-contributor_guide" href="#XCALibre.Mesh.Boundary-contributor_guide"><code>XCALibre.Mesh.Boundary</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Boundary{S&lt;:Symbol, UR&lt;:UnitRange{&lt;:Integer}}
    name::S         # Boundary patch name
    IDs_range::UR   # range to access boundary info (faces and boundary_cellsID)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Mesh/Mesh_0_types.jl#L22-L27">source</a></section></article><p>To fully characterise how mesh information is represented in XCALibre.jl, it is important to highlight the following &quot;contracts&quot; that are exploited throughout:</p><ul><li>Node, face and cell IDs correspond to the index where they are stored in their corresponding vector in the <code>Mesh3</code> structure e.g. <code>Mesh3.Faces[10]</code> would return information for the face whose ID is 10. These vectors are 1-indexed as standard in Julia.</li><li>Face normals at boundary faces is always pointing outside the domain e.g. they point in the direction expected in the FVM</li><li>Face normals for internal faces is always pointing in the direction from the ownerCell with the smallest ID to the largest. Since the discretisation loop is cell based, for the cell with the highest ID the direction must be reversed. This information is tracked in <code>Mesh3.nsign</code> which stores 1 if the face normal is correctly aligned or -1 if the normal needs to be reversed.</li><li>Boundary faces (e.g. patches) are stored consecutively in <code>Mesh3.Faces</code> starting at the beginning of the array followed by all the internal faces.</li><li>Boundary faces are those connected only to 1 <code>Cell</code>, thus, for these faces the entry <code>Face3D.ownerCells</code> is a 2-element vector with a repeated index e.g. [3, 3]</li><li>Boundary cells only store information for internal faces. This improves performance for the main discretisation loop (cell based) since it can always been assumed that none of the faces will be a boundary face, which are dealt with in a separate loop.</li></ul><h3 id="Field-types"><a class="docs-heading-anchor" href="#Field-types">Field types</a><a id="Field-types-1"></a><a class="docs-heading-anchor-permalink" href="#Field-types" title="Permalink"></a></h3><p>After the <code>Mesh2</code> and <code>Mesh3</code> objects, the most fundamental data structure in XCALibre.jl are fields used to represent the flow variables. In the current implementation, the prime field is the <code>ScalarField</code> for storing information at cell centres, and the corresponding <code>FaceScalarField</code> to store information at cell faces (normally fluxes). Internally, both are identical, therefore, the internal structure of the &quot;Face&quot; variants will not be discussed. <code>ScalarFields</code> have the following definition:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Fields.ScalarField-contributor_guide" href="#XCALibre.Fields.ScalarField-contributor_guide"><code>XCALibre.Fields.ScalarField</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ScalarField{VF,M,BC} &lt;: AbstractScalarField
    values::VF  # scalar values at cell centre
    mesh::M     # reference to mesh
    BCs::BC     # store user-provided boundary conditions
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Fields/Fields_0_types.jl#L49-L55">source</a></section></article><p>Vector and tensors are represented internally by their individual components, as an illustration the <code>VectorField</code> type is shown below. Notice that each component of both vector and tensor fields are themselves represented by the same <code>ScalarField</code> type shown above. This has some implementation benefits, i.e. reducing duplication and allowing for rapid development. However, the performance of other means of storing these fields is being investigated. Thus, these internals may change if we identify performance gains.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Fields.VectorField-contributor_guide" href="#XCALibre.Fields.VectorField-contributor_guide"><code>XCALibre.Fields.VectorField</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct VectorField{S1&lt;:ScalarField,S2,S3,M&lt;:AbstractMesh,BC} &lt;: AbstractVectorField
    x::S1   # x-component is itself a `ScalarField`
    y::S2   # y-component is itself a `ScalarField`
    z::S3   # z-component is itself a `ScalarField`
    mesh::M
    BCs::BC
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Fields/Fields_0_types.jl#L104-L112">source</a></section></article><p>All fields behave (mostly) like regular arrays and can be indexed using the standard Julia syntax e.g. say <code>U</code> is a <code>VectorField</code>, then <code>U[3]</code> would return the vector stored in cell with ID = 3 (as a <code>SVector{3}</code> for improved performance).</p><div class="admonition is-info" id="Note-721d402d2d6d6868"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-721d402d2d6d6868" title="Permalink"></a></header><div class="admonition-body"><p>The implementation of broadcasting operations has been put on hold until a more thorough investigation of alternative data structures for vector and tensor fields has been completed. This is ongoing work. </p></div></div><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><hr/><p>To implement a new boundary condition the following elements are required (see source code for <a href="../reference/#XCALibre.Discretise.Dirichlet"><code>Dirichlet</code></a>, for example):</p><ul><li>type definition: a structure containing the fields <code>:ID</code> and <code>:value</code></li><li><code>fixedValue</code> function: used to check that user provided information is suitable for this boundary being implemented</li><li>Implementation of the boundary face value: functor defining the boundary condition implementation, facilitated by a macro (see details below)</li><li>Scalar and vector face value interpolation: kernels to specify how to transfer cell information to the boundary. </li></ul><p>Developers and contributors are encouraged to explore the source code for examples on existing implementations of boundary conditions. To ease their implementation the <a href="#XCALibre.Discretise.@define_boundary-contributor_guide"><code>XCALibre.Discretise.@define_boundary</code></a> is provided.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Discretise.@define_boundary-contributor_guide" href="#XCALibre.Discretise.@define_boundary-contributor_guide"><code>XCALibre.Discretise.@define_boundary</code></a> ‚Äî <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">macro define_boundary(boundary, operator, definition)
    quote
        @inline (bc::$boundary)(
            term::Operator{F,P,I,$operator}, cellID, zcellID, cell, face, fID, i, component, time
            ) where {F,P,I} = $definition
    end |&gt; esc
end</code></pre><p>Macro to reduce boilerplate code when defining boundary conditions (implemented as functors) and provides access to key fields needed in the implementation of boundary conditions, such as the boundary cell and face objects (more details below)</p><p><strong>Input arguments</strong></p><ul><li><code>boundary</code> specifies the boundary type being defined</li><li><code>operator</code> specifies the operator to which the condition applies e.g. <code>Laplacian</code></li><li><code>definition</code> provides the implementation details</li></ul><p><strong>Available fields</strong></p><ul><li><code>term</code> reference to operator on which the boundary applies (gives access to the field and mesh) </li><li><code>cellID</code> ID of the corresponding boundary cell</li><li><code>zcellID</code> sparse matrix linear index for the cell</li><li><code>cell</code> gives access to boundary cell object and corresponding information</li><li><code>face</code> gives access to boundary face object and corresponding information</li><li><code>fID</code> ID of the boundary face (to index <code>Mesh2.faces</code> vector)</li><li><code>i</code> local index of the boundary faces within a kernel or loop</li><li><code>component</code> for vectors this specifies the components being evaluated (access as <code>component.value</code>). For scalars <code>component = nothing</code></li><li><code>time</code> provides the current simulation time. This only applies to time dependent boundary implementation defined as functions or neural networks.</li></ul><p><strong>Example</strong></p><p>Below the use of this macro is illustrated for the implementation of a  <code>Dirichlet</code> boundary condition acting on the <code>Laplacian</code> using the <code>Linear</code> scheme:</p><pre><code class="nohighlight hljs">@define_boundary Dirichlet Laplacian{Linear} begin
    J = term.flux[fID]      # extract operator flux
    (; area, delta) = face  # extract boundary face information
    flux = J*area/delta     # calculate the face flux
    ap = term.sign*(-flux)  # diagonal (cell) matrix coefficient
    ap, ap*bc.value         # return `ap` and `an`
end</code></pre><p>When called, this functor will return two values <code>ap</code> and <code>an</code>, where <code>ap</code> is the cell contribution for approximating the boundary face value, and <code>an</code> is the explicit part of the face value approximation i.e. <code>ap</code> contributes to the diagonal of the sparse matrix (left-hand side) and <code>an</code> is the explicit contribution assigned to the solution vector <code>b</code> on the right-hand of the linear system of equations <span>$Ax = b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/c2395eea3cc1dd5a0cf9f8ffc4d132ba38518f8a/src/Discretise/boundary_conditions/0_definition_macro.jl#L2-L45">source</a></section></article><h2 id="Implementing-new-models"><a class="docs-heading-anchor" href="#Implementing-new-models">Implementing new models</a><a id="Implementing-new-models-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-new-models" title="Permalink"></a></h2><hr/><p>The internal API for models is still somewhat experimental, thus, it is more instructive to explore the source code. Although not fully finalised, the implementation is reasonably straight forward to follow thanks to the abstractions that have been adopted, some of which are described above, as well as the use of descriptive names for internal functions. If you need help on any aspect of the internals, for now, it is recommended to contact us by opening an issue.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">¬´ Benchmarks</a><a class="docs-footer-nextpage" href="../reference/">Reference ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Sunday 26 October 2025 02:20">Sunday 26 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
