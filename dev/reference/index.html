<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · XCALibre.jl</title><meta name="title" content="Reference · XCALibre.jl"/><meta property="og:title" content="Reference · XCALibre.jl"/><meta property="twitter:title" content="Reference · XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../examples/04_2d-inflow-using-Flux/">Advanced: Inflow condition using Machine Learning (<code>Flux.jl</code>)</a></li><li><a class="tocitem" href="../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li><li><a class="tocitem" href="../examples/06_2d-laplace-solver/">Validation: Laplace Solver in 2D Solid Medium</a></li><li><a class="tocitem" href="../examples/07_2d-bump-komegaSST/">Verification: 2D bump <span>$k-\omega$</span> SST</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../user_guide/0_introduction_and_workflow/">Introduction</a></li><li><a class="tocitem" href="../user_guide/1_preprocessing/">Pre-processing</a></li><li><a class="tocitem" href="../user_guide/2_physics_and_models/">Physics and models</a></li><li><a class="tocitem" href="../user_guide/3_numerical_setup/">Numerical setup</a></li><li><a class="tocitem" href="../user_guide/4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../user_guide/5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../contributor_guide/">Contributor Guide</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li><li><a class="tocitem" href="../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="XCALibre.Mesh.Boundary"><a class="docstring-binding" href="#XCALibre.Mesh.Boundary"><code>XCALibre.Mesh.Boundary</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Boundary{S&lt;:Symbol, UR&lt;:UnitRange{&lt;:Integer}}
    name::S         # Boundary patch name
    IDs_range::UR   # range to access boundary info (faces and boundary_cellsID)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Mesh/Mesh_0_types.jl#L22-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Mesh.Cell"><a class="docstring-binding" href="#XCALibre.Mesh.Cell"><code>XCALibre.Mesh.Cell</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Cell{F&lt;:AbstractFloat, SV3&lt;:SVector{3,F},UR&lt;:UnitRange{&lt;:Integer}}
    centre::SV3     # coordinate of cell centroid
    volume::F       # cell volume
    nodes_range::UR # range to access cell nodes in Mesh3.cell_nodes
    faces_range::UR # range to access cell faces info (faces, neighbours cells, etc.)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Mesh/Mesh_0_types.jl#L35-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Mesh.Face3D"><a class="docstring-binding" href="#XCALibre.Mesh.Face3D"><code>XCALibre.Mesh.Face3D</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Face3D{
    F&lt;:AbstractFloat, 
    SV2&lt;:SVector{2,&lt;:Integer},
    SV3&lt;:SVector{3,F}, 
    UR&lt;:UnitRange{&lt;:Integer}
    }
    
    nodes_range::UR # range to access face nodes in Mesh3.face_nodes
    ownerCells::SV2 # IDs of face owner cells (always 2)
    centre::SV3     # coordinates of face centre
    normal::SV3     # face normal unit vector
    e::SV3          # unit vector in the direction between owner cells
    area::F         # face area
    delta::F        # distance between owner cells centres
    weight::F       # linear interpolation weight
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Mesh/Mesh_0_types.jl#L82-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Mesh.Mesh3"><a class="docstring-binding" href="#XCALibre.Mesh.Mesh3"><code>XCALibre.Mesh.Mesh3</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Mesh3{VC, VI, VF&lt;:AbstractArray{&lt;:Face3D}, VB, VN, SV3, UR} &lt;: AbstractMesh
    cells::VC           # vector of cells
    cell_nodes::VI      # vector of indices to access cell nodes
    cell_faces::VI      # vector of indices to access cell faces
    cell_neighbours::VI # vector of indices to access cell neighbours
    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )
    faces::VF           # vector of faces
    face_nodes::VI      # vector of indices to access face nodes
    boundaries::VB      # vector of boundaries
    nodes::VN           # vector of nodes
    node_cells::VI      # vector of indices to access node cells
    get_float::SV3      # store mesh float type
    get_int::UR         # store mesh integer type
    boundary_cellsID::VI # vector of indices of boundary cell IDs
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Mesh/Mesh_0_types.jl#L151-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Mesh.Node"><a class="docstring-binding" href="#XCALibre.Mesh.Node"><code>XCALibre.Mesh.Node</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Node{SV3&lt;:SVector{3,&lt;:AbstractFloat}, UR&lt;:UnitRange{&lt;:Integer}}
    coords::SV3     # node coordinates
    cells_range::UR # range to access neighbour cells in Mesh3.node_cells
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Mesh/Mesh_0_types.jl#L9-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.UNV2.UNV2D_mesh-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.UNV2.UNV2D_mesh-Tuple{Any}"><code>XCALibre.UNV2.UNV2D_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UNV2D_mesh(meshFile; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 2D UNV mesh file into XCALibre.jl</p><p><strong>Input</strong></p><ul><li><code>meshFile</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/UNV2/UNV2_3_builder.jl#L3-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.UNV3.UNV3D_mesh-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.UNV3.UNV3D_mesh-Tuple{Any}"><code>XCALibre.UNV3.UNV3D_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">UNV3D_mesh(unv_mesh; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D UNV mesh file into XCALibre.jl. Note that a limitation of the .unv mesh format is that it only supports the following 3D cells:</p><ul><li>Tetahedrals</li><li>Prisms</li><li>Hexahedrals</li></ul><p><strong>Input</strong></p><ul><li><code>unv_mesh</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/UNV3/UNV3_2_builder.jl#L3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.FoamMesh.FOAM3D_mesh-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.FoamMesh.FOAM3D_mesh-Tuple{Any}"><code>XCALibre.FoamMesh.FOAM3D_mesh</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FOAM3D_mesh(mesh_file; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D OpenFOAM mesh file into XCALibre.jl. Note that, at present, it is not recommended to run 2D cases using meshes imported using this function.</p><p><strong>Input</strong></p><ul><li><code>mesh_file</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/FoamMesh/FoamMesh_5_build.jl#L3-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Multithread.activate_multithread-Tuple{CPU}"><a class="docstring-binding" href="#XCALibre.Multithread.activate_multithread-Tuple{CPU}"><code>XCALibre.Multithread.activate_multithread</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">activate_multithread(backend::CPU; nthreads=1) = BLAS.set_num_threads(nthreads)</code></pre><p>Convenience function to set number of BLAS threads. </p><p><strong>Input arguments</strong></p><ul><li><code>backend</code> is the only required input which must be <code>CPU()</code> from <code>KernelAbstractions.jl</code></li><li><code>nthreads</code> can be used to set the number of BLAS cores (default <code>nthreads=1</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Multithread/spmvm.jl#L70-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Fields.ScalarField"><a class="docstring-binding" href="#XCALibre.Fields.ScalarField"><code>XCALibre.Fields.ScalarField</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ScalarField{VF,M,BC} &lt;: AbstractScalarField
    values::VF  # scalar values at cell centre
    mesh::M     # reference to mesh
    BCs::BC     # store user-provided boundary conditions
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Fields/Fields_0_types.jl#L49-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Fields.VectorField"><a class="docstring-binding" href="#XCALibre.Fields.VectorField"><code>XCALibre.Fields.VectorField</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct VectorField{S1&lt;:ScalarField,S2,S3,M&lt;:AbstractMesh,BC} &lt;: AbstractVectorField
    x::S1   # x-component is itself a `ScalarField`
    y::S2   # y-component is itself a `ScalarField`
    z::S3   # z-component is itself a `ScalarField`
    mesh::M
    BCs::BC
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Fields/Fields_0_types.jl#L104-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Fields.initialise!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Fields.initialise!-Tuple{Any, Any}"><code>XCALibre.Fields.initialise!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function initialise!(field, value) # dummy function for documentation
    # Assign `value` to field in-place
    nothing
end</code></pre><p>This function will set the given <code>field</code> to the <code>value</code> provided in-place. Useful for initialising fields prior to running a simulation.</p><p><strong>Input arguments</strong></p><ul><li><code>field</code> specifies the field to be initialised. The field must be either a <code>AbractScalarField</code> or <code>AbstractVectorField</code></li><li><code>value</code> defines the value to be set. This should be a scalar or vector (3 components) depending on the field to be modified e.g. for an <code>AbstractVectorField</code> we can specify as <code>value=[10,0,0]</code></li></ul><p>Note: in most cases the fields to be modified are stored within a physics model i.e. a <code>Physics</code> object. Thus, the argument <code>value</code> must fully qualify the model. For example, if we have created a <code>Physics</code> model named <code>mymodel</code> to set the velocity field, <code>U</code>, we would set the argument <code>field</code> to <code>mymodel.momentum.U</code>. See the example below.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">initialise!(mymodel.momentum.U, [2.5, 0, 0])
initialise!(mymodel.momentum.p, 1.25)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Fields/Fields_0_types.jl#L354-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Dirichlet"><a class="docstring-binding" href="#XCALibre.Discretise.Dirichlet"><code>XCALibre.Discretise.Dirichlet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Dirichlet &lt;: AbstractDirichlet</code></pre><p>Dirichlet boundary condition model.</p><p><strong>Inputs</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> Scalar or Vector value for Dirichlet boundary condition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/dirichlet.jl#L3-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.DirichletFunction"><a class="docstring-binding" href="#XCALibre.Discretise.DirichletFunction"><code>XCALibre.Discretise.DirichletFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DirichletFunction(ID, value) &lt;: AbstractDirichlet</code></pre><p>Dirichlet boundary condition defined with user-provided function.</p><p><strong>Input</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> Custom function or struct (&lt;:XCALibreUserFunctor) for Dirichlet boundary condition</li><li><code>IDs_range</code> Range of indices to access boundary patch faces</li></ul><p><strong>Function requirements</strong></p><p>The function passed to this boundary condition must have the following signature:</p><pre><code class="nohighlight hljs">f(coords, time, index) = SVector{3}(ux, uy, uz)</code></pre><p>For a vector-value field, or: </p><pre><code class="nohighlight hljs">f(coords, time, index) = p::Number</code></pre><p>for a scalar field. In both cases, <code>coords</code> is the coordinate vector of the face, <code>time</code> is the current time (or iteration counter in steady simulations), and <code>index</code> is the local face index from <code>1</code> to <code>N</code>, where <code>N</code> is the number of faces on the boundary. The function must return either a three-component <code>SVector</code> (StaticArrays.jl) or a plain numeric value, depending on whether the boundary condition represents a vector or scalar field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/dirichletFunction.jl#L6-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Empty"><a class="docstring-binding" href="#XCALibre.Discretise.Empty"><code>XCALibre.Discretise.Empty</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Empty &lt;: AbstractPhysicalConstraint</code></pre><p>Empty boundary condition model <em>(currently only configured for zero gradient)</em></p><p><strong>Fields</strong></p><ul><li>&#39;ID&#39; – Boundary ID</li><li><code>value</code> – Scalar or Vector value for Empty boundary condition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/empty.jl#L9-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Extrapolated"><a class="docstring-binding" href="#XCALibre.Discretise.Extrapolated"><code>XCALibre.Discretise.Extrapolated</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Extrapolated &lt;: AbstractNeumann</code></pre><p>This boundary condition extrapolates the face value using the interior cell value. Equivalent to setting a zero gradient boundary condition (semi-implicitly). It applies to both scalar and vector fields.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Extrapolated(:outlet)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/extrapolated.jl#L4-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.FixedTemperature"><a class="docstring-binding" href="#XCALibre.Discretise.FixedTemperature"><code>XCALibre.Discretise.FixedTemperature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FixedTemperature(name::Symbol, model::Enthalpy; T::Number)</code></pre><p>Fixed temperature boundary condition model, which allows the user to specify wall temperature that can be translated to the energy specific model, such as sensible enthalpy.</p><p><strong>Inputs</strong></p><ul><li><code>name</code>: Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>T</code>: keyword argument use to define the boundary temperature </li><li><code>model</code>: defines the underlying <code>Energy</code> model to be used (currently only <code>Enthalpy</code> is available)</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">FixedTemperature(:inlet, T=300.0, Enthalpy(cp=cp, Tref=288.15))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/fixedTemperature.jl#L4-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Neumann"><a class="docstring-binding" href="#XCALibre.Discretise.Neumann"><code>XCALibre.Discretise.Neumann</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Neumann &lt;: AbstractNeumann</code></pre><p>Neumann boundary condition model to set the gradient at the boundary explicitly <em>(currently only configured for zero gradient)</em></p><p><strong>Inputs</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> Scalar providing face normal gradient</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Neumann(:outlet, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/neumann.jl#L4-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.NeumannFunction"><a class="docstring-binding" href="#XCALibre.Discretise.NeumannFunction"><code>XCALibre.Discretise.NeumannFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeumannFunction(ID, value) &lt;: AbstractNeumann</code></pre><p>Neumann boundary condition defined with user-provided function.</p><p><strong>Input</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> Custom function defining the desired Neumann boundary condition.</li></ul><p><strong>Function requirements</strong></p><p>The function passed to this boundary condition has not yet been implemented. However, users can pass a custom struct to specialise the internal implementations of many functions. By default, at present, this function will assign a zero gradient boundary condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/neumannFunction.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Periodic"><a class="docstring-binding" href="#XCALibre.Discretise.Periodic"><code>XCALibre.Discretise.Periodic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Periodic{I,V,R&lt;:UnitRange} &lt;: AbstractPhysicalConstraint
    ID::I
    value::V
end</code></pre><p>Implicit implementation of <code>Periodic</code> boundary condition. Note that to apply this condition two periodic patch pairs need to be constructed using the function <code>construct_periodic</code>. The implementation currently requires conformant patch pairs.</p><p><strong>Fields</strong></p><ul><li><code>ID</code> is the name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> tuple containing information needed to apply this boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/periodic.jl#L9-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.RotatingWall"><a class="docstring-binding" href="#XCALibre.Discretise.RotatingWall"><code>XCALibre.Discretise.RotatingWall</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RotatingWall &lt;: AbstractPhysicalConstraint</code></pre><p>RotatingWall boundary condition model for no-slip  for rotating RotatingWalls (rotating around an axis). It has been strictly implemented to work with vectors only. </p><p><strong>Inputs</strong></p><ul><li><code>rpm</code> provides the rotating speed (internally converted to radian/second)</li><li><code>centre</code> vector indicating the location of the rotation centre e.g. [0,0,0]</li><li><code>axis</code> unit vector indicating the rotation axis e.g. [1,0,0]</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">RotatingWall(:inner_wall, rpm=100, centre=[0,0,0], axis=[0,0,1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/rotating_wall.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Symmetry"><a class="docstring-binding" href="#XCALibre.Discretise.Symmetry"><code>XCALibre.Discretise.Symmetry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Symmetry &lt;: AbstractBoundary</code></pre><p>Symmetry boundary condition vector and scalar fields. Notice that for scalar fields, this boundary condition applies an explicit zero gradient condition. In some rare cases, the use of an <code>Extrapolated</code> condition for scalars may be beneficial (to assign a semi-implicit zero gradient condition)</p><p><strong>Input</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :freestream). Internally it gets replaced with the boundary index ID</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Symmetry(:freestream)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/symmetry.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Wall"><a class="docstring-binding" href="#XCALibre.Discretise.Wall"><code>XCALibre.Discretise.Wall</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Wall &lt;: AbstractDirichlet</code></pre><p>Wall boundary condition model for no-slip  or moving walls (linear motion). It should be applied to the velocity vector, and in most cases, its scalar variant should be applied to scalars.</p><p><strong>Inputs</strong></p><ul><li><code>ID</code> represents the name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li><li><code>value</code> should be given as a vector for the velocity e.g. [10,0,0]. For scalar fields such as the pressure the value entry can be omitted or set to zero explicitly.</li></ul><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">Wall(:plate, [0, 0, 0]) # no-slip wall condition for velocity
Wall(:plate) # corresponding definition for scalars, e.g. pressure
Wall(:plate, 0) # alternative definition for scalars, e.g. pressure</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/wall.jl#L3-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.Zerogradient"><a class="docstring-binding" href="#XCALibre.Discretise.Zerogradient"><code>XCALibre.Discretise.Zerogradient</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Zerogradient &lt;: AbstractNeumann</code></pre><p>Zerogradient boundary condition model <em>(explicitly applied to the boundary)</em></p><p><strong>Input</strong></p><ul><li><code>ID</code> Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Zerogradient(:inlet)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/zerogradient.jl#L4-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.construct_periodic-Tuple{Any, Any, Symbol, Symbol}"><a class="docstring-binding" href="#XCALibre.Discretise.construct_periodic-Tuple{Any, Any, Symbol, Symbol}"><code>XCALibre.Discretise.construct_periodic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_periodic(mesh, backend, patch1::Symbol, patch2::Symbol)</code></pre><p>Function for construction of periodic boundary conditions.</p><p><strong>Input</strong></p><ul><li><code>mesh</code> – Mesh.</li><li><code>backend</code>  – Backend configuraton.</li><li><code>patch1</code>  – Primary periodic patch ID.</li><li><code>patch2</code>   – Neighbour periodic patch ID.</li></ul><p><strong>Output</strong></p><ul><li><p>periodic::Tuple - tuple containing boundary definitions for <code>patch1</code> and <code>patch2</code> i.e. (periodic1, periodic2). The fields of <code>periodic1</code> and <code>periodic2</code> are </p><ul><li><code>ID</code> – Index to access boundary information in mesh object</li><li><code>value</code> represents a <code>PeriodicValue</code> struct with the following fields:<ul><li>index – ID used to find boundary geometry information in the mesh object</li><li>distance – perpendicular distance between the patches</li><li>face_map – vector providing indeces to faces of match patch</li><li>ismaster – flat to identify one of the patch pairs as the main patch</li></ul></li></ul></li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">- `periodic = construct_periodic(mesh, CPU(), :top, :bottom)` - Example using CPU 
backend with periodic boundaries named `top` and `bottom`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/periodic.jl#L56-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Discretise.@define_boundary-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#XCALibre.Discretise.@define_boundary-Tuple{Any, Any, Any}"><code>XCALibre.Discretise.@define_boundary</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">macro define_boundary(boundary, operator, definition)
    quote
        @inline (bc::$boundary)(
            term::Operator{F,P,I,$operator}, cellID, zcellID, cell, face, fID, i, component, time
            ) where {F,P,I} = $definition
    end |&gt; esc
end</code></pre><p>Macro to reduce boilerplate code when defining boundary conditions (implemented as functors) and provides access to key fields needed in the implementation of boundary conditions, such as the boundary cell and face objects (more details below)</p><p><strong>Input arguments</strong></p><ul><li><code>boundary</code> specifies the boundary type being defined</li><li><code>operator</code> specifies the operator to which the condition applies e.g. <code>Laplacian</code></li><li><code>definition</code> provides the implementation details</li></ul><p><strong>Available fields</strong></p><ul><li><code>term</code> reference to operator on which the boundary applies (gives access to the field and mesh) </li><li><code>cellID</code> ID of the corresponding boundary cell</li><li><code>zcellID</code> sparse matrix linear index for the cell</li><li><code>cell</code> gives access to boundary cell object and corresponding information</li><li><code>face</code> gives access to boundary face object and corresponding information</li><li><code>fID</code> ID of the boundary face (to index <code>Mesh2.faces</code> vector)</li><li><code>i</code> local index of the boundary faces within a kernel or loop</li><li><code>component</code> for vectors this specifies the components being evaluated (access as <code>component.value</code>). For scalars <code>component = nothing</code></li><li><code>time</code> provides the current simulation time. This only applies to time dependent boundary implementation defined as functions or neural networks.</li></ul><p><strong>Example</strong></p><p>Below the use of this macro is illustrated for the implementation of a  <code>Dirichlet</code> boundary condition acting on the <code>Laplacian</code> using the <code>Linear</code> scheme:</p><pre><code class="nohighlight hljs">@define_boundary Dirichlet Laplacian{Linear} begin
    J = term.flux[fID]      # extract operator flux
    (; area, delta) = face  # extract boundary face information
    flux = J*area/delta     # calculate the face flux
    ap = term.sign*(-flux)  # diagonal (cell) matrix coefficient
    ap, ap*bc.value         # return `ap` and `an`
end</code></pre><p>When called, this functor will return two values <code>ap</code> and <code>an</code>, where <code>ap</code> is the cell contribution for approximating the boundary face value, and <code>an</code> is the explicit part of the face value approximation i.e. <code>ap</code> contributes to the diagonal of the sparse matrix (left-hand side) and <code>an</code> is the explicit contribution assigned to the solution vector <code>b</code> on the right-hand of the linear system of equations <span>$Ax = b$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Discretise/boundary_conditions/0_definition_macro.jl#L2-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solve.JacobiSmoother"><a class="docstring-binding" href="#XCALibre.Solve.JacobiSmoother"><code>XCALibre.Solve.JacobiSmoother</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct JacobiSmoother{L,F,V} &lt;: AbstractSmoother
    loops::L
    omega::F
    x_temp::V
end</code></pre><p>Structure to hold information for using the weighted Jacobi smoother. </p><p><strong>Fields</strong></p><ul><li><code>loops</code> represents the number of smoothing iterations.</li><li><code>omega</code> represents the relaxation weight, 1 corresponds to no weighting. Typically a weight of 2/3 is used to filter high frequencies in the residual field.</li><li><code>x_temp</code> is a vector used internally to store intermediate solutions.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">JacobiSmoother(mesh::AbstractMesh)</code></pre><p>This constructor takes a mesh object as input to create the smoother. The number of cells in the mesh is used to allocate <code>x_temp</code>. The number of loops and smoother factor are set to 5 and 1, respectively.</p><pre><code class="nohighlight hljs">JacobiSmoother(; domain, loops, omega=2/3)</code></pre><p>Alternative constructor for <code>JacobiSmoother</code>.</p><p><strong>keyword arguments</strong></p><ul><li><code>domain</code> represents a mesh object of type <code>AbstractMesh</code>.</li><li><code>loops</code> is the number of iterations to be used</li><li><code>omega</code> represents the weighting factor, 1 does not relax the system, 2/3 is found to work well for smoothing high frequencies in the residual field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solve/Smoothers/Smoothers_jacobi.jl#L5-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solve.Runtime-Union{Tuple{}, Tuple{N}, Tuple{I}} where {I&lt;:Integer, N&lt;:Number}"><a class="docstring-binding" href="#XCALibre.Solve.Runtime-Union{Tuple{}, Tuple{N}, Tuple{I}} where {I&lt;:Integer, N&lt;:Number}"><code>XCALibre.Solve.Runtime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Runtime(; 
        # keyword arguments

        iterations::I, 
        write_interval::I, 
        time_step::N
    ) where {I&lt;:Integer,N&lt;:Number} = begin
    
    # returned Runtime struct
    Runtime{I&lt;:Integer,F&lt;:AbstractFloat}
        (
            iterations=iterations, 
            dt=time_step, 
            write_interval=write_interval
        )
end</code></pre><p>This is a convenience function to set the top-level runtime information. The inputs are all keyword arguments and provide basic information to flow solvers just before running a simulation.</p><p><strong>Input arguments</strong></p><ul><li><code>iterations::Integer</code>: specifies the number of iterations in a simulation run.</li><li><code>write_interval::Integer</code>: defines how often simulation results are written to file (on the current working directory). The interval is currently based on number of iterations. Set to <code>-1</code> to run without writing results to file.</li><li><code>time_step::AbstractFloat</code>: the time step to use in the simulation. Notice that for steady solvers this is simply a counter and it is recommended to simply use <code>1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">runtime = Runtime(iterations=2000, time_step=1, write_interval=2000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solve/Solve_1_api.jl#L90-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solve.Schemes"><a class="docstring-binding" href="#XCALibre.Solve.Schemes"><code>XCALibre.Solve.Schemes</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Schemes(;
    # keyword arguments and their default values
    time=SteadyState,
    divergence=Linear, 
    laplacian=Linear, 
    gradient=Gauss,
    limiter=nothing) = begin

    # Returns Schemes struct used to configure discretisation
    
    Schemes(
        time=time,
        divergence=divergence,
        laplacian=laplacian,
        gradient=gradient,
        limiter=limiter
    )   
end</code></pre><p>The <code>Schemes</code> struct is used at the top-level API to help users define discretisation schemes for every field solved.</p><p><strong>Inputs</strong></p><ul><li><code>time</code>: is used to set the time schemes (default is <code>SteadyState</code>)</li><li><code>divergence</code>: is used to set the divergence scheme (default is <code>Linear</code>) </li><li><code>laplacian</code>: is used to set the laplacian scheme (default is <code>Linear</code>)</li><li><code>gradient</code>:  is used to set the gradient scheme (default is <code>Gauss</code>)</li><li><code>limiter</code>: is used to specify if gradient limiters should be used, currently supported limiters include <code>FaceBased</code> and <code>MFaceBased</code> (default is <code>nothing</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solve/Solve_1_api.jl#L127-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solve.SolverSetup-Union{Tuple{}, Tuple{I}, Tuple{PT}, Tuple{S2}, Tuple{S1}} where {S1, S2, PT, I}"><a class="docstring-binding" href="#XCALibre.Solve.SolverSetup-Union{Tuple{}, Tuple{I}, Tuple{PT}, Tuple{S2}, Tuple{S1}} where {S1, S2, PT, I}"><code>XCALibre.Solve.SolverSetup</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SolverSetup(; 
        # required keyword arguments 

        solver::S, 
        preconditioner::PT, 
        convergence, 
        relax,

        # optional keyword arguments

        float_type=Float64,
        smoother=nothing,
        limit=nothing,
        itmax::Integer=1000, 
        atol=(eps(_get_float(region)))^0.9,
        rtol=_get_float(region)(1e-1)

    ) where {S,PT&lt;:PreconditionerType} = begin

        return SolverSetup(kwargs...)  
end</code></pre><p>This function is used to provide solver settings that will be used internally in XCALibre.jl. It returns a <code>SolverSetup</code> object with solver settings that are used internally by the flow solvers. </p><p><strong>Input arguments</strong></p><ul><li><code>solver</code>: solver object from Krylov.jl and it could be one of <code>Bicgstab()</code>, <code>Cg()</code>, <code>Gmres()</code> which are re-exported in XCALibre.jl</li><li><code>preconditioner</code>: instance of preconditioner to be used e.g. Jacobi()</li><li><code>convergence</code> sets the stopping criteria of this field</li><li><code>relax</code>: specifies the relaxation factor to be used e.g. set to 1 for no relaxation</li><li><code>smoother</code>: specifies smoothing method to be applied before discretisation. <code>JacobiSmoother</code>: is currently the only choice (defaults to <code>nothing</code>)</li><li><code>limit</code>: used in some solvers to bound the solution within these limits e.g. (min, max). It defaults to <code>nothing</code></li><li><code>itmax</code>: maximum number of iterations in a single solver pass (defaults to 1000) </li><li><code>atol</code>: absolute tolerance for the solver (default to eps(FloatType)^0.9)</li><li><code>rtol</code>: set relative tolerance for the solver (defaults to 1e-1)</li><li><code>float_type</code>: specifies the floating point type to be used by the solver. It is also used to estimate the absolute tolerance for the solver (defaults to <code>Float64</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solve/Solve_1_api.jl#L25-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Compressible"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Compressible"><code>XCALibre.ModelPhysics.Compressible</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Compressible &lt;: AbstractCompressible</code></pre><p>Compressible fluid model containing fluid field parameters for compressible flows with      constant parameters - ideal gas with constant viscosity.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;cp&#39;   – Fluid specific heat capacity.</li><li><code>gamma</code> – Ratio of specific heats.</li><li><code>Pr</code>   – Fluid Prantl number.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{Compressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7)</code> - Constructur with default values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/2_fluid_models.jl#L110-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Conduction"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Conduction"><code>XCALibre.ModelPhysics.Conduction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Conduction &lt;: AbstractEnergyModel</code></pre><p>Type that represents energy conduction model for solids.</p><p><strong>Fields</strong></p><ul><li><code>T</code> Temperature scalar field on cells (ScalarField).</li><li><code>Tf</code> Temperature scalar field on faces (FaceScalarField).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Conduction.jl#L3-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Fluid"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Fluid"><code>XCALibre.ModelPhysics.Fluid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Fluid &lt;: AbstractFluid</code></pre><p>Abstract fluid model type for constructing new fluid models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/2_fluid_models.jl#L12-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.HelmholtzFluidConstants"><a class="docstring-binding" href="#XCALibre.ModelPhysics.HelmholtzFluidConstants"><code>XCALibre.ModelPhysics.HelmholtzFluidConstants</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Stores all fluid-specific constants required for the Helmholtz Equation of State, ancillary equations, and associated property calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L2-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Incompressible"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Incompressible"><code>XCALibre.ModelPhysics.Incompressible</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Incompressible &lt;: AbstractIncompressible</code></pre><p>Incompressible fluid model containing fluid field parameters for incompressible flows.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;rho&#39;  – Fluid density.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{Incompressible}(nu=0.001, rho=1.0)</code> - Constructor with default values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/2_fluid_models.jl#L25-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.KEquation"><a class="docstring-binding" href="#XCALibre.ModelPhysics.KEquation"><code>XCALibre.ModelPhysics.KEquation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KEquation &lt;: AbstractTurbulenceModel</code></pre><p>KEquation LES model containing all Smagorinksy field parameters.</p><p><strong>Fields</strong></p><ul><li><code>nut</code> – Eddy viscosity ScalarField.</li><li><code>nutf</code> – Eddy viscosity FaceScalarField.</li><li><code>coeffs</code> – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_KEquation.jl#L4-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.KOmega"><a class="docstring-binding" href="#XCALibre.ModelPhysics.KOmega"><code>XCALibre.ModelPhysics.KOmega</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KOmega &lt;: AbstractTurbulenceModel</code></pre><p>kOmega model containing all kOmega field parameters.</p><p><strong>Fields</strong></p><ul><li><code>k</code> – Turbulent kinetic energy ScalarField.</li><li><code>omega</code> – Specific dissipation rate ScalarField.</li><li><code>nut</code> – Eddy viscosity ScalarField.</li><li><code>kf</code> – Turbulent kinetic energy FaceScalarField.</li><li><code>omegaf</code> – Specific dissipation rate FaceScalarField.</li><li><code>nutf</code> – Eddy viscosity FaceScalarField.</li><li><code>coeffs</code> – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L7-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.KOmegaLKE"><a class="docstring-binding" href="#XCALibre.ModelPhysics.KOmegaLKE"><code>XCALibre.ModelPhysics.KOmegaLKE</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KOmegaLKE &lt;: AbstractTurbulenceModel</code></pre><p>kOmega model containing all kOmega field parameters.</p><p><strong>Fields</strong></p><ul><li><code>k</code> – Turbulent kinetic energy ScalarField.</li><li><code>omega</code> – Specific dissipation rate ScalarField.</li><li><code>kl</code> – ScalarField.</li><li><code>nut</code> – Eddy viscosity ScalarField.</li><li><code>kf</code> – Turbulent kinetic energy FaceScalarField.</li><li><code>omegaf</code> – Specific dissipation rate FaceScalarField.</li><li><code>klf</code> – FaceScalarField.</li><li><code>nutf</code> – Eddy viscosity FaceScalarField.</li><li><code>coeffs</code> – Model coefficients.</li><li><code>Tu</code> – Freestream turbulence intensity for model.</li><li><code>y</code> – Near-wall distance for model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L4-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.KOmegaSST"><a class="docstring-binding" href="#XCALibre.ModelPhysics.KOmegaSST"><code>XCALibre.ModelPhysics.KOmegaSST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">KOmega &lt;: AbstractTurbulenceModel</code></pre><p>kOmega model containing all kOmega field parameters.</p><p><strong>Fields</strong></p><ul><li>&#39;k&#39; – Turbulent kinetic energy ScalarField.</li><li>&#39;omega&#39; – Specific dissipation rate ScalarField.</li><li>&#39;nut&#39; – Eddy viscosity ScalarField.</li><li>&#39;kf&#39; – Turbulent kinetic energy FaceScalarField.</li><li>&#39;omegaf&#39; – Specific dissipation rate FaceScalarField.</li><li>&#39;nutf&#39; – Eddy viscosity FaceScalarField.</li><li>&#39;coeffs&#39; – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaSST.jl#L7-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.LES"><a class="docstring-binding" href="#XCALibre.ModelPhysics.LES"><code>XCALibre.ModelPhysics.LES</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LES &lt;: AbstractLESModel</code></pre><p>Abstract LES model type for constructing LES models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/turbulence_types.jl#L26-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Laminar"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Laminar"><code>XCALibre.ModelPhysics.Laminar</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Laminar &lt;: AbstractTurbulenceModel</code></pre><p>Laminar model definition for physics API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_laminar.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Momentum"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Momentum"><code>XCALibre.ModelPhysics.Momentum</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Momentum{V,S,SS} &lt;: AbstractMomentumModel
    U::V 
    p::S 
    sources::SS
end</code></pre><p>Momentum model containing key momentum fields.</p><p><strong>Fields</strong></p><ul><li>&#39;U&#39;        – Velocity VectorField.</li><li>&#39;p&#39;        – Pressure ScalarField.</li><li>&#39;sources&#39;  – Momentum model sources.</li></ul><p><strong>Examples</strong></p><ul><li>`Momentum(mesh::AbstractMesh)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/0_type_definition.jl#L72-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Physics"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Physics"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Physics{T,F,SO,M,Tu,E,D,BI}
    time::T
    fluid::F
    solid::SO
    momentum::M 
    turbulence::Tu 
    energy::E
    domain::D
    boundary_info::BI
end</code></pre><p>XCALibre&#39;s parametric Physics type for user-level API. Also used to dispatch flow solvers.</p><p><strong>Fields</strong></p><ul><li><code>time::Union{Steady, Transient}</code>   – User-provided time model.</li><li><code>fluid::AbstractFluid</code>  – User-provided <code>Fluid</code>` model.</li><li><code>solid::AbstractSolid</code>  – User-provided <code>Solid</code>` model.</li><li><code>momentum</code>  – Momentum model. Currently this is auto-generated by the <code>Physics</code> constructor</li><li><code>turbulence::AbstractTurbulenceModel</code>  – User-provided <code>Turbulence</code>` model.</li><li><code>energy:AbstractEnergyModel</code>  – User-provided <code>Energy</code> model.</li><li><code>domain::AbstractMesh</code>  – User-provided <code>Mesh</code>. Must be adapted to target device before constructing a Physics object.</li><li><code>boundary_info::boundary_info</code>  – Mesh boundary information.  Auto-generated by the <code>Physics</code> constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/0_type_definition.jl#L7-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Physics-Tuple{}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Physics-Tuple{}"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Physics(; time, fluid, solid, turbulence, energy, domain)::Physics{T,F,SO,M,Tu,E,D,BI}</code></pre><p><code>Physics</code> constructor part of the top-level API. It can be used to define the Physics and models relevant to a simulation. This constructor uses keyword arguments to allow users to fine-tune their simulations, whilst some fields are auto-generated behind the scenes for convenience (<code>Momentum</code> and <code>boundary_info</code>). Where:</p><ul><li><code>time</code> - specified the time model (Steady or Transient)</li><li><code>fluid</code> - specifies the type of fluid (Incompressible, etc.)</li><li><code>turbulence</code> - specified the Turbulence model</li><li><code>energy</code> - specifies the Energy treatment</li><li><code>domain</code> - provides the mesh to used (must be adapted to the target backend device)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/0_type_definition.jl#L107-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.RANS"><a class="docstring-binding" href="#XCALibre.ModelPhysics.RANS"><code>XCALibre.ModelPhysics.RANS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RANS &lt;: AbstractRANSModel</code></pre><p>Abstract RANS model type for consturcting RANS models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/turbulence_types.jl#L14-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Smagorinsky"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Smagorinsky"><code>XCALibre.ModelPhysics.Smagorinsky</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Smagorinsky &lt;: AbstractTurbulenceModel</code></pre><p>Smagorinsky LES model containing all Smagorinksy field parameters.</p><p><strong>Fields</strong></p><ul><li><code>nut</code> – Eddy viscosity ScalarField.</li><li><code>nutf</code> – Eddy viscosity FaceScalarField.</li><li><code>coeffs</code> – Model coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L4-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Solid"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Solid"><code>XCALibre.ModelPhysics.Solid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Solid &lt;: AbstractSolid</code></pre><p>Abstract solid model type for constructing new solid models.</p><p><strong>Fields</strong></p><ul><li>&#39;args&#39; – Model arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/2_solid_models.jl#L10-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Steady"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Steady"><code>XCALibre.ModelPhysics.Steady</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Steady</code></pre><p>Steady model for Physics model API.</p><p><strong>Examples</strong></p><ul><li><code>Steady()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/0_type_definition.jl#L57-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Transient"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Transient"><code>XCALibre.ModelPhysics.Transient</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Transient</code></pre><p>Transient model for Physics model API.</p><p><strong>Examples</strong></p><ul><li><code>Transient()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/0_type_definition.jl#L46-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.WeaklyCompressible"><a class="docstring-binding" href="#XCALibre.ModelPhysics.WeaklyCompressible"><code>XCALibre.ModelPhysics.WeaklyCompressible</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WeaklyCompressible &lt;: AbstractCompressible</code></pre><p>Weakly compressible fluid model containing fluid field parameters for weakly compressible      flows with constant parameters - ideal gas with constant viscosity.</p><p><strong>Fields</strong></p><ul><li>&#39;nu&#39;   – Fluid kinematic viscosity.</li><li>&#39;cp&#39;   – Fluid specific heat capacity.</li><li><code>gamma</code> – Ratio of specific heats.</li><li><code>Pr</code>   – Fluid Prandtl number.</li></ul><p><strong>Examples</strong></p><ul><li><code>Fluid{WeaklyCompressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7)</code> - Constructor with </li></ul><p>default values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/2_fluid_models.jl#L61-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.EOS_wrapper-Union{Tuple{F}, Tuple{HelmholtzEnergyFluid, F, F, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.EOS_wrapper-Union{Tuple{F}, Tuple{HelmholtzEnergyFluid, F, F, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.EOS_wrapper</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Main high-level wrapper. Determines the fluid phase (liquid, vapor, two-phase, or supercritical) and computes a comprehensive set of thermodynamic properties for the given state (T, P).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L466-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.Ttoh!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.Ttoh!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.Ttoh!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Ttoh!(model::Physics{T1,F,SO,M,Tu,E,D,BI}, T::ScalarField, h::ScalarField
) where {T1,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function coverts temperature ScalarField to sensible enthalpy ScalarField.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>T</code>      – Temperature ScalarField.</li><li><code>h</code>      – Sensible enthalpy ScalarField.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L273-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.beta_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.beta_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.beta_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the isobaric expansion coefficient in 1/K.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.c_p-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.c_p-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.c_p</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the isobaric (constant pressure) heat capacity in J/(mol*K).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.c_v-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.c_v-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.c_v</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the isochoric (constant volume) heat capacity in J/(mol*K).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.change-Tuple{Physics, Any, Any}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.change-Tuple{Physics, Any, Any}"><code>XCALibre.ModelPhysics.change</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change(model::Physics, property, value) =&gt; updatedModel::Physics</code></pre><p>A convenience function to change properties of an exisitng <code>Physics</code> model.</p><p><strong>Input arguments</strong></p><ul><li><code>model::Physics</code> a <code>Physics</code> model to modify</li><li><code>property</code> is a symbol specifying the property to change </li><li><code>value</code> is the new setting for the specified <code>property</code></li></ul><p><strong>Output</strong></p><p>This function return a new <code>Physics</code> object</p><p><strong>Example</strong></p><p>To change a model to run a transient simulation e.g. after converging in steady state</p><pre><code class="nohighlight hljs">modelTransient = change(model, :time, Transient())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/3_physics_API.jl#L3-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.compute_pressure-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.compute_pressure-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.compute_pressure</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes pressure (in Pa) for a given temperature (K) and molar density (mol/m^3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.cv0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.cv0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.cv0_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the ideal-gas isochoric heat capacity (Cv0) in J/(mol*K) at a given temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.dPsat_dT-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.dPsat_dT-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.dPsat_dT</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculates the derivative of saturation pressure with respect to temperature (dPsat/dT) using the ancillary equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.energy!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{XCALibre.ModelPhysics.SensibleEnthalpyModel, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 6}}} where {T1, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.energy!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{XCALibre.ModelPhysics.SensibleEnthalpyModel, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 6}}} where {T1, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.energy!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">energy::SensibleEnthalpyModel, model::Physics{T1,F,SO,M,Tu,E,D,BI}, prev, mdotf, rho, mueff, time, config
) where {T1,F,SO,M,Tu,E,D,BI,E1}</code></pre><p>Run energy transport equations.</p><p><strong>Input</strong></p><ul><li><code>energy</code>: Energy model.</li><li><code>model</code>: Physics model defined by user.</li><li><code>prev</code>: Previous energy cell values.</li><li><code>mdtof</code>: Face mass flow.</li><li><code>rho</code>: Density ScalarField.</li><li><code>mueff</code>: Effective viscosity FaceScalarField.</li><li><code>time</code>: Simulation runtime.</li><li><code>config</code>: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L122-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.enthalpy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.enthalpy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.enthalpy_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the total enthalpy (ideal + residual) in J/mol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.entropy_calc-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.entropy_calc-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.entropy_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the total entropy (ideal + residual) in J/(mol*K).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.find_saturation_properties-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.find_saturation_properties-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.find_saturation_properties</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculates saturation properties (pressure, liquid density, vapor density) at a given temperature. Uses a secant solver to find the pressure where the liquid and vapor Gibbs free energies are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L352-L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.find_saturation_temperature-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.find_saturation_temperature-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.find_saturation_temperature</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Iteratively solves for the saturation temperature (in K) for a given pressure (Pa) using the ancillary equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.gibbs_free_energy-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.gibbs_free_energy-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.gibbs_free_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the Gibbs free energy in J/mol for a given state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.h0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.h0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.h0_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the ideal-gas enthalpy (h0) in J/mol at a given temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.htoT!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.htoT!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.htoT!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">htoT!(model::Physics{T1,F,SO,M,Tu,E,D,BI}, h::ScalarField, T::ScalarField
) where {T1,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function coverts sensible enthalpy ScalarField to temperature ScalarField.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>h</code>      – Sensible enthalpy ScalarField.</li><li><code>T</code>      – Temperature ScalarField.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L293-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{SensibleEnthalpy, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T1, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{SensibleEnthalpy, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T1, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(energy::SensibleEnthalpy, model::Physics{T1,F,SO,M,Tu,E,D,BI}, mdotf, rho, peqn, config
) where {T1,F,SO,M,Tu,E,D,BI})</code></pre><p>Initialisation of energy transport equations.</p><p><strong>Input</strong></p><ul><li><code>energy</code>: Energy model.</li><li><code>model</code>: Physics model defined by user.</li><li><code>mdtof</code>: Face mass flow.</li><li><code>rho</code>: Density ScalarField.</li><li><code>peqn</code>: Pressure equation.</li><li><code>config</code>: Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>SensibleEnthalpyModel</code>: Energy model struct containing energy equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L60-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KEquation, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KEquation, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(turbulence::KEquation, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,SO,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KEquationModel(       turbulence,        Δ,        magS,        ModelState((), false)   )</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_KEquation.jl#L51-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmega, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmega, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(turbulence::KOmega, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,SO,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KOmegaModel(       turbulence,       k_eqn,        ω_eqn,       state       )</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L61-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaLKE, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaLKE, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(turbulence::KOmegaLKE, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,SO,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KOmegaLKEModel(       turbulence,       k_eqn,       ω_eqn,       kl_eqn,       nueffkLS,       nueffkS,       nueffωS,       nuL,       nuts,       Ω,       γ,       fv,       normU,       Reυ,       ∇k,       ∇ω,        state   )</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L123-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaSST, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaSST, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(turbulence::KOmega, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,SO,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>KOmegaModel(k_eqn, ω_eqn)</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaSST.jl#L85-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Laminar, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Laminar, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function initialise(
    turbulence::Laminar, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
    ) where {T,F,SO,M,Tu,E,D,BI}
return LaminarModel(), config</code></pre><p>end</p><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code> – turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>mdtof</code>  – Face mass flow.</li><li><code>peqn</code>   – Pressure equation.</li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.</li></ul><p><strong>Output</strong></p><ul><li><code>LaminarModel()</code>  – Turbulence model structure.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_laminar.jl#L28-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Smagorinsky, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Smagorinsky, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.initialise</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialise(turbulence::Smagorinsky, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config
) where {T,F,SO,M,Tu,E,D,BI}</code></pre><p>Initialisation of turbulent transport equations.</p><p><strong>Input</strong></p><ul><li><code>turbulence</code>: turbulence model.</li><li><code>model</code>: Physics model defined by user.</li><li><code>mdtof</code>: Face mass flow.</li><li><code>peqn</code>: Pressure equation.</li><li><code>config</code>: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.</li></ul><p><strong>Output</strong></p><p>Returns a structure holding the fields and data needed for this model</p><pre><code class="nohighlight hljs">SmagorinskyModel(
    turbulence, 
    Δ, 
    ModelState((), false)
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L45-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.internal_energy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.internal_energy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.internal_energy_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the total internal energy (ideal + residual) in J/mol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.k_T-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.k_T-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.k_T</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the isothermal compressibility in 1/Pa (required for thermal conductivity computation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.params_computation-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.params_computation-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.params_computation</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes a set of key thermodynamic properties from molar density and temperature, and converts them from molar to mass-specific units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L429-L432">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, FaceScalarField, Any}} where {T, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, FaceScalarField, Any}} where {T, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.thermo_Psi!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">thermo_Psi!(model::Physics{T,F,SO,M,Tu,E,D,BI}, Psif::FaceScalarField) 
where {T,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Function updates the value of Psi.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>Psif</code>    – Compressibility factor FaceScalarField.</li></ul><p><strong>Algorithm</strong></p><p>Weakly compressible currently uses the ideal gas equation for establishing the compressibility factor where <span>$\rho = p * \Psi$</span>. <span>$\Psi$</span> is calculated from the sensible  enthalpy, reference temperature and fluid model specified <span>$C_p$</span> and <span>$R$</span> value where  <span>$R$</span> is calculated from <span>$C_p$</span> and <span>$\gamma$</span> specified in the fluid model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L246-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, ScalarField}} where {T, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, ScalarField}} where {T, F&lt;:AbstractCompressible, SO, M, Tu, E, D, BI}"><code>XCALibre.ModelPhysics.thermo_Psi!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">thermo_Psi!(model::Physics{T,F,SO,M,Tu,E,D,BI}, Psi::ScalarField) 
where {T,F&lt;:AbstractCompressible,M,Tu,E,D,BI}</code></pre><p>Model updates the value of Psi.</p><p><strong>Input</strong></p><ul><li><code>model</code>  – Physics model defined by user.</li><li><code>Psi</code>    – Compressibility factor ScalarField.</li></ul><p><strong>Algorithm</strong></p><p>Weakly compressible currently uses the ideal gas equation for establishing the compressibility factor where <span>$\rho = p * \Psi$</span>. <span>$\Psi$</span> is calculated from the sensible  enthalpy, reference temperature and fluid model specified <span>$C_p$</span> and <span>$R$</span> value where  <span>$R$</span> is calculated from <span>$C_p$</span> and <span>$\gamma$</span> specified in the fluid model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Energy/Sensible_Enthalpy.jl#L221-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Turb}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaLKEModel, Physics{T, F, SO, M, Turb, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Turb&lt;:AbstractTurbulenceModel, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Turb}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaLKEModel, Physics{T, F, SO, M, Turb, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Turb&lt;:AbstractTurbulenceModel, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>turbulence!(rans::KOmegaLKEModel, model::Physics{T,F,SO,M,Turb,E,D,BI}, S, prev, time, config     ) where {T,F,SO,M,Turb&lt;:AbstractTurbulenceModel,E,D,BI}</p><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::KOmegaLKEModel</code> – KOmega turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaLKE.jl#L276-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KEquationModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KEquationModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">turbulence!(les::KEquationModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, S2, prev, time, config
) where {T,F,SO,M,Tu&lt;:AbstractTurbulenceModel,E,D,BI}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>les::KEquationModel</code> – KEquation LES turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>S2</code>  – Square of the strain rate magnitude.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_KEquation.jl#L118-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">turbulence!(rans::KOmegaModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config
) where {T,F,SO,M,Tu&lt;:AbstractTurbulenceModel,E,D,BI}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::KOmegaModel</code> – KOmega turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmega.jl#L138-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.LaminarModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.LaminarModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">turbulence!(rans::LaminarModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config
) where {T,F,SO,M,Tu&lt;:Laminar,E,D,BI}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::LaminarModel</code> – Laminar turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_laminar.jl#L57-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.SmagorinskyModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.SmagorinskyModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">turbulence!(les::SmagorinskyModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, S2, prev, time, config
) where {T,F,SO,M,Tu&lt;:AbstractTurbulenceModel,E,D,BI}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>les::SmagorinskyModel</code>: <code>Smagorinsky</code> LES turbulence model.</li><li><code>model</code>: Physics model defined by user.</li><li><code>S</code>: Strain rate tensor.</li><li><code>S2</code>: Square of the strain rate magnitude.</li><li><code>prev</code>: Previous field.</li><li><code>time</code>: current simulation time </li><li><code>config</code>: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/LES_Smagorinsky.jl#L89-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.turbulence!-Union{Tuple{S1}, Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaSSTModel{E1, E2, S1}, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI, E1, E2, S1}"><a class="docstring-binding" href="#XCALibre.ModelPhysics.turbulence!-Union{Tuple{S1}, Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaSSTModel{E1, E2, S1}, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu&lt;:AbstractTurbulenceModel, E, D, BI, E1, E2, S1}"><code>XCALibre.ModelPhysics.turbulence!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">turbulence!(rans::KOmegaModel{E1,E2,S1}, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config
) where {T,F,SO,M,Tu&lt;:KOmega,E,D,BI,E1,E2,S1}</code></pre><p>Run turbulence model transport equations.</p><p><strong>Input</strong></p><ul><li><code>rans::KOmegaModel{E1,E2,S1}</code> – KOmega turbulence model.</li><li><code>model</code>  – Physics model defined by user.</li><li><code>S</code>   – Strain rate tensor.</li><li><code>prev</code>  – Previous field.</li><li><code>time</code>   – </li><li><code>config</code> – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/Turbulence/RANS_kOmegaSST.jl#L176-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.u0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.u0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.u0_calc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Computes the ideal-gas internal energy (u0) in J/mol at a given temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.ModelPhysics.vapour_pressure_ancillary-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><a class="docstring-binding" href="#XCALibre.ModelPhysics.vapour_pressure_ancillary-Union{Tuple{F}, Tuple{F, Any, Any}} where F&lt;:AbstractFloat"><code>XCALibre.ModelPhysics.vapour_pressure_ancillary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculates the saturation pressure (in Pa) for a given temperature using a simplified ancillary equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/ModelPhysics/FluidProperties/HelmholtzEnergy/HelmholtzFunctions.jl#L258">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Simulate.Configuration"><a class="docstring-binding" href="#XCALibre.Simulate.Configuration"><code>XCALibre.Simulate.Configuration</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@kwdef struct Configuration{SC,SL,RT,HW,PP}
    schemes::SC
    solvers::SL
    runtime::RT
    hardware::HW
    postprocess::PP = nothing
end</code></pre><p>The <code>Configuration</code> type is passed to all flow solvers and provides all the relevant information to run a simulation. </p><p><strong>Inputs</strong></p><ul><li><code>schemes::NamedTuple</code> this keyword argument is used to pass distretisation scheme information to flow solvers. See <a href="../user_guide/3_numerical_setup/#Numerical-setup">Numerical setup</a> for details.</li><li><code>solvers::NamedTuple</code> this keyword argument is used to pass the configurations for the linear solvers for each field information to flow solvers. See <a href="../user_guide/4_runtime_and_solvers/#Runtime-and-solvers">Runtime and solvers</a> for details.</li><li><code>runtime::NamedTuple</code> this keyword argument is used to pass runtime information to the flow solvers. See <a href="../user_guide/4_runtime_and_solvers/#Runtime-and-solvers">Runtime and solvers</a> for details.</li><li><code>hardware::NamedTuple</code> this keyword argument is used to pass the hardware configuration and backend settings to the flow solvers. See <a href="../user_guide/1_preprocessing/#Pre-processing">Pre-processing</a> for details.</li></ul><p><strong>Optional keywords</strong></p><ul><li><code>postprocess</code> this keyword argument is used to pass any fields that need to be post-processed. See <a href="../user_guide/5_postprocessing/#Post-processing">Post-processing</a> for details.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">config = Configuration(
    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Simulate/Simulate_0_types.jl#L4-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Simulate.Hardware"><a class="docstring-binding" href="#XCALibre.Simulate.Hardware"><code>XCALibre.Simulate.Hardware</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">hardware = Hardware(backend, workgroup)</code></pre><p>Struct used to configure the backend.</p><p><strong>Inputs</strong></p><ul><li><code>backend</code>: used to specify the backend e.g. <code>CPU()</code>, <code>CUDABackend()</code> or other backends supported by <code>KernelAbstraction.jl</code></li><li><code>workgroup::Int</code> this is an integer specifying the number of workers that cooperate in a parallel run. For GPUs this could be set to the size of the device&#39;s warp e.g. <code>workgroup = 32</code>. On CPUs, the default value in <code>KernelAbstractions.jl</code> is currently <code>workgroup = 1024</code>.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>Hardware</code> object with the fields <code>backend</code> and <code>workgroup</code> which are accessed by internally in <code>XCALibre.jl</code> to execute a given kernel in the target <code>backend</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Simulate/Simulate_0_types.jl#L43-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.cpiso!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Solvers.cpiso!-Tuple{Any, Any}"><code>XCALibre.Solvers.cpiso!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cpiso!(model, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Compressible and transient variant of the PISO algorithm with a sensible enthalpy transport equation for the energy. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_2_CPISO.jl#L3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.csimple!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Solvers.csimple!-Tuple{Any, Any}"><code>XCALibre.Solvers.csimple!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">csimple!(
    model_in, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
)</code></pre><p>Compressible variant of the SIMPLE algorithm with a sensible enthalpy transport equation for the energy. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li><li><code>e</code> Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_1_CSIMPLE.jl#L3-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.laplace!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Solvers.laplace!-Tuple{Any, Any}"><code>XCALibre.Solvers.laplace!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">laplace!(model_in, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Top-level entry point for solving the Laplace (heat conduction) equation on <code>model.domain</code>.   Optionally runs in steady or transient mode and can call Conduction energy model for high fidelity (k and cp are recomputed at each iteration).</p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>T</code> Vector of T residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_1_LAPLACE.jl#L6-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.piso!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Solvers.piso!-Tuple{Any, Any}"><code>XCALibre.Solvers.piso!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cpiso!(model, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Incompressible and transient variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations. </p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_2_PISO.jl#L3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Tuple{}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Tuple{}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function run!(
    model::Physics, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    )

    # here an internal function is used for solver dispatch
    return residuals
end</code></pre><p>This is the top level API function to initiate a simulation. It uses the user-provided <code>model</code> defined as a <code>Physics</code> object to dispatch to the appropriate solver.</p><p><strong>Dispatched flow solvers</strong></p><ul><li>Steady incompressible (SIMPLE algorithm for coupling)</li><li>Transient incompressible (PISO algorithm for coupling)</li><li>Steady weakly compressible (SIMPLE algorithm for coupling)</li><li>Transient weakly compressible (PISO algorithm for coupling)</li></ul><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>). The fields available within the returned <code>residuals</code> tuple depend on the solver used. For example, for an incompressible solver, a x-momentum equation residual can be retrieved accessing the <code>Ux</code> field i.e. <code>residuals.Ux</code>. Look at reference guide for each dispatch method to find out which fields are available.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">residuals = run!(model, config) 

# to access the pressure residual

residuals.p </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L3-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:Incompressible, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:Incompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config;
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Steady,F&lt;:Incompressible,M,Tu,E,D,BI} = 
begin
    residuals = simple!(model, config, pref=pref)
    return residuals
end</code></pre><p>Calls the incompressible steady solver using the SIMPLE algorithm.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L95-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Steady, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Steady,F&lt;:WeaklyCompressible,M,Tu,E,D,BI} = 
begin
    residuals = csimple!(model, config, pref=pref); #, pref=0.0)
    return residuals
end</code></pre><p>Calls the compressible steady solver using the SIMPLE algorithm for weakly compressible fluids.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li><li><code>e</code>   - Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L183-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:Incompressible, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:Incompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Transient,F&lt;:Incompressible,M,Tu,E,D,BI} = 
begin
    residuals = piso!(model, config, pref=pref); #, pref=0.0)
    return residuals
end</code></pre><p>Calls the incompressible transient solver using the PISO algorithm.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L138-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T&lt;:Transient, F&lt;:WeaklyCompressible, M, Tu, E, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,M,Tu,E,D,BI}; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T&lt;:Transient,F&lt;:WeaklyCompressible,M,Tu,E,D,BI} = 
begin
    residuals = cpiso!(model, config)
    return residuals
end</code></pre><p>Calls the compressible transient solver using the PISO algorithm for weakly compressible fluids.</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code>  - Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code>  - Vector of y-velocity residuals for each iteration.</li><li><code>p</code>   - Vector of pressure residuals for each iteration.</li><li><code>e</code>   - Vector of energy residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L245-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, Any}} where {T, F, SO, M, Tu, E&lt;:Conduction, D, BI}"><a class="docstring-binding" href="#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, Any}} where {T, F, SO, M, Tu, E&lt;:Conduction, D, BI}"><code>XCALibre.Solvers.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(
    model::Physics{T,F,SO,M,Tu,E,D,BI}, config;
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0
    ) where{T,F,SO&lt;:Uniform,M,Tu,E,D,BI} = 
begin
    residuals = laplace!(model, config, pref=pref)
    return residuals
end</code></pre><p>Top-level entry point for solving the Laplace (heat conduction) equation on <code>model.domain</code>.   Optionally runs in steady or transient mode and can call CryogenicConduction energy model for high fidelity (k and cp are recomputed at each iteration).</p><p><strong>Input</strong></p><ul><li><code>model</code> represents the <code>Physics</code> model defined by user.</li><li><code>config</code> Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM()</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>T</code>   - (Vector?) of temperature residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_3_solver_dispatch.jl#L50-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Solvers.simple!-Tuple{Any, Any}"><a class="docstring-binding" href="#XCALibre.Solvers.simple!-Tuple{Any, Any}"><code>XCALibre.Solvers.simple!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simple!(model_in, config; 
    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)</code></pre><p>Incompressible variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations.</p><p><strong>Input arguments</strong></p><ul><li><code>model</code> reference to a <code>Physics</code> model defined by the user.</li><li><code>config</code> Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.</li><li><code>output</code> select the format used for simulation results from <code>VTK()</code> or <code>OpenFOAM</code> (default = <code>VTK()</code>)</li><li><code>pref</code> Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = <code>nothing</code>)</li><li><code>ncorrectors</code> number of non-orthogonality correction loops (default = <code>0</code>)</li><li><code>inner_loops</code> number to inner loops used in transient solver based on PISO algorithm (default = <code>0</code>)</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> for accessing the residuals (e.g. <code>residuals.Ux</code>) with the following entries:</p><ul><li><code>Ux</code> Vector of x-velocity residuals for each iteration.</li><li><code>Uy</code> Vector of y-velocity residuals for each iteration.</li><li><code>Uz</code> Vector of y-velocity residuals for each iteration.</li><li><code>p</code> Vector of pressure residuals for each iteration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Solvers/Solvers_1_SIMPLE.jl#L3-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.FieldAverage-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.FieldAverage-Tuple{Any}"><code>XCALibre.Postprocess.FieldAverage</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldAverage(
#required arguments
field;
name::String,

#optional keyword arguments
start::Union{Real,Nothing},
stop::Union{Real,Nothing},
update_interval::Union{Real,Nothing})</code></pre><p>Constructor to allocate memory to store the time averaged field. Once created, should be passed to the <code>Configuration</code> object as an argument with keyword <code>postprocess</code></p><p><strong>Input arguments</strong></p><ul><li><code>field</code> the <code>VectorField</code> or <code>ScalarField</code> to be averaged, e.g , <code>model.momentum.U</code>.</li><li><code>name::String</code> the name of the field to be averaged, e.g &quot;U_mean&quot;, this is used only when exporting to .vtk format</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>start::Union{Real,Nothing}</code> optional keyword which specifies the start time/iteration of the averaging window, for <strong>steady</strong> simulations, this is in <strong>iterations</strong>, for <strong>transient</strong> simulations it is in <strong>flow time</strong>.   </li><li><code>stop::Union{Real,Nothing}</code> optional keyword which specifies the end iteration/time of the averaging window. Default value is the last iteration/timestep. </li><li><code>update_interval::Union{Real,Nothing}</code> optional keyword which specifies how often the time average of the field is updated and stored (default value is 1 i.e average updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the <code>write_interval</code> in <code>Configuration</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_0_field_average.jl#L13-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.FieldRMS-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.FieldRMS-Tuple{Any}"><code>XCALibre.Postprocess.FieldRMS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FieldRMS(
#required arguments
field;
name::String,

#optional keyword arguments
start::Union{Real,Nothing},
stop::Union{Real,Nothing},
update_interval::Union{Real,Nothing})</code></pre><p>Constructor to allocate memory to store the root mean square of the fluctuations of a field over the averaging window. Once created, should be passed to the <code>Configuration</code> object as an argument with keyword <code>postprocess</code></p><p><strong>Input arguments</strong></p><ul><li><code>field</code> the <code>VectorField</code> or <code>ScalarField</code>, e.g , <code>model.momentum.U</code>.</li><li><code>name::String</code> the name/label of the field, e.g &quot;U_rms&quot;, this is used only when exporting to .vtk format</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>start::Union{Real,Nothing}</code> optional keyword which specifies the start of the RMS calculation window, for <strong>steady</strong> simulations, this is in <strong>iterations</strong>, for <strong>transient</strong> simulations it is in <strong>flow time</strong>.   </li><li><code>stop::Union{Real,Nothing}</code> optional keyword which specifies the end iteration/time of the RMS calculation window. Default value is the last iteration/timestep. </li><li><code>update_interval::Union{Real,Nothing}</code> optional keyword which specifies how often the RMS of the field is updated and stored (default value is 1 i.e RMS updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the <code>write_interval</code> in <code>Configuration</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_1_field_rms.jl#L12-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.ReynoldsStress-Tuple{Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.ReynoldsStress-Tuple{Any}"><code>XCALibre.Postprocess.ReynoldsStress</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ReynoldsStress(
#required arguments
model.momentum.U; 

#optional keyword arguments
start::Union{Real,Nothing},
stop::Union{Real,Nothing},
update_interval::Union{Real,Nothing})</code></pre><p>Constructor to allocate memory to store the Reynolds Stress Tensor over the calculation window. Once created, should be passed to the <code>Configuration</code> object as an argument with keyword <code>postprocess</code></p><p><strong>Input arguments</strong></p><ul><li><code>field</code>, must be <code>model.momentum.U</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>start::Union{Real,Nothing}</code> optional keyword which specifies the start of the Reynolds Stress Tensor calculation window, for <strong>steady</strong> simulations, this is in <strong>iterations</strong>, for <strong>transient</strong> simulations it is in <strong>flow time</strong>.   </li><li><code>stop::Union{Real,Nothing}</code> optional keyword which specifies the end iteration/time of the Reynolds Stress Tensor calculation window. Default value is the last iteration/timestep. </li><li><code>update_interval::Union{Real,Nothing}</code> optional keyword which specifies how often the Reynolds Stress Tensor is updated and stored (default value is 1 i.e Reynolds Stress Tensor updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the <code>write_interval</code> in <code>Configuration</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_2_reynolds_stress_tensor.jl#L12-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.boundary_average-Tuple{Symbol, Any, Any, Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.boundary_average-Tuple{Symbol, Any, Any, Any}"><code>XCALibre.Postprocess.boundary_average</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function boundary_average(patch::Symbol, field, config; time=0)
    # Extract mesh object
    mesh = field.mesh

    # Determine ID (index) of the boundary patch 
    ID = boundary_index(mesh.boundaries, patch)
    @info &quot;calculating average on patch: $patch at index $ID&quot;
    boundary = mesh.boundaries[ID]
    (; IDs_range) = boundary

    # Create face field of same type provided by user (scalar or vector)
    sum = nothing
    if typeof(field) &lt;: VectorField 
        faceField = FaceVectorField(mesh)
        sum = zeros(_get_float(mesh), 3) # create zero vector
    else
        faceField = FaceScalarField(mesh)
        sum = zero(_get_float(mesh)) # create zero
    end

    # Interpolate CFD results to boundary
    interpolate!(faceField, field, config)
    correct_boundaries!(faceField, field, field.BCs, time, config)

    # Calculate the average
    for fID ∈ IDs_range
        sum += faceField[fID]
    end
    ave = sum/length(IDs_range)

    # return average
    return ave
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_functions.jl#L87-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.pressure_force-Tuple{Symbol, ScalarField, Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.pressure_force-Tuple{Symbol, ScalarField, Any}"><code>XCALibre.Postprocess.pressure_force</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pressure_force(patch::Symbol, p::ScalarField, rho)</code></pre><p>Function to calculate the pressure force acting on a given patch/boundary.</p><p><strong>Input arguments</strong></p><ul><li><code>patch::Symbol</code> name of the boundary of interest (as a <code>Symbol</code>)</li><li><code>p::ScalarField</code> pressure field</li><li><code>rho</code> density. Set to 1 for incompressible solvers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_functions.jl#L5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.stress_tensor-NTuple{4, Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.stress_tensor-NTuple{4, Any}"><code>XCALibre.Postprocess.stress_tensor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stress_tensor(U::VectorField, ν, νt, config)</code></pre><p>Function to calculate the stress tensor.</p><p><strong>Input arguments</strong></p><ul><li><code>U::VectorField</code> velocity field</li><li><code>ν</code> laminar viscosity of the fluid</li><li><code>νt</code> eddy viscosity from turbulence models. Pass ConstantScalar(0) for laminar flows</li><li><code>config</code> need to pass <code>Configuration</code> object as this contains the boundary conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_functions.jl#L201-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.viscous_force-Tuple{Symbol, VectorField, Vararg{Any, 4}}"><a class="docstring-binding" href="#XCALibre.Postprocess.viscous_force-Tuple{Symbol, VectorField, Vararg{Any, 4}}"><code>XCALibre.Postprocess.viscous_force</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">viscous_force(patch::Symbol, U::VectorField, rho, ν, νt, config)</code></pre><p>Function to calculate the pressure force acting on a given patch/boundary.</p><p><strong>Input arguments</strong></p><ul><li><code>patch::Symbol</code> name of the boundary of interest (as a <code>Symbol</code>)</li><li><code>U::VectorField</code> velocity field</li><li><code>rho</code> density. Set to 1 for incompressible solvers</li><li><code>ν</code> laminar viscosity of the fluid</li><li><code>νt</code> eddy viscosity from turbulence models. Pass ConstantScalar(0) for laminar flows</li><li><code>config</code> need to pass <code>Configuration</code> object as this contains the boundary conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_functions.jl#L38-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Postprocess.wall_shear_stress-Tuple{Symbol, Any, Any}"><a class="docstring-binding" href="#XCALibre.Postprocess.wall_shear_stress-Tuple{Symbol, Any, Any}"><code>XCALibre.Postprocess.wall_shear_stress</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">wall_shear_stress(patch::Symbol, model,config)</code></pre><p>Function to calculate the wall shear stress acting on a given patch/boundary.</p><p><strong>Input arguments</strong></p><ul><li><code>patch::Symbol</code> name of the boundary of interest (as a <code>Symbol</code>)</li><li><code>model</code> instance of <code>Physics</code> object needs to be passed </li><li><code>config</code> need to pass <code>Configuration</code> object as this contains the boundary conditions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Postprocess/Postprocess_functions.jl#L149-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Preprocess.setField_Box!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><a class="docstring-binding" href="#XCALibre.Preprocess.setField_Box!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>XCALibre.Preprocess.setField_Box!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setField_Box!(; mesh, field, value::F, min_corner::V, max_corner::V) where {F &lt;: AbstractFloat, V &lt;: AbstractVector}</code></pre><p>Sets field values equal to <code>value</code> argument only for cells located within a box defined by min and max corners</p><p><strong>Input arguments</strong></p><ul><li><code>mesh</code> reference to <code>domain</code> inside a <code>Physics</code> model defined by the user.</li><li><code>field</code> field to be modified.</li><li><code>value</code> new values for the chosen field.</li><li><code>min_corner</code> minimum coordinate values of the box in the format of [x, y, z].</li><li><code>max_corner</code> maximum coordinate values of the box in the format of [x, y, z].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Preprocess/setFields.jl#L3-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Preprocess.setField_Circle2D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><a class="docstring-binding" href="#XCALibre.Preprocess.setField_Circle2D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>XCALibre.Preprocess.setField_Circle2D!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setField_Circle2D!(mesh, field, value::F, centre::V, radius::F) where {F &lt;: AbstractFloat, V &lt;: AbstractVector}</code></pre><p>Sets field values equal to <code>value</code> argument only for cells located within a 2D circle defined by its centre and radius</p><p><strong>Input arguments</strong></p><ul><li><code>mesh</code> reference to <code>domain</code> inside a <code>Physics</code> model defined by the user.</li><li><code>field</code> field to be modified.</li><li><code>value</code> new values for the chosen field.</li><li><code>centre</code> coordinate of centre of the circle in the format of [x, y].</li><li><code>radius</code> length of the radius of the circle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Preprocess/setFields.jl#L44-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="XCALibre.Preprocess.setField_Sphere3D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><a class="docstring-binding" href="#XCALibre.Preprocess.setField_Sphere3D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F&lt;:AbstractFloat, V&lt;:(AbstractVector)}"><code>XCALibre.Preprocess.setField_Sphere3D!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setField_Sphere3D!(mesh, field, value::F, centre::V, radius::F) where {F &lt;: AbstractFloat, V &lt;: AbstractVector}</code></pre><p>Sets field values equal to <code>value</code> argument only for cells located within a 3D sphere defined by its centre and radius</p><p><strong>Input arguments</strong></p><ul><li><code>mesh</code> reference to <code>domain</code> inside a <code>Physics</code> model defined by the user.</li><li><code>field</code> field to be modified.</li><li><code>value</code> new values for the chosen field.</li><li><code>centre</code> coordinate of centre of the sphere in the format of [x, y, z].</li><li><code>radius</code> length of the radius of the sphere.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/072703f9f49cd29bca414ae42a3db815db3ccd28/src/Preprocess/setFields.jl#L82-L94">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributor_guide/">« Contributor Guide</a><a class="docs-footer-nextpage" href="../release_notes/">Release notes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 27 January 2026 18:54">Tuesday 27 January 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
