var documenterSearchIndex = {"docs":
[{"location":"user_guide/4_runtime_and_solvers/#Runtime-and-solvers","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"Final steps before launching a simulation","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#Runtime-setup","page":"Runtime and solvers","title":"Runtime setup","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"At this stage in the setup workflow, the user defines the runtime information to configure the runtime behaviour of the  flow solver, including the time step to use (only meaningful for transient solutions), as well as information about how often to write results to disk. XCALibre.jl provides a the Runtime to perform this operation. ","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#XCALibre.Solve.Runtime-user_guide-4_runtime_and_solvers","page":"Runtime and solvers","title":"XCALibre.Solve.Runtime","text":"Runtime(; \n        # keyword arguments\n\n        iterations::I, \n        write_interval::I, \n        time_step::N\n    ) where {I<:Integer,N<:Number} = begin\n    \n    # returned Runtime struct\n    Runtime{I<:Integer,F<:AbstractFloat}\n        (\n            iterations=iterations, \n            dt=time_step, \n            write_interval=write_interval\n        )\nend\n\nThis is a convenience function to set the top-level runtime information. The inputs are all keyword arguments and provide basic information to flow solvers just before running a simulation.\n\nInput arguments\n\niterations::Integer: specifies the number of iterations in a simulation run.\nwrite_interval::Integer: defines how often simulation results are written to file (on the current working directory). The interval is currently based on number of iterations. Set to -1 to run without writing results to file.\ntime_step::AbstractFloat: the time step to use in the simulation. Notice that for steady solvers this is simply a counter and it is recommended to simply use 1.\n\nExample\n\nruntime = Runtime(iterations=2000, time_step=1, write_interval=2000)\n\n\n\n\n\n","category":"type"},{"location":"user_guide/4_runtime_and_solvers/#Configuration-object","page":"Runtime and solvers","title":"Configuration object","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"Once all the simulation configuration information has been defined, from discretisation scheme to runtime information, all settings must be wrapped in a Configuration object. The definition, including expected input arguments, for the Configuration object are detailed below.","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#XCALibre.Simulate.Configuration-user_guide-4_runtime_and_solvers","page":"Runtime and solvers","title":"XCALibre.Simulate.Configuration","text":"@kwdef struct Configuration{SC,SL,RT,HW,PP}\n    schemes::SC\n    solvers::SL\n    runtime::RT\n    hardware::HW\n    postprocess::PP = nothing\nend\n\nThe Configuration type is passed to all flow solvers and provides all the relevant information to run a simulation. \n\nInputs\n\nschemes::NamedTuple this keyword argument is used to pass distretisation scheme information to flow solvers. See Numerical setup for details.\nsolvers::NamedTuple this keyword argument is used to pass the configurations for the linear solvers for each field information to flow solvers. See Runtime and solvers for details.\nruntime::NamedTuple this keyword argument is used to pass runtime information to the flow solvers. See Runtime and solvers for details.\nhardware::NamedTuple this keyword argument is used to pass the hardware configuration and backend settings to the flow solvers. See Pre-processing for details.\n\nOptional keywords\n\npostprocess this keyword argument is used to pass any fields that need to be post-processed. See Post-processing for details.\n\nExample\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\n\n\n\n\n","category":"type"},{"location":"user_guide/4_runtime_and_solvers/#Initialising-fields","page":"Runtime and solvers","title":"Initialising fields","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"The last (optional) step before running the simulation is to provide an initial guess for all the fields being solved. Although this step is optional, in most cases the flow solvers will perform better when initialised. To set an initial value for a field, the initialise! function is provided, which assigns a starting value to a given field.","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#XCALibre.Fields.initialise!-user_guide-4_runtime_and_solvers","page":"Runtime and solvers","title":"XCALibre.Fields.initialise!","text":"function initialise!(field, value) # dummy function for documentation\n    # Assign `value` to field in-place\n    nothing\nend\n\nThis function will set the given field to the value provided in-place. Useful for initialising fields prior to running a simulation.\n\nInput arguments\n\nfield specifies the field to be initialised. The field must be either a AbractScalarField or AbstractVectorField\nvalue defines the value to be set. This should be a scalar or vector (3 components) depending on the field to be modified e.g. for an AbstractVectorField we can specify as value=[10,0,0]\n\nNote: in most cases the fields to be modified are stored within a physics model i.e. a Physics object. Thus, the argument value must fully qualify the model. For example, if we have created a Physics model named mymodel to set the velocity field, U, we would set the argument field to mymodel.momentum.U. See the example below.\n\nExample\n\ninitialise!(mymodel.momentum.U, [2.5, 0, 0])\ninitialise!(mymodel.momentum.p, 1.25)\n\n\n\n\n\n","category":"function"},{"location":"user_guide/4_runtime_and_solvers/#Launching-flow-solvers","page":"Runtime and solvers","title":"Launching flow solvers","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"In XCALibre.jl the run! function is used to start a simulation, which will dispatch to the appropriate flow solver for execution. Once the simulation is complete a NamedTuple containing residual information is returned for users to explore the convergence history of the simulation. ","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#XCALibre.Solvers.run!-Tuple{}-user_guide-4_runtime_and_solvers","page":"Runtime and solvers","title":"XCALibre.Solvers.run!","text":"function run!(\n    model::Physics, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    )\n\n    # here an internal function is used for solver dispatch\n    return residuals\nend\n\nThis is the top level API function to initiate a simulation. It uses the user-provided model defined as a Physics object to dispatch to the appropriate solver.\n\nDispatched flow solvers\n\nSteady incompressible (SIMPLE algorithm for coupling)\nTransient incompressible (PISO algorithm for coupling)\nSteady weakly compressible (SIMPLE algorithm for coupling)\nTransient weakly compressible (PISO algorithm for coupling)\n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux). The fields available within the returned residuals tuple depend on the solver used. For example, for an incompressible solver, a x-momentum equation residual can be retrieved accessing the Ux field i.e. residuals.Ux. Look at reference guide for each dispatch method to find out which fields are available.\n\nExample\n\nresiduals = run!(model, config) \n\n# to access the pressure residual\n\nresiduals.p \n\n\n\n\n\n","category":"method"},{"location":"user_guide/4_runtime_and_solvers/#Restarting-simulations","page":"Runtime and solvers","title":"Restarting simulations","text":"","category":"section"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"It should be noted that when running a simulation with run!, the solution fields in the Physics model are mutated. Thus, running the simulation from the previous solution is simply a matter of reissuing the run! function. At present, this has the side effect of overwriting any existing solution files (.vtk or .vtu). Users must be aware of this behaviour.","category":"page"},{"location":"user_guide/4_runtime_and_solvers/","page":"Runtime and solvers","title":"Runtime and solvers","text":"In some cases, it may be desirable to solve a problem with a steady solver and use the solution to run transient simulations. This is possible using the change function.","category":"page"},{"location":"user_guide/4_runtime_and_solvers/#XCALibre.ModelPhysics.change-user_guide-4_runtime_and_solvers","page":"Runtime and solvers","title":"XCALibre.ModelPhysics.change","text":"change(model::Physics, property, value) => updatedModel::Physics\n\nA convenience function to change properties of an exisitng Physics model.\n\nInput arguments\n\nmodel::Physics a Physics model to modify\nproperty is a symbol specifying the property to change \nvalue is the new setting for the specified property\n\nOutput\n\nThis function return a new Physics object\n\nExample\n\nTo change a model to run a transient simulation e.g. after converging in steady state\n\nmodelTransient = change(model, :time, Transient())\n\n\n\n\n\n","category":"function"},{"location":"examples/04_2d-inflow-using-Flux/#Advanced:-Inflow-condition-using-Machine-Learning-(Flux.jl)","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/#Introduction","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Introduction","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"In this example a simple neural network is constructed and used to define an inlet boundary condition for the x-component of the velocity vector. This example serves to illustrate how other packages from the Julia ecosystem can be integrated into XCALibre.jl to extend its functionality. In particular, this example will show how to build a basic neural network using Flux.jl to represent a parabolic velocity profile and how this neural network can be used to define an inlet condition in XCALibre.jl. ","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The boundary condition is injected into the solution using the builtin DirichletFunction boundary condition, which is designed to pass arbitrary Julia functions to a given boundary.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#XCALibre.Discretise.DirichletFunction-examples-04_2d-inflow-using-Flux","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"XCALibre.Discretise.DirichletFunction","text":"DirichletFunction(ID, value) <: AbstractDirichlet\n\nDirichlet boundary condition defined with user-provided function.\n\nInput\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue Custom function or struct (<:XCALibreUserFunctor) for Dirichlet boundary condition\nIDs_range Range of indices to access boundary patch faces\n\nFunction requirements\n\nThe function passed to this boundary condition must have the following signature:\n\nf(coords, time, index) = SVector{3}(ux, uy, uz)\n\nWhere, coords is a vector containing the coordinates of a face, time is the current time in transient simulations (and the iteration number in steady simulations), and index is the local face index (from 1 to N, where N is the number of faces in a given boundary). The function must return an SVector (from StaticArrays.jl) representing the velocity vector. \n\n\n\n\n\n","category":"type"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"In this example, instead of passing a Julia function, the boundary velocity profile will be given via a simple neural network. ","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"note: Note\nThis interface is experimental and subject to change. Currently it can only be used for vectors.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Set-up-steps","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Set up steps","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Install-and-load-modules","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Install and load modules","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"To be able to run this example the following modules need to be installed. This can be done by entering into package mode (using \"]\" in the REPL) and typing the following:","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"add Plots, XCALibre, Flux, StaticArrays, LinearAlgebra, KernelAbstractions, Adapt","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"This will download and install the required packages. Once installed, the packages can be loaded as follows:","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"using Plots\nusing XCALibre\nusing Flux\nusing StaticArrays\nusing Statistics\nusing LinearAlgebra\nusing KernelAbstractions\nnothing # hide","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Build-a-neural-network-model","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Build a neural network model","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"Next, a neural network will be created to return a parabolic velocity profile. In this case, the training data will be generated using an analytical expression. ","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\nactual(y) = begin\n    H = 1.0 # channel height\n    H2 = H/2.0\n    h = y - H2\n    vx = (1.0 - (h/H2)^2.0)\n    return vx\nend\n","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"And define a simple 2-layer neural network to model the inlet function:","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"inflowNetwork = Chain(\n    Dense(1 => 6, sigmoid),\n    Dense(6 => 1)) |> f64","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"Now, we generate the training and testing datasets using the analytical function. The neural network is not yet trained but it can already be used (of course, the prediction is not yet very useful). The various datasets, and initial model predictions are shown in the figure below.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\ny_actual = [0:0.01:1;] # array of y-values for plotting\nvx_actual = actual.(y_actual)\n\n# Generate training dataset\ny_train = hcat(rand(0:(0.1/100):0.1, 100)...)./0.1\nvx_train = actual.(y_train)\n\n# Test locations selected randomly\ny_test = hcat(rand(0:(0.1/100):0.1, 100)...)./0.1\nvx_untrained = inflowNetwork(y_test)\n\nplot(\n    y_actual, vx_actual, label=\"Actual\", \n    frame_style=:box, foreground_color_legend = nothing,\n    xlabel=\"Dimensionless distance\", ylabel=\"Normalised velocity\")\nscatter!(y_train', vx_train', label=\"Training data\")\nscatter!(y_test', vx_untrained', label=\"Untrained output\")\nsavefig(\"flux_comparison_untrained.svg\"); nothing # hide","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"(Image: )","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The next step is to train the model as shown below. Finally, to make sure that the model has trained correctly, it is tested with at randomly generated points and the output compared with the analytical function as shown in the figure below.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\nloss(inflowNetwork, y, vx) = mean(abs2.(inflowNetwork(y) .- vx))\n\nopt =  Flux.setup(Adam(), inflowNetwork)\ndata = [(y_train, vx_train)]\nfor epoch in 1:20000\n    Flux.train!(loss, inflowNetwork, data, opt)\nend\nloss(inflowNetwork, data[1]...,)\n\nvx_trained = inflowNetwork(y_test)\n\n\nplot(\n    y_actual, vx_actual, label=\"Actual\", \n    frame_style=:box, foreground_color_legend = nothing,\n    xlabel=\"Dimensionless distance\", ylabel=\"Normalised velocity\")\nscatter!(y_test', vx_trained', label=\"Trained output\")\nsavefig(\"flux_comparison.svg\"); nothing # hide","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"(Image: )","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Define-inlet-condition-and-interface","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Define inlet condition and interface","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The next step is to define some interfaces to allow passing the model as if it was a simple Julia function. This requires only 3 key ingredients. First, a struct is defined that will contain any user data needed as well as the model itself. In this case, the following structure has been used (but users are completely free to define their own structures).  The only requirements are that the structure should be a subtype of XCALibreUserFunctor and it must contain the steady property.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"struct Inflow{F,I,O,N,V,T} <: XCALibreUserFunctor\n    U::F        # maximum velocity\n    H::F        # inlet height\n    input::I    # vector to hold input coordinates\n    output::O   # vector to hold model inferred values\n    network::N  # model itself\n    xdir::V     # struct used to define x-direction unit vector\n    steady::T   # required field! (Bool)\nend","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"Second, the struct above is used as a functor, defined following the requirements set by the DirichletFunction boundary condition. Essentially, this allows for external data to be stored in the Inflow object, which is then made \"callable\" to behave as a simple Julia function that returns the velocity vector at a given coordinate (vec) and time (t).","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"(bc::Inflow)(vec, t, i) = begin\n    velocity = @view bc.output[:,i]\n    return @inbounds SVector{3}(velocity[1], velocity[2], velocity[3])\nend","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The third step is to define a new method for the update_user_boundary! function from the Discretise module. This function offers a mechanism to update the internals of the previously defined structure by calling the user-provided neural network model. In this particular example, this is not required since the boundary values are not changing in time (it would have been sufficient to do a single inference round and to simply store the values inside the Inflow struct). However, this function is implemented here to illustrate the interface, and provide an example of a user-defined kernel. Notice that, in this particular example, the only purpose of this function is to scale the velocity field inferred by the neural network (since it was defined with values between 0 and 1).","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\nXCALibre.Discretise.update_user_boundary!(\n    BC::DirichletFunction{I,V,R}, faces, cells, facesID_range, time, config\n    ) where {I,V<:Inflow,R} = begin\n    \n    (; hardware) = config\n    (; backend, workgroup) = hardware\n\n    kernel_range = length(facesID_range)\n    kernel! = _update_user_boundary!(backend, workgroup, kernel_range)\n    kernel!(BC, faces, cells, facesID_range, time, ndrange=kernel_range)\n    KernelAbstractions.synchronize(backend)\n\n    (; output, input, U, network, xdir) = BC.value\n    output .= U.*network(input).*xdir # convert to vector\nend\n\n@kernel function _update_user_boundary!(BC, faces, cells, facesID_range, time)\n    i = @index(Global)\n    startID = facesID_range[1]\n    fID = i + startID - 1\n    coords = faces[fID].centre\n    BC.value.input[i] = coords[2]/BC.value.H # scale coordinates\nend\n","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Create-an-instance-of-Inflow","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Create an instance of  Inflow","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"An instance of the Inflow object is now created. Notice that the input and output fields contain vectors to hold the boundary face information, thus, they must be of the same size as the number of boundary faces. The mesh is, therefore, loaded first.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"backwardFacingStep_5mm.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\nnfaces = mesh.boundaries[1].IDs_range |> length","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The Inflow functor is now constructed.","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\nU = 0.5 # maximum velocity\nH = 0.1 # inlet height\ninput = zeros(1,nfaces)\ninput .= (H/2)/H\noutput = U.*inflowNetwork(input).*[1 0 0]'\n@view output[:,2]\n\ninlet_profile= Inflow(\n    0.5,\n    0.1,\n    input,\n    output,\n    inflowNetwork,\n    [1,0,0],\n    true\n)\n","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Run-simulation","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Run simulation","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"The final step is simply to set up and run a simulation in XCALibre.jl. Notice that this does not require any special considerations, only to remember to use the DirichletFunction boundary condition when setting the inlet velocity. The inlet_profile functor object is then passed to the boundary. ","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"\nvelocity = [0.5, 0.0, 0.0]\nnu = 1e-3\nRe = velocity[1]*0.1/nu\n\nmodel = Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh\n    )\n\nBCs = assign(\n    region=mesh,\n    (\n        U = [\n            DirichletFunction(:inlet, inlet_profile), # Pass functor\n            Extrapolated(:outlet),\n            Wall(:wall, [0.0, 0.0, 0.0]),\n            Wall(:top, [0.0, 0.0, 0.0])\n        ],\n        p = [\n            Extrapolated(:inlet),\n            Dirichlet(:outlet, 0.0),\n            Wall(:wall),\n            Wall(:top)\n        ]\n    )\n)\n\nschemes = (\n    U = Schemes(divergence = Linear),\n    p = Schemes()\n)\n\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(),\n        convergence = 1e-8,\n        relax       = 0.7,\n        rtol = 1e-4\n    ),\n    p = SolverSetup(\n        solver      = Cg(),\n        preconditioner = Jacobi(),\n        convergence = 1e-8,\n        relax       = 0.3,\n        rtol = 1e-4\n    )\n)\n\nruntime = Runtime(iterations=500, time_step=1, write_interval=500)\nruntime = Runtime(iterations=1, time_step=1, write_interval=-1) # hide\n\nhardware = Hardware(backend=CPU(), workgroup=1024)\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\nGC.gc()\n\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 0.0)\n\nresiduals = run!(model, config)\n\nnothing # hide","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/#Simulation-result","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Simulation result","text":"","category":"section"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"","category":"page"},{"location":"examples/04_2d-inflow-using-Flux/","page":"Advanced: Inflow condition using Machine Learning (Flux.jl)","title":"Advanced: Inflow condition using Machine Learning (Flux.jl)","text":"(Image: Comparison with OpenFOAM)","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Verification:-2D-bump-k-\\omega-SST","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/#Introduction","page":"Verification: 2D bump k-omega SST","title":"Introduction","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"","category":"page"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"The correct implementation of the k-omega SST solver in XCALibre.jl has been verified by quantitatively comparing results with those obtained with OpenFOAM. The simulation set up and mesh file used to run the simulation with XCALibre.jl are available in this repository.","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Simulation-setup","page":"Verification: 2D bump k-omega SST","title":"Simulation setup","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"","category":"page"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"\nusing XCALibre\n# using CUDA # Uncomment to run on NVIDIA GPUs\n# using AMDGPU # Uncomment to run on AMD GPUs\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"OF_bump2d/polyMesh\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = FOAM3D_mesh(mesh_file, scale=1, integer_type=Int64, float_type=Float64)\n\n# Select backend and setup hardware\nbackend = CPU(); workgroup = 1024; activate_multithread(backend)\n# backend = CUDABackend() # ru non NVIDIA GPUs\n# backend = ROCBackend() # run on AMD GPUs\nhardware = Hardware(backend=backend, workgroup=workgroup)\n\nmesh_dev = adapt(CPU(), mesh)\n\nu_mag = 69.44\nvelocity = [u_mag, 0.0, 0.0]\nnu = 1.388E-5\nk_inlet = 0.723\nω_inlet = 8675\n\nmodel = Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{KOmegaSST}(walls=(:bump,)),\n    # turbulence = RANS{KOmega}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh_dev\n    )\n\npatch_group = [:top, :symUp, :symDown]\n\n# set up as walls\ngroup_bcs_U = Wall.(patch_group, Ref([0,0,0]))\ngroup_bcs_p = Wall.(patch_group)\ngroup_bcs_k = Dirichlet.(patch_group, Ref(0.0))\ngroup_bcs_omega = OmegaWallFunction.(patch_group)\ngroup_bcs_nut = Dirichlet.(patch_group, Ref(0.0))\n\n# set up as symmetric\ngroup_bcs_U = Symmetry.(patch_group)\ngroup_bcs_p = group_bcs_U\ngroup_bcs_k = group_bcs_U\ngroup_bcs_omega = group_bcs_U\ngroup_bcs_nut = group_bcs_U\n\n\nBCs = assign(\n    region = mesh_dev,\n    (\n        U = [\n            Dirichlet(:inlet, velocity),\n            Zerogradient(:outlet),\n            Wall(:bump, [0.0, 0.0, 0.0]),\n            Empty(:frontAndBack),\n            group_bcs_U...,\n        ],\n        p = [\n            Zerogradient(:inlet),\n            Dirichlet(:outlet, 0.0),\n            Wall(:bump),\n            Empty(:frontAndBack),\n            group_bcs_p...,\n        ],\n        k = [\n            Dirichlet(:inlet, k_inlet),\n            Zerogradient(:outlet),\n            KWallFunction(:bump),\n            Empty(:frontAndBack),\n            group_bcs_k...,\n        ],\n        omega = [\n            Dirichlet(:inlet, ω_inlet),\n            Zerogradient(:outlet),\n            OmegaWallFunction(:bump),\n            Empty(:frontAndBack),\n            group_bcs_omega...,\n        ],\n        nut = [\n            Extrapolated(:inlet),\n            Extrapolated(:outlet),\n            Dirichlet(:bump, 0.0),\n            Empty(:frontAndBack),\n            group_bcs_nut...,\n        ],\n    )\n)\n\nschemes = (\n    U = Schemes(divergence=Upwind),\n    p = Schemes(divergence=Upwind),\n    y = Schemes(),\n    k = Schemes(divergence=Upwind),\n    omega = Schemes(divergence=Upwind)\n)\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(),\n        convergence = 1e-8,\n        relax       = 0.6,\n        rtol = 1e-3\n    ),\n    p = SolverSetup(\n        solver      = Cg(),\n        preconditioner = DILU(),\n        convergence = 1e-11,\n        relax       = 0.2,\n        rtol = 1e-3,\n        itmax = 4000\n    ),\n    y = SolverSetup(\n        solver      = Cg(),\n        preconditioner = Jacobi(),\n        convergence = 1e-10,\n        rtol = 1e-5,\n        relax       = 0.7,\n        itmax = 5000\n    ),\n    k = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(),\n        convergence = 1e-10,\n        relax       = 0.6,\n        rtol = 1e-3\n    ),\n    omega = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(), \n        convergence = 1e-10,\n        relax       = 0.6,\n        rtol = 1e-3\n    )\n)\n\nruntime = Runtime(iterations=5000, write_interval=100, time_step=1)\nruntime = Runtime(iterations=1, write_interval=1, time_step=1) #hide\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\nGC.gc()\n\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 0.0)\ninitialise!(model.turbulence.k, k_inlet)\ninitialise!(model.turbulence.omega, ω_inlet)\ninitialise!(model.turbulence.nut, k_inlet/ω_inlet)\n\nresiduals = run!(model, config, output=OpenFOAM())","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Results","page":"Verification: 2D bump k-omega SST","title":"Results","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#XCALibre-solution","page":"Verification: 2D bump k-omega SST","title":"XCALibre solution","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"(Image: Simulation domain)","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Quantitative-comparision","page":"Verification: 2D bump k-omega SST","title":"Quantitative comparision","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"The figure below compares the results obtained with OpenFOAM and XCALibre.jl. The profiles are extracted along the y-direction at x = 0.75 m and 1.20 m. ","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Profiles-at-x-0.75-m","page":"Verification: 2D bump k-omega SST","title":"Profiles at x = 0.75 m","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"(Image: Comparison with OpenFOAM - x = 0.75m)","category":"page"},{"location":"examples/07_2d-bump-komegaSST/#Profiles-at-x-1.20-m","page":"Verification: 2D bump k-omega SST","title":"Profiles at x = 1.20 m","text":"","category":"section"},{"location":"examples/07_2d-bump-komegaSST/","page":"Verification: 2D bump k-omega SST","title":"Verification: 2D bump k-omega SST","text":"(Image: Comparison with OpenFOAM - x = 1.20m)","category":"page"},{"location":"user_guide/0_introduction_and_workflow/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"This page explains the overarching workflow in XCALibre.jl and provides a list of contents","category":"page"},{"location":"user_guide/0_introduction_and_workflow/#Workflow-overview","page":"Introduction","title":"Workflow overview","text":"","category":"section"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"XCALibre.jl has been designed to incorporate a logical workflow, that is, the sequence of setup steps that would take a user naturally from the start of a simulation to its final post-processing. The key steps are listed below","category":"page"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"Pre-processing - this step involves defining the computational domain and selecting the corresponding backend to performs the calculations\nPhysics and models - this step involves defining the fluid type, flow properties, selecting appropriate models and setting suitable boundary conditions\nNumerical setup - in this phase of the simulation set up all aspect related to the numerics are chosen, from distretisation schemes all the way to solvers and preconditioners. \nRuntime and solvers - once everything has been set up, the simulation is ready to run, once runtime information such as time steps and solution saving intervals has been selected. The final step is to actually start the simulation.\nPost-processing - the final step is to enjoy all the pretty pictures!","category":"page"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"The user guide is structured such that the information provided is grouped following the workflow illustrated above. For convenience the contents of the user guide are included below, with links to the relevant sections.","category":"page"},{"location":"user_guide/0_introduction_and_workflow/#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"user_guide/0_introduction_and_workflow/","page":"Introduction","title":"Introduction","text":"Pages = Main.USER_GUIDE_PAGES\nDepth = 2","category":"page"},{"location":"user_guide/3_numerical_setup/#Numerical-setup","page":"Numerical setup","title":"Numerical setup","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Available discretisation schemes, linear solvers and preconditioners","category":"page"},{"location":"user_guide/3_numerical_setup/#Discretisation-schemes","page":"Numerical setup","title":"Discretisation schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Part of the methodology to solve the various model equations using the Finite Volume Method (FVM) is to discretise each equation term, essentially, this process linearises the partial differential equation so that it can be represented as a system of linear equations, which can be solved using linear algebra along with iterative solvers. This section presents the discretisation schemes currently available in XCALibre.jl.","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Discretisation schemes in XCALibre.jl are organised under the abstract type AbstractScheme. As shown previously, a list of available schemes can be found using the  subtypes function:","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"using XCALibre # hide\nusing AbstractTrees # hide\n# import Main.subtypes as subtypes # hide\n    using InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = Main.subtypes(d) # hide\nprint_tree(AbstractScheme) # hide","category":"page"},{"location":"user_guide/3_numerical_setup/#Schemes-available","page":"Numerical setup","title":"Schemes available","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/#Time-schemes","page":"Numerical setup","title":"Time schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Scheme Description\nSteadyState sets the time derivative to zero\nEuler First order implicit Euler scheme\nCrankNicolson Second order central scheme (not implemented yet)","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/#Laplacian-schemes","page":"Numerical setup","title":"Laplacian schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Scheme Description\nLinear 2nd order Gauss gradient scheme with linear interpolation","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/#Divergence-schemes","page":"Numerical setup","title":"Divergence schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Scheme Description\nLinear 2nd order central difference\nUpwind 1st order upwind scheme\nBoundedUpwind Bounded version of the Upwind scheme\nLUST 1st/2nd order mixed scheme (fixed at 75% Linear - 25% Upwind)","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/#Gradient-schemes","page":"Numerical setup","title":"Gradient schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Scheme Description\nGauss Green-Gauss uncorrected gradient scheme\nMidpoint Green-Gauss skew corrected scheme (2 iterations - hardcoded)","category":"page"},{"location":"user_guide/3_numerical_setup/#Gradient-limiters","page":"Numerical setup","title":"Gradient limiters","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Scheme Description\nFaceBased Limit gradient calculation based on face extrapolation\nMFaceBased Limit gradient calculation based on face extrapolation in multiple dimensions","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"The construction of all gradient limiters currently requires users to pass the mesh object that will be used for the simulations e.g. MFaceBased(mesh). Notice that the mesh object must be moved to the same device where the simulation will be performed. To prevent mistakes and avoid errors, it is recommended to construct the limiters using the simulation Physics object directly since it provide a reference to the mesh (domain) e.g. if a Physics object named model has been created, construct the limiter as MFaceBased(model.domain)","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/#Specifying-schemes","page":"Numerical setup","title":"Specifying schemes","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"XCALibre.jl flow solvers offer considerable flexibility to users for defining discretisation schemes. However, this means that discretisation schemes must be specified for every term of every equation solved. The schemes must be provided as a NamedTuple where each keyword corresponds to the fields being solved, e.g. (U = ..., p = ..., k = ..., <field> = ...). To facilitate this process, the Schemes function is provided. Used without any inputs Schemes uses the default values provided (see details below).","category":"page"},{"location":"user_guide/3_numerical_setup/#XCALibre.Solve.Schemes-user_guide-3_numerical_setup","page":"Numerical setup","title":"XCALibre.Solve.Schemes","text":"Schemes(;\n    # keyword arguments and their default values\n    time=SteadyState,\n    divergence=Linear, \n    laplacian=Linear, \n    gradient=Gauss,\n    limiter=nothing) = begin\n\n    # Returns Schemes struct used to configure discretisation\n    \n    Schemes(\n        time=time,\n        divergence=divergence,\n        laplacian=laplacian,\n        gradient=gradient,\n        limiter=limiter\n    )   \nend\n\nThe Schemes struct is used at the top-level API to help users define discretisation schemes for every field solved.\n\nInputs\n\ntime: is used to set the time schemes (default is SteadyState)\ndivergence: is used to set the divergence scheme (default is Linear) \nlaplacian: is used to set the laplacian scheme (default is Linear)\ngradient:  is used to set the gradient scheme (default is Gauss)\nlimiter: is used to specify if gradient limiters should be used, currently supported limiters include FaceBased and MFaceBased (default is nothing)\n\n\n\n\n\n","category":"type"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"For example, below we set the schemes for the  U and p fields. Notice that in the first case the schemes will take their default values (entry for p). In the case of U, we are only changing the setting for the divergence scheme to Upwind.","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"using XCALibre\n\n# Note: this example assumes a Physics object named `model` already exists\n\nschemes = (\n    p = Schemes(), # no input provided (will use defaults)\n    U = Schemes(divergence = Upwind, gradient=Midpoint, limiter=MFaceBased(model.domain)),\n)","category":"page"},{"location":"user_guide/3_numerical_setup/#Linear-solvers","page":"Numerical setup","title":"Linear solvers","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Linear solvers in XCALibre.jl are provided by Krylov.jl. The following solvers types are re-exported in XCALibre.jl","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Bicgstab() is a general purpose linear solver. Works well with non-symmetric matrices e.g. for U.\nCg() is particular strong with symmetric matrices e.g to solve the pressure equation.\nGmres() is a general solver. We have found it works best on the CPU backend.","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"For more information on these solvers you can review the excellent documentation provided by the Krylov.jl team. ","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"XCALibre.jl provides the SolverSetup convenience function for setting solvers. See details below. ","category":"page"},{"location":"user_guide/3_numerical_setup/#XCALibre.Solve.SolverSetup-user_guide-3_numerical_setup","page":"Numerical setup","title":"XCALibre.Solve.SolverSetup","text":"SolverSetup(; \n        # required keyword arguments \n\n        solver::S, \n        preconditioner::PT, \n        convergence, \n        relax,\n\n        # optional keyword arguments\n\n        float_type=Float64,\n        smoother=nothing,\n        limit=nothing,\n        itmax::Integer=1000, \n        atol=(eps(_get_float(region)))^0.9,\n        rtol=_get_float(region)(1e-1)\n\n    ) where {S,PT<:PreconditionerType} = begin\n\n        return SolverSetup(kwargs...)  \nend\n\nThis function is used to provide solver settings that will be used internally in XCALibre.jl. It returns a SolverSetup object with solver settings that are used internally by the flow solvers. \n\nInput arguments\n\nsolver: solver object from Krylov.jl and it could be one of Bicgstab(), Cg(), Gmres() which are re-exported in XCALibre.jl\npreconditioner: instance of preconditioner to be used e.g. Jacobi()\nconvergence sets the stopping criteria of this field\nrelax: specifies the relaxation factor to be used e.g. set to 1 for no relaxation\nsmoother: specifies smoothing method to be applied before discretisation. JacobiSmoother: is currently the only choice (defaults to nothing)\nlimit: used in some solvers to bound the solution within these limits e.g. (min, max). It defaults to nothing\nitmax: maximum number of iterations in a single solver pass (defaults to 1000) \natol: absolute tolerance for the solver (default to eps(FloatType)^0.9)\nrtol: set relative tolerance for the solver (defaults to 1e-1)\nfloat_type: specifies the floating point type to be used by the solver. It is also used to estimate the absolute tolerance for the solver (defaults to Float64)\n\n\n\n\n\n","category":"type"},{"location":"user_guide/3_numerical_setup/#Preconditioners","page":"Numerical setup","title":"Preconditioners","text":"","category":"section"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"XCALibre.jl offers a range of preconditioners which are subtypes of the abstract type PreconditionerType, exploring its subtypes we can find a list of the currently available preconditioners: ","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"using XCALibre # hide\nusing AbstractTrees # hide\n# import Main.subtypes as subtypes # hide\n    using InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = Main.subtypes(d) # hide\nprint_tree(PreconditionerType) # hide","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"note: Note\nOnly the Jacobi and NormDiagonal preconditioners have GPU ready implementations. At present these have the most robust implementation and they can be used with both CPU and GPU backends. The other preconditioners can only be used on the CPU. Notice that on our tests the LDL preconditioner only works when paired with the Gmres() on the CPU. Also notice that the implementations for DILU (experimental), IC0GPU and ILU0GPU (NVIDIA only), should be considered experimental. Work on improving the offering of preconditioners is ongoing.","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"warning: Warning\nInternally the storage for sparse matrices was moved to the CSR format. Thus, temporarily, we have removed support for LDL and ILU0 preconditioners while we work on CSR compatible implementations. ","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"Below an example is provided in context. Here, we are setting solvers for both the velocity field U and the pressure field p and packing them into a NamedTuple \"solvers\". The Jacobi preconditioner is used in both solvers. Notice that preconditioners are specified with an instance of their type i.e. Jacobi(). Internally, the preconditioner instance is used for dispatch. This tupple will then be passed on to create the final Configuration object.","category":"page"},{"location":"user_guide/3_numerical_setup/","page":"Numerical setup","title":"Numerical setup","text":"using XCALibre\n\n# Note: this example assumes a Physics object named `model` already exists\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(), # Gmres()\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-4,\n        atol = 1e-10\n    ),\n    p = SolverSetup(\n        solver      = Cg(), # Bicgstab(), Gmres()\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-4,\n        atol = 1e-10\n    )\n)","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Exploring the performance of XCALibre.jl","category":"page"},{"location":"benchmarks/#Introduction","page":"Benchmarks","title":"Introduction","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This space will be used to explore the performance of various flow solvers and XCALibre.jl more broadly, and tests/benchmarks will be added as they become available. Eventually, our hope is to have benchmarks for all the solvers available in XCALibre.jl, but this will take time. Users are welcome to share their own benchmarks.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In general, it is accepted that benchmarking code is no easy task. Benchmarks that explore relative performance between different functionality within the same codebase tend to be easier, or more reliable. However, when comparing performance of \"similar\" functionality between different codebases is particularly challenging, and comparing the performance of different CFD codes is no exception. This is due to different implementation choices, difference in numerics, algorithm differences, etc., etc. Thus, it should be stressed that any results discussed herein should be accepted in this context. To enable some degree of transparency, our goal is to make all benchmark results and setup available to the community for scrutiny. Benchmark cases will be published in a separate Github repository, XCALibre_benchmarks. Any errors or methodology inconsistencies identified by the community can be identified, and we encourage user to report them.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Due to licensing considerations, it is not possible to report any direct benchmarks comparing performance between XCALibre.jl and commercial CFD codes. Thus, unless otherwise stated, the benchmarks included here are all likely to compare performance against OpenFOAM (foundation) or OpenFOAM (ESI). Specific versions used will be reported (and updated as far as possible). It should be stressed that the main XCALibre.jl developers are all OpenFOAM users and we hold this CFD package is very high regard, and as an established open-source CFD code it makes a perfect candidate to use in our benchmarking efforts, especially for ouf CPU implementation performance. ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This page will be updated as new results become available, but do bare with us, this exercise will take time. Thanks!","category":"page"},{"location":"benchmarks/#Laminar-incompressible-solver-(3D)","page":"Benchmarks","title":"Laminar incompressible solver (3D)","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"benchmarks/#Case-and-set-up-information","page":"Benchmarks","title":"Case and set up information","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"In this first benchmark, the performance of the laminar solver implementation in XCALibre.jl is explored. The configuration corresponds to a backward-facing step geometry with a mesh with approximately 500,000 cells. The test case mesh file, along with setup files for both XCALibre.jl and OpenFOAM can be found here.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The following cases were tested:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Case Code Version Backend Variable Solver Preconditioner\nOF11 Similar OpenFOAM OpenFOAM 11 (foundation) CPU Velocity \\ Pressure PBiCGStab \\ PCG diagonal \\ diagonal\nOF11 Best OpenFOAM OpenFOAM 11 (foundation) CPU Velocity \\ Pressure PBiCGStab \\ GAMG DILU \\ none\nv0.3.2 XCALibre.jl v0.3.2 (Julia v0.10.6) CPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal\nv0.3.3 XCALibre.jl v0.3.3 (Julia v0.10.6) CPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal\nv0.5.0 XCALibre.jl v0.5.0 (Julia v0.11.5) CPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal\nv0.3.2 GPU XCALibre.jl v0.3.2 (Julia v0.10.6) GPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal\nv0.3.3 GPU XCALibre.jl v0.3.3 (Julia v0.10.6) GPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal\nv0.5.0 GPU XCALibre.jl v0.5.0 (Julia v0.11.5) GPU Velocity \\ Pressure BiCGStab \\ CG diagonal \\ diagonal","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Notice that the OF11 Similar case aims to provide a configuration in OpenFOAM that is comparable to the numerical setup used (and available) in XCALibre.jl. The OF11 Best uses the most performant setup available in OpenFOAM, in terms of the linear solver and preconditioner combination. Discretisation schemes and solver tolerance are kept as similar as possible for all cases. The XCALibre.jl test cases aim to provide relative performance between difference versions and backends.","category":"page"},{"location":"benchmarks/#Hardware","page":"Benchmarks","title":"Hardware","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All tests were performed on an ASUS TUF Gaming A15 FA506 with 16Gb of RAM, an AMD Ryzen™ 7 4800H CPU and. GPU test cases ran on the laptop's NVIDIA RTX 2060 with 6Gb of VRAM. Ubuntu 21.04 LTS was the operating system and it was set up to \"performance\" mode to ensure that power was reduced during tests (particularly important of GPU tests).","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The execution time for the various test cases is shown in the figure below. This is the total time required to complete 500 iterations. This includes memory allocation time and a single write-to-file event. The cases were run with an increasing number of CPUs, ranging from 1 to 8 CPU cores.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: Execution time)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Firstly, the results show that there has been a substantial performance improvement in the latest version of XCALibre.jl (v0.3.3). In version v0.3.2, XCALibre.jl was generally slower than OpenFOAM when using a similar numerical setup (OF11 Similar), with the exception of cases where low CPU cores were used. In v0.3.3, XCALibre.jl is showing faster computing than the OF11 Similar regardless of the number of cores used. However, when OpenFOAM is setup using the more advanced solvers (i.e. GAMG) and preconditioners available (e.g. DILU), it achieves a further reduction in compute time. However, when executing on a modest NVIDIA RTX 2060 GPU backend, XCALibre.jl is able to complete the calculation at even lower computation times. ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To better understand the performance gains achieved in XCALibre.jl v0.3.3, the relative computation time is plotted in the figure below. Notice that the \"speed up\" figures shown are found by dividing the runtime for a given case with the simulation time for a single core run when using v0.3.2. In a nutshell, the results show that v0.3.3 achieves performance gains in the range of 2-5x. Also, the most performance configuration in OpenFOAM (OF11 Best) has gains in the range of 2-8x. This is encouraging, but highlights that there is still room to improve performance in the CPU implementation of the laminar solver in XCALibre.jl. It is also encouraging to see that XCALibre.jl GPU performance is significantly faster that both OpenFOAM and XCALibre.jl (on CPU) with a speed up of approximately 17x. A considerable performance  gain for the GPU implementation is also achieved in v0.3.3 compared to v0.3.2. Internally, the major change was a change of the sparse matrix storage format from CSC to CSR, which allows the use of optimised sparse matrix operations (available in CUDA.jl), but also the re-implementation of some kernel to take advantage of the row storage used in the CSR format. Further performance improvements were achieved in v0.5.0 by implementing better logic for assigning boundary conditions, as well as more robust boundary condition implementations.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: Speed up comparison)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Lastly, the scaling behaviour of the codes has been explored and shown in the figure below. In a nutshell, OpenFOAM shows the best scaling overall, specially for case OF1 Similar. The latest version of XCALibre.jl is showing a similar trend to the OF11 Best case, but the results point to the need to further improve the implementation in XCALibre.jl to improve its scaling behaviour.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: Parallel scaling)","category":"page"},{"location":"user_guide/2_physics_and_models/#Physics-and-models","page":"Physics and models","title":"Physics and models","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Information about setting up a Physics object and boundary conditions to represent the flow physics","category":"page"},{"location":"user_guide/2_physics_and_models/#Physics-model-definition","page":"Physics and models","title":"Physics model definition","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"The Physics object is part of the highest level API in XCALibre.jl. Physics objects are a means for users to set up the physics and models that are relevant to their particular CFD simulation. Internally, the Physics model created is passed to solvers and is used for dispatch (solvers, algorithms and models). Thus, it is important to ensure that the information provided to this object is correct and representative of the user's intentions. Physics models consist of a struct with the  fields shown below. All fields must be provided to the solvers otherwise the construction of the object will fail.","category":"page"},{"location":"user_guide/2_physics_and_models/#XCALibre.ModelPhysics.Physics-user_guide-2_physics_and_models","page":"Physics and models","title":"XCALibre.ModelPhysics.Physics","text":"struct Physics{T,F,SO,M,Tu,E,D,BI}\n    time::T\n    fluid::F\n    solid::SO\n    momentum::M \n    turbulence::Tu \n    energy::E\n    domain::D\n    boundary_info::BI\nend\n\nXCALibre's parametric Physics type for user-level API. Also used to dispatch flow solvers.\n\nFields\n\ntime::Union{Steady, Transient}   – User-provided time model.\nfluid::AbstractFluid  – User-provided Fluid` model.\nsolid::AbstractSolid  – User-provided Solid` model.\nmomentum  – Momentum model. Currently this is auto-generated by the Physics constructor\nturbulence::AbstractTurbulenceModel  – User-provided Turbulence` model.\nenergy:AbstractEnergyModel  – User-provided Energy model.\ndomain::AbstractMesh  – User-provided Mesh. Must be adapted to target device before constructing a Physics object.\nboundary_info::boundary_info  – Mesh boundary information.  Auto-generated by the Physics constructor\n\n\n\n\n\n","category":"type"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For convenience, XCALibre.jl provides a more user-friendly constructor that will automatically take care of the construction of derived fields.","category":"page"},{"location":"user_guide/2_physics_and_models/#XCALibre.ModelPhysics.Physics-Tuple{}-user_guide-2_physics_and_models","page":"Physics and models","title":"XCALibre.ModelPhysics.Physics","text":"Physics(; time, fluid, solid, turbulence, energy, domain)::Physics{T,F,SO,M,Tu,E,D,BI}\n\nPhysics constructor part of the top-level API. It can be used to define the Physics and models relevant to a simulation. This constructor uses keyword arguments to allow users to fine-tune their simulations, whilst some fields are auto-generated behind the scenes for convenience (Momentum and boundary_info). Where:\n\ntime - specified the time model (Steady or Transient)\nfluid - specifies the type of fluid (Incompressible, etc.)\nturbulence - specified the Turbulence model\nenergy - specifies the Energy treatment\ndomain - provides the mesh to used (must be adapted to the target backend device)\n\n\n\n\n\n","category":"method"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"At this point, it is worth reminding users that one of the benefits of working with Julia is its dynamic nature. This means that objects can be dynamically interrogated. For example:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre\nfieldnames(Physics)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"This will provide users with all the fields that make up the Physics object. This is a nice way to explore the makeup of any object in Julia (and by extension XCALibre.jl). The rest of this page will provide details of the physics models available in XCALibre.jl, including:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Time models\nFluid types\nTurbulence models\nEnergy models","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"warning: Warning\nThe mesh provided to the domain field must already be adapted to the required backend device. See Backend selection for detail. ","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"note: Note\nIn the next version of XCALibre.jl the field boundary_info will be likely removed outside of the Physics object in order to improve on the current performance (avoiding unnecessary memory movement between GPU backends and the host devices).","category":"page"},{"location":"user_guide/2_physics_and_models/#Time-models","page":"Physics and models","title":"Time models","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Earlier in this section, the dynamic nature of Julia was mentioned in the context of extracting fields for the Physics model used in XCALibre.jl. In the following sections this benefit of using Julia will be exploited further. XCALibre.jl takes advantage of Julia's rich type system and we define Abstract types to organise major functionality. For example, time models are subtypes of the abstract type AbstractTimeModel. Therefore, out-of-the-box we get for free a means to explore implemented features in XCALibre.jl. For example, to identify the time models implemented, we simply need to type the following in the REPL:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre\n# import Main.subtypes as subtypes # hide\nusing InteractiveUtils # Load from standard library\nMain.subtypes(AbstractTimeModel)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"From the output it can be seen that there are two time models in XCALibre.jl for Steady or Transient simulations. These are singleton types and contain (at present) no internal fields or data. They are largely used by XCALibre.jl to dispatch either steady or transient solvers. We are starting to get a picture of how the Physics object is constructed. For example, to specify a Steady simulation","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"The time model can be specified as Steady as follows:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady()\n    ...\n)","category":"page"},{"location":"user_guide/2_physics_and_models/#Fluid-types","page":"Physics and models","title":"Fluid types","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Following from the idea of using Julia's dynamic features to explore the types available in XCALibre.jl, in this section we will explore the fluid types available. This time, we will use a helper package AbstractTrees (which can be installed in the usual way, by entering into package mode in the REPL and typing add AbstractTrees). In XCALibre.jl all fluid types are subtypes of AbstractFluid. The types available are shown in the example below:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"begin\n    # Note: this code snippet will not be shown later for succinctness\n    using XCALibre\n    using InteractiveUtils # Load from standard library\n    # using Pkg; Pkg.add(\"AbstractTrees\") # run to install AbstractTrees\n    using AbstractTrees \n    # import Main.subtypes as subtypes # hide\n    AbstractTrees.children(d::DataType) = Main.subtypes(d)\n    print_tree(AbstractFluid)\nend","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"From the subtype tree above, we can see that XCALibre.jl offers 2 major abstract fluid types, AbstractIncompressible and AbstractCompressible. There are 3 concrete fluid types:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Incompressible - for simulations were the fluid density does not change with pressure\nWeaklyCompressible - for simulation were the fluid density is allowed to change (no shockwaves)\nCompressible - for simulations were discontinuities may appear (not available for general use yet)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"To specify a given fluid type, the Fluid wrapper type is used as a general constructor which is specialised depending depending on the fluid type from the list above provided by the user. The constructors require the following inputs:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For incompressible fluid flow","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Fluid{Incompressible}(; nu, rho=1.0) ","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For compressible fluids (weak formulation)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Fluid{WeaklyCompressible}(; nu, cp, gamma, Pr)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"where the input variables represent the following:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"nu - kinematic viscosity\nrho - fluid density\ngamma - specific heat ratio\nPr - Prandlt number\ncp - specific heat at constant pressure","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For example, an incompressible fluid can be specified as follows","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu=1e-5),\n    ...\n)","category":"page"},{"location":"user_guide/2_physics_and_models/#Turbulence-models","page":"Physics and models","title":"Turbulence models","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Below is a representation of the AbstractTurbulenceModel inheritance tree. It shows turbulence models available. Turbulence models are defined using the RANS and LES constructors and passing a specific turbulence model type. As it will be illustrated in the flowing sections.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre # hide\nusing AbstractTrees # hide\n# import Main.subtypes as subtypes # hide\n    using InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = Main.subtypes(d) # hide\nprint_tree(AbstractTurbulenceModel) # hide","category":"page"},{"location":"user_guide/2_physics_and_models/#RANS-models-constructors","page":"Physics and models","title":"RANS models constructors","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Laminar model: no user input is required. This is a dummy model that does not contribute to the momentum equation.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"RANS{Laminar}() # only constructor needed","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"KOmega model: the standard 2 equation Wilcox model coefficients are passed by default. This model solves 2 transport equations for the turbulent kinetic energy and the specific dissipation rate,  k and omega, respectively. Subsequently, k and omega are used to update the turbulent eddy viscosity, nut. These 3 fields must be provided with boundary conditions. ","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"RANS{KOmega}() # will set the default coefficient values shown below\nRANS{KOmega}(; β⁺=0.09, α1=0.52, β1=0.072, σk=0.5, σω=0.5) # set defaults\nRANS{KOmega}(β1=0.075) # user can choose to change a single coefficient","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"KOmegaLKE model: the user must provide a reference turbulence intensity (Tu) and a tuple of symbols specifying wall boundaries. This model uses 3 equations (k, kl, omega) to update the eddy viscosity (nut). These fields must be provided with boundary conditions.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"RANS{KOmegaLKE}(; Tu::Number, walls::Tuple) # no defaults defined\nRANS{KOmegaLKE}(Tu = 0.01, walls=(:cylinder,)) # user should provide information for Tu and walls","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For example, a steady, incompressible simulation using the KOmega model can be specified as","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu=1e-5),\n    turbulence = RANS{KOmega}(),\n    ...\n)","category":"page"},{"location":"user_guide/2_physics_and_models/#LES-models","page":"Physics and models","title":"LES models","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Laminar model: no user input is required. This is a dummy model that does not contribute to the momentum equation. It can be used to carry out LES simulations of laminar flows. For sufficiently refined grids, this model can be used for DNS simulations. Since XCALibre.jl is a Finite Volume Method solver, for complex geometries the simulation should be regarded as a quasi-DNS simulation. For second order accurate DNS simulations very high quality hex grids should be used.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"LES{Laminar}() # only constructor needed","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Smagorinsky model: the standard model constant is passed by default. Boundary conditions for nut must be provided, generally zero gradient conditions work well. No special wall functions for nut in LES mode are available.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"LES{Smagorinsky}() # default constructor will use value below\nLES{Smagorinsky}(; C=0.15) # default value provided by default\nLES{Smagorinsky}(C=0.1) # user selected value","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For example, an incompressible LES simulation with the Smagorinsky model can be specified as","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Transient(),\n    fluid = Fluid{Incompressible}(nu=1e-5),\n    turbulence = LES{Smagorinsky}(),\n)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"note: Note\nIn the specification above the time model was set as Transient since LES models are strictly time-resolving. A simulation might run when the Steady model is chosen, but the results would likely not be reliable. XCALibre.jl by design offers flexibility for users to customise their setup, the consequence is that it falls on users to define a combination of models that is appropriate. Likewise, in the example above an Isothermal energy model would have to be selected. See Energy models","category":"page"},{"location":"user_guide/2_physics_and_models/#Energy-models","page":"Physics and models","title":"Energy models","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Currently, XCALibre.jl offers two options to model the energy equation. A tree of the AbstractEnergyModel is shown below. The top-level constructor for energy models is the Energy type. Specific constructor signatures are also illustrated below.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre # hide\nusing AbstractTrees # hide\n# import Main.subtypes as subtypes # hide\n    using InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = Main.subtypes(d) # hide\nprint_tree(AbstractEnergyModel) # hide","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Isothermal model: assumes temperature effects are negligible. Used for incompressible solvers.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Energy{Isothermal}() # default constructor","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"SensibleEnthalpy model: uses the sensible enthalpy model for the energy equation. Required for the compressible solvers.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Energy{SensibleEnthalpy}(; Tref)  # constructor definition. No default values given to Tref keyword\nEnergy{SensibleEnthalpy}(Tref=300)  # Users must provide a referent temperature value","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For example, a steady, compressible RANS simulation with the KOmegaLKE model can be specified as","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady(),\n    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),\n    turbulence = RANS{KOmegaLKE}(),\n    energy = Energy{SensibleEnthalpy}(Tref=300),\n    ...\n)","category":"page"},{"location":"user_guide/2_physics_and_models/#Domain-definition","page":"Physics and models","title":"Domain definition","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"The final step when defining a Physics model is to specify the domain on which the various models will be used. This is simply a reference to the mesh object.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Continuing from the previous example, a steady, compressible RANS simulation with the KOmegaLKE model can be specified as","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady(),\n    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),\n    turbulence = RANS{KOmegaLKE}(),\n    energy = Energy{SensibleEnthalpy}(Tref=300),\n    domain = mesh_dev\n)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"warning: Warning\nWhen passing the mesh objective to complete the definition of the Physics object, the mesh must be adapted to the target device where the computation will be performed. See Backend selection for more details.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Notice that the transfer to the target compute backend can also be done inline. For example,","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Physics(\n    time = Steady(),\n    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),\n    turbulence = RANS{KOmegaLKE}(),\n    energy = Energy{SensibleEnthalpy}(Tref=300),\n    domain = adapt(CUDABackend(), mesh) # for Nvidia GPUs\n)","category":"page"},{"location":"user_guide/2_physics_and_models/#Boundary-conditions","page":"Physics and models","title":"Boundary conditions","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"The final step to completely capture the physics for the simulation is to define boundary conditions in order to find a concrete solution of the model equations being solved. XCALibre.jl offers a range of boundary conditions. As before, boundary conditions are specified by type and the are classified under the AbstractBoundary type and subdivided into 4 additional abstract types AbstractDirichlet, AbstractNeumann, AbstractPhysicalConstraint and AbstractWallFunction. The complete abstract tree is illustrated below.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre # hide\nusing AbstractTrees # hide\n# import Main.subtypes as subtypes # hide\n    using InteractiveUtils # hide\nAbstractTrees.children(d::DataType) = Main.subtypes(d) # hide\nprint_tree(AbstractBoundary) # hide","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Philosophically, the four subtypes represent different physical types of boundary conditions:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"AbstractDirichlet boundary conditions are used to assign a concrete value to field at the boundary.\nAbstractNeumann boundaries are used to fix the field gradient at the boundary.\nAbstractPhysicalConstraint boundaries represent physical constraints imposed on the domain.\nAbstractWallFunction represent models for treating flow or turbulence quantities in wall regions.","category":"page"},{"location":"user_guide/2_physics_and_models/#AbstractDirichlet-conditions","page":"Physics and models","title":"AbstractDirichlet conditions","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Dirichlet(name, value)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name\nvalue is a vector or scalar defining desired value at the boundary","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"FixedTemperature(name; T, model::EnergyModel<:AbstractEnergyModel)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name\nT is a keyword argument to define the temperate value to be assigned at the boundary\nmodel is a keyword argument that expects an instance of the energy model to be used e.g. SensibleEnergy","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"DirichletFunction(name, func)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name\nfunc is a function identifier. func is a user-defined function (but can also be a neural network) that returns a scalar or vector as a function of time and space.\nfunc must adhere to an internal contract. See XCALibre.Discretise.DirichletFunction for more details.","category":"page"},{"location":"user_guide/2_physics_and_models/#AbstractNeumann-conditions","page":"Physics and models","title":"AbstractNeumann conditions","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Extrapolated(name, value)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name\nvalue is a scalar defining the gradient normal to the boundary","category":"page"},{"location":"user_guide/2_physics_and_models/#AbstractPhysicalConstraint-conditions","page":"Physics and models","title":"AbstractPhysicalConstraint conditions","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Wall boundary conditions can be used to provide a boundary with a wall constraint. This boundary type, at present, can only be used to define vectors. For scalar quantities in wall regions a Extrapolated (zero gradient) should be imposed.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Wall(name, value)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name\nvalue is a vector defining wall velocity e.g. [0, 0, 0]","category":"page"},{"location":"user_guide/2_physics_and_models/#XCALibre.Discretise.RotatingWall-user_guide-2_physics_and_models","page":"Physics and models","title":"XCALibre.Discretise.RotatingWall","text":"RotatingWall <: AbstractPhysicalConstraint\n\nRotatingWall boundary condition model for no-slip  for rotating RotatingWalls (rotating around an axis). It has been strictly implemented to work with vectors only. \n\nInputs\n\nrpm provides the rotating speed (internally converted to radian/second)\ncentre vector indicating the location of the rotation centre e.g. [0,0,0]\naxis unit vector indicating the rotation axis e.g. [1,0,0]\n\nExample\n\nRotatingWall(:inner_wall, rpm=100, centre=[0,0,0], axis=[0,0,1])\n\n\n\n\n\n","category":"type"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Symmetry boundary condition can be used to assign a symmetry constraint to a given boundary patch in the domain. It can be used for both vector and scalar quantities.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Symmetry(name)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"Periodic boundaries consist of a pair of boundary patches that behave as if they are physically connected. The periodic boundary essentially provides a mapping between these patches and helps in calculating the face values at the interface. The construction of periodic boundaries is different to other boundary conditions because the addressing between each face for the patch pair needs to be calculated and stored. Periodic boundary can be constructed as follows:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"periodic::Tuple = construct_periodic(mesh, backend, patch1::Symbol, patch2::Symbol)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"mesh is a reference to the mesh object\nbackend defines the expected backend e.g. CPU(), CUDABackend, etc.\npatch1 and patch2 symbols of the two patch pair we would like to flag as periodic","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"The output is a tuple containing two Periodic boundary types with information relevant to each boundary patch pair and it can be used directly to assign a periodic boundary for both patches (by splatting into the assignment macro e.g. periodic...)","category":"page"},{"location":"user_guide/2_physics_and_models/#AbstractWallFunction-conditions","page":"Physics and models","title":"AbstractWallFunction conditions","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"KWallFunction provides a turbulent kinetic energy boundary condition for high-Reynolds models.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"KWallFunction(name)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"OmegaWallFunction provides a value for the specific dissipation rate for both low- and high-Reynolds model.","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"OmegaWallFunction(name)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"NutWallFunction provides a value for the eddy viscosity for high-Reynolds models","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"NutWallFunction(name)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"name is a symbol providing the boundary name","category":"page"},{"location":"user_guide/2_physics_and_models/#Assigning-conditions-(macro)","page":"Physics and models","title":"Assigning conditions (macro)","text":"","category":"section"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"XCALibre.jl requires that a boundary condition is assigned to every single patch in the domain (as defined within the mesh object) for every field that is part of the solution. To facilitate this process, XCALibre.jl provides the @assign macro for convenience. The @assign macro has the following signature:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"@assign! model::Physics <physical model> <field> (\n    <patch1 boudary>, \n    <patch2 boundary>, \n    ...\n    )","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"For example, for a laminar incompressible simulation, only the momentum equation is being solved. Therefore, users need to provide conditions for every patch for the U and  p fields in the momentum model:","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"using XCALibre\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"backwardFacingStep_10mm.unv\"\nmesh_file = joinpath(grids_dir, grid)\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\nbackend = CPU() #  run on CPU\nhardware = Hardware(backend=backend, workgroup=4)\nmesh_dev = mesh # dummy assignment \n\n# Flow conditions\nvelocity = [1.5, 0.0, 0.0]\nnu = 1e-3\nRe = velocity[1]*0.1/nu # Reynolds number\n\n# Physics models\nmodel = Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh_dev\n    )\n\n# Define boundary conditions\nBCs = assign(\n    region=mesh_dev,\n    (\n        U = [\n            Dirichlet(:inlet, velocity),\n            Extrapolated(:outlet),\n            Wall(:wall, [0.0, 0.0, 0.0]),\n            Wall(:top, [0.0, 0.0, 0.0])\n        ], \n        p = [\n            Extrapolated(:inlet),\n            Dirichlet(:outlet, 0.0),\n            Wall(:wall), # scalar wall - set up as zero gradient\n            Wall(:top)   # scalar wall - set up as zero gradient\n        ]\n    )\n)","category":"page"},{"location":"user_guide/2_physics_and_models/","page":"Physics and models","title":"Physics and models","text":"hint: Hint\nJulia is a dynamic language and objects can be interrogated on the fly (dynamically). Say you created a Physics model named mymodel, you can interrogate the contents of any of the fields in the Physics structure using the fieldnames function, e.g. fieldnames(mymodel.momentum), to find which fields need to be provided with boundary conditions. Any fields not ending in f should be set. ","category":"page"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Read this section for information about how to install XCALibre.jl and an example showcasing the API","category":"page"},{"location":"quick_start/#Installation","page":"Quick Start","title":"Installation","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"First, you need to download and install Julia on your system. Once you have a working installation of Julia, XCALibre.jl can be installed using the built-in package manager. ","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"XCALibre.jl is available directly from the the General Julia Registry. Thus, to install XCALibre.jl open a Julia REPL, press ] to enter the package manager. The REPL prompt icon will change from julia> (green) to pkg> (and change colour to blue) or (myenvironment) pkg> where myenvironment is the name of the currently active Julia environment. Once you have activated the package manager mode enter","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"pkg> add XCALibre","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To install XCALibre.jl directly from Github enter the following command (for the latest release)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"pkg> add https://github.com/mberto79/XCALibre.jl.git","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"A specific branch can be installed by providing the branch name precided by a #, for example, to install the dev-0.3-main branch enter","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"pkg> add https://github.com/mberto79/XCALibre.jl.git#dev-0.3-main","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"note: Note\nTo enable GPU acceleration you will also need to install the corresponding GPU package for your hardware. See CUDA.jl, AMD.jl, oneAPI.jl for more details. XCALibre.jl will automatically precompile and load the relevant backend specific functionality (using Julia extensions)","category":"page"},{"location":"quick_start/#Example","page":"Quick Start","title":"Example","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The example below illustrates the top-level API used in XCALibre.jl. It shows the key steps a user needs to follow to set up a simulation:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Pre-processing (steps 1 and 2)\nPhysics and models (steps 3 to 5)\nNumerical setup (steps 6 and 7)\nRuntime and solvers setup (steps 8 to 11)\nPost-processing (step 12)","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Once you have installed Julia and XCALibre.jl, the example below can be run by copying the contents shown below and pasting them in a file. The file can be executed within vscode, the Julia REPL or from a system terminal. ","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To run in vscode check the information for using Julia in vscode\nTo run in the Julia REPL, simply launch Julia and type include(\"name_of_your_file.jl\")\nTo run from a system terminal (bash or cmd, for example), simply type path/to/julia name_of_your_file.jl","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"In most cases, it is preferable to run simulations from within the Julia REPL because, in Julia, there is often a cost associated to the first run due to compilation time. By relaunching a simulation in the REPL, all previously compiled code will not be recompiled. This is particularly helpful in the prototyping stages. For long running simulations, the compilation time is normally negligible compared to the actual time needed to complete the simulation.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"\n# Step 0. Load libraries\nusing XCALibre\n# using CUDA # Uncomment to run on NVIDIA GPUs\n# using AMDGPU # Uncomment to run on AMD GPUs\n\n\n# Step 1. Define mesh\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"backwardFacingStep_10mm.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001) # convert mesh\n\n# Step 2. Select backend and setup hardware\nbackend = CPU()\n# backend = CUDABackend() # ru non NVIDIA GPUs\n# backend = ROCBackend() # run on AMD GPUs\n\nhardware = Hardware(backend=backend, workgroup=1024)\n# hardware = Hardware(backend=backend, workgroup=32) # use for GPU backends\n\nmesh_dev = mesh # use this line to run on CPU\n# mesh_dev = adapt(backend, mesh)  # Uncomment to run on GPU \n\n# Step 3. Flow conditions\nvelocity = [1.5, 0.0, 0.0]\nnu = 1e-3\nRe = velocity[1]*0.1/nu\n\n# Step 4. Define physics\nmodel = Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh_dev\n    )\n\n# Step 5. Define boundary conditions\nBCs = assign(\n    region=mesh_dev,\n    (\n        U = [\n            Dirichlet(:inlet, velocity),\n            Extrapolated(:outlet),\n            Wall(:wall, [0.0, 0.0, 0.0]),\n            Wall(:top, [0.0, 0.0, 0.0])\n        ],\n        p = [\n            Extrapolated(:inlet),\n            Dirichlet(:outlet, 0.0),\n            Wall(:wall),\n            Wall(:top)\n        ]\n    )\n)\n\n# Step 6. Choose discretisation schemes\nschemes = (\n    U = Schemes(divergence = Linear),\n    p = Schemes() # no input provided (will use defaults)\n)\n\n# Step 7. Set up linear solvers and preconditioners\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(), # Options: Gmres()\n        preconditioner = Jacobi(), # Options: NormDiagonal()\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-1\n    ),\n    p = SolverSetup(\n        solver      = Cg(), # Options: Cg(), Bicgstab(), Gmres()\n        preconditioner = Jacobi(), # Options: NormDiagonal()\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-2\n    )\n)\n\n# Step 8. Specify runtime requirements\nruntime = Runtime(iterations=2000, time_step=1, write_interval=2000)\nruntime = Runtime(iterations=1, time_step=1, write_interval=-1) # hide\n\n# Step 9. Construct Configuration object\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\n# Step 10. Initialise fields (initial guess)\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 0.0)\n\n# Step 11. Run simulation\nresiduals = run!(model, config);\n\n# Step 12. Post-process\npwd() # find active directory where the file \"iteration_002000.vtk\" was saved","category":"page"},{"location":"quick_start/#Output","page":"Quick Start","title":"Output","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"If you chose to run the example above, XCALibre.jl would have written a simulation result file to your computer. The name of the file is iteration_002000.vtk. The file will be located in your current active directory (you can check this by running pwd()). This file can be open directly in ParaView for further post-processing. You can find out more about ParaView on their website. The image below is the output solution generated by XCALibre.jl to the example simulation above.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: Simulation result visualisation in ParaView)","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Verification:-2D-incompressible-backward-facing-step","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Introduction","page":"Verification: 2D incompressible backward-facing step","title":"Introduction","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"The correct implementation of the laminar solver in XCALibre.jl has been verified by quantitatively comparing results with those obtained with OpenFOAM. The simulation set up and mesh file used to run the simulation with XCALibre.jl are available in this repository.","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Simulation-setup","page":"Verification: 2D incompressible backward-facing step","title":"Simulation setup","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"\nusing XCALibre\n# using CUDA # Uncomment to run on NVIDIA GPUs\n# using AMDGPU # Uncomment to run on AMD GPUs\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"backwardFacingStep_10mm.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\n# Select backend and setup hardware\nbackend = CPU()\n# backend = CUDABackend() # ru non NVIDIA GPUs\n# backend = ROCBackend() # run on AMD GPUs\n\nhardware = Hardware(backend=backend, workgroup=1024)\n# hardware = Hardware(backend=backend, workgroup=32) # use for GPU backends\n\nmesh_dev = mesh # use this line to run on CPU\n# mesh_dev = adapt(backend, mesh)  # Uncomment to run on GPU \n\nvelocity = [1.5, 0.0, 0.0]\nnu = 1e-3\nRe = velocity[1]*0.1/nu\n\nmodel = Physics(\n    time = Steady(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh_dev\n    )\n\nBCs = assign(\n    region=mesh_dev,\n    (\n        U = [\n            Dirichlet(:inlet, velocity),\n            Extrapolated(:outlet),\n            Wall(:wall, [0.0, 0.0, 0.0]),\n            Wall(:top, [0.0, 0.0, 0.0])\n        ],\n        p = [\n            Extrapolated(:inlet),\n            Dirichlet(:outlet, 0.0),\n            Wall(:wall),\n            Wall(:top)\n        ]\n    )\n)\n\nschemes = (\n    U = Schemes(divergence = Linear),\n    p = Schemes() # no input provided (will use defaults)\n)\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(), # Options: Gmres()\n        preconditioner = Jacobi(), # Options: NormDiagonal()\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-4,\n        atol = 1e-10\n    ),\n    p = SolverSetup(\n        solver      = Cg(), # Options: Cg(), Bicgstab(), Gmres()\n        preconditioner = Jacobi(), # Options: NormDiagonal()\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-4,\n        atol = 1e-10\n    )\n)\n\nruntime = Runtime(iterations=2000, time_step=1, write_interval=2000)\nruntime = Runtime(iterations=1, time_step=1, write_interval=-1) # hide\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 0.0)\n\nresiduals = run!(model, config);","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Results","page":"Verification: 2D incompressible backward-facing step","title":"Results","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Domain-and-mesh","page":"Verification: 2D incompressible backward-facing step","title":"Domain and mesh","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"(Image: Simulation domain)","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#OpenFoam-solution","page":"Verification: 2D incompressible backward-facing step","title":"OpenFoam solution","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"(Image: Simulation domain)","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#XCALibre-solution","page":"Verification: 2D incompressible backward-facing step","title":"XCALibre solution","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"(Image: Simulation domain)","category":"page"},{"location":"examples/01_2d-isothermal-backward-facing-step/#Quantitative-comparision","page":"Verification: 2D incompressible backward-facing step","title":"Quantitative comparision","text":"","category":"section"},{"location":"examples/01_2d-isothermal-backward-facing-step/","page":"Verification: 2D incompressible backward-facing step","title":"Verification: 2D incompressible backward-facing step","text":"The figure below compares the results obtained with OpenFOAM and XCALibre.jl. The profiles are extracted along the y-direction at x = 0.5 m.  (Image: Comparison with OpenFOAM)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Validation:-2D-Constant-temperature-flat-plate","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Introduction","page":"Validation: 2D Constant temperature flat plate","title":"Introduction","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"A 2D constant temperature laminar flat plate case has been used to validate the weakly  compressible solver. The case provides a constant temperature boundary condition along the  wall of the domain. ","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"The Nusselt number values obtained from the simulation are compared against the theoretical local Nusselt number correlation  for forced convection on constant temperature flat plate:","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Nu_x = 0332 Re_x^12 Pr^13","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"The correlation is valid for Prandtl numbers greater than 0.6.","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Boundary-conditions","page":"Validation: 2D Constant temperature flat plate","title":"Boundary conditions","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Inlet","page":"Validation: 2D Constant temperature flat plate","title":"Inlet","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Field Boundary condition\nU Dirichlet ([0.2, 0.0, 0.0] m/s)\np Extrapolated (Zero-gradient)\nT FixedTemperature (300.0 K)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Wall","page":"Validation: 2D Constant temperature flat plate","title":"Wall","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Field Boundary condition\nU No-slip wall\np Extrapolated (Zero-gradient)\nT FixedTemperature (310.0 K)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Outlet","page":"Validation: 2D Constant temperature flat plate","title":"Outlet","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Field Boundary condition\nU Extrapolated (Zero-gradient)\np Dirichlet (0.0 Pa)\nT Extrapolated (Zero-gradient)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Top","page":"Validation: 2D Constant temperature flat plate","title":"Top","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Field Boundary condition\nU Extrapolated (Zero-gradient)\np Extrapolated (Zero-gradient)\nT Extrapolated (Zero-gradient)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Fluid-Properties","page":"Validation: 2D Constant temperature flat plate","title":"Fluid Properties","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"Property value\nnu 0.0001\nPr 0.71\nc_p 1005.0\ngamma 1.4","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Mesh","page":"Validation: 2D Constant temperature flat plate","title":"Mesh","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"The mesh is shown in the figure below. The plate is represented by the \"wall\" boundary. The flow moves from left to right (\"inlet\" to \"outlet\" boundaries). The x-axis is aligned with the wall boundary and the y-axis is position in the direction perpendicular to the wall.","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"(Image: Figure 1)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"The streamwise cell length is 2mm with a total domain length of 1m. The near-wall cell height is 0.049mm with a domain height of 0.2m.","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Case-file","page":"Validation: 2D Constant temperature flat plate","title":"Case file","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"using XCALibre\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"flatplate_2D_laminar.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\nvelocity = [0.2, 0.0, 0.0]\nnu = 1e-4\nRe = velocity[1]*1/nu\ncp = 1005.0\ngamma = 1.4\nPr = 0.7\n\nmodel = Physics(\n    time = Steady(),\n    fluid =  Fluid{WeaklyCompressible}(\n        nu = nu,\n        cp = cp,\n        gamma = gamma,\n        Pr = Pr\n        ),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{SensibleEnthalpy}(Tref = 288.15),\n    domain = mesh # mesh_dev  # use mesh_dev for GPU backend\n    )\n\nBCs = assign(\n    region=mesh,\n    (\n        U = [\n            Dirichlet(:inlet, velocity),\n            Extrapolated(:outlet),\n            Wall(:wall, [0.0, 0.0, 0.0]),\n            Symmetry(:top)\n        ],\n        p = [\n            Extrapolated(:inlet),\n            Dirichlet(:outlet, 100000.0),\n            Wall(:wall),\n            Symmetry(:top)\n        ],\n        h = [\n            FixedTemperature(:inlet, T=300.0, Enthalpy(cp=cp, Tref=288.15)),\n            Extrapolated(:outlet),\n            FixedTemperature(:wall, T=310.0, Enthalpy(cp=cp, Tref=288.15)),\n            Symmetry(:top)\n        ],\n    )\n)\n\nschemes = (\n    U = Schemes(divergence=Linear),\n    p = Schemes(divergence=Linear),\n    h = Schemes(divergence=Linear)\n)\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-1\n    ),\n    p = SolverSetup(\n        solver      = Cg(),\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 0.3,\n        rtol = 1e-1\n    ),\n    h = SolverSetup(\n        solver      = Bicgstab(),\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 0.7,\n        rtol = 1e-1\n    )\n)\n\nruntime = Runtime(iterations=1000, write_interval=1000, time_step=1)\nruntime = Runtime(iterations=1, write_interval=-1, time_step=1) # hide\n\nhardware = Hardware(backend=CPU(), workgroup=4)\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\nGC.gc()\n\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 100000.0)\ninitialise!(model.energy.T, 300.0)\n\nresiduals = run!(model, config)","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/#Results","page":"Validation: 2D Constant temperature flat plate","title":"Results","text":"","category":"section"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"The results of the model are compared to the theoretical correlation in the figure below:","category":"page"},{"location":"examples/03_2d-constant-temperature-flat-plate/","page":"Validation: 2D Constant temperature flat plate","title":"Validation: 2D Constant temperature flat plate","text":"(Image: Nusselt number distribution results.)","category":"page"},{"location":"contributor_guide/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Guidelines and practical information for contributing to XCALibre.jl","category":"page"},{"location":"contributor_guide/#Introduction","page":"Contributor Guide","title":"Introduction","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"In time, our ambition is to document the internal API completely, however, this will take some time and it is an ongoing process. Since XCALibre.jl uses a modular approach and the current functionality covers a good portion of the CFD stack, those interested in working with the internal API should be able to work from existing implementations. In this page we provide key information for those users who want to customise, refine, improve, or extend XCALibre.jl.","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"From its humble beginning as a 1D diffusion example code to explore the features of the Julia programming language (and speed claims which turned out to be true 😄), XCALibre.jl was meant to be shared and used to help students understand the Finite Volume Method and as an entry point to explore the implementation details underpinning CFD. As the code base has grown, this original purpose remains. However, XCALibre.jl is now a more complete CFD software stack which can be used by both researchers and students to test out new ideas, even on complex geometry with acceptable performance. XCALibre.jl will hopefully continue to grow and offer more functionality as it has been the case since work on XCALibre.jl started. In the sharing spirit of open-source software we also welcome code contributions, and we hope to make this process as simple as possible. However, we ask contributors to follow a few guidelines to ensure that we grow XCALibre.jl in a sustainable and maintainable manner.","category":"page"},{"location":"contributor_guide/#Some-guidelines","page":"Contributor Guide","title":"Some guidelines","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"To help use keep the codebase consistent and allow us to merge future Pull Requests (PRs) more easily, we kindly request that contributors adhere to some basic guidelines. We are trying to strike a balance between consistency and ease of contribution by aiming not to be overly demanding on contributors. A minimum set of guidelines is provided below (subject to review as the codebase evolves), in no particular order:","category":"page"},{"location":"contributor_guide/#Code-style","page":"Contributor Guide","title":"Code style","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Follow the style guide recommended in the official Julia documentation\nUse camel case format for custom types e.g. MyType\nWe prefer easy-to-read function names e.g. use calculate_flux over calf or similar. All in lower case and words separated with an underscore\nFor internal variables feel free to use Unicode symbols, or camel case identifiers. However, please refrain from doing this for any top-level or user-facing API variables.\nAlthough Julia allows some impressive one-liners, please avoid. These can be hard to reason sometimes, aim to strike a balance between succinctness and clarity. ","category":"page"},{"location":"contributor_guide/#Code-contribution","page":"Contributor Guide","title":"Code contribution","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Please open a PR for any code contributions against our main branch if your are contributing top level functionality that builds on existing code e.g. a new turbulence model or a new boundary condition (these contributions will typically be included inside one of the existing sub modules)\nFor contributions that may require code reorganisation please do get in touch to ensure this aligns with any planned changes (open an issue). PRs will likely be requested against the current dev branch\nIdeally, all contributions will also include basic documentation and tests.","category":"page"},{"location":"contributor_guide/#Help-wanted","page":"Contributor Guide","title":"Help wanted","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"If you have specific expertise in MPI or Multi-GPU implementation and wish to get involved please get in touch.","category":"page"},{"location":"contributor_guide/#Module-organisation","page":"Contributor Guide","title":"Module organisation","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Module Description\nXCALibre.Mesh This module defines all types required to construct the mesh object used by the flow solvers. Two main mesh types are used Mesh2 and Mesh3 used for 2D and 3D simulations, respectively. Some access functions are also included in this module.\nXCALibre.Fields This module defines the fields used to hold and represent the flow variable. Scalar, vector and tensor fields are defined e.g. ScalarField, etc. Information is stored at cell centres. These fields also have face variant where information is stored at face centres e.g. FaceVectorField. These fields are generally used to store fluxes. A limited set of field operations are also defined e.g. getfield to allow indexing field object directly.\nXCALibre.ModelFramework This module provides the framework used to define scalar and vector model equations whilst storing information about the operators used. The data structure also defines sparse matrices used to store discretisation information.\nXCALibre.Discretise This module defines the various operators needed to represent each terms in a model equation and the main discretisation loop that linearises each term according to the schemes available. Boundary conditions are also implemented in this module.\nXCALibre.Solve This module includes all functions and logic needed to solve the linear system of equations that follows the equation discretisation. The internal API to solve these systems of equations is included in this module.\nXCALibre.Calculate Implementation of functions use to carry out calculations essential to the implementation of flow solvers is included in this module. This includes interpolation of variables from cell centroid to cell faces, gradient calculation, surface normals, etc.\nXCALibre.ModelPhysics This module includes the implementations of all the physical models i.e. fluid, turbulence and energy models.\nXCALibre.Simulate This model contains information needed to set up a simulation, including the Configuration type used by all flow solvers.\nXCALibre.Solvers Implementations of the SIMPLE and PISO flow solvers from steady and unsteady solutions, including their compressible variant.\nXCALibre.Postprocess A limited set of functions for postprocessing are implemented in this module.\nXCALibre.IOFormats Functionality to write simulation results to VTK or OpenFOAM output files are implemented in this module.\nXCALibre.FoamMesh Stand alone module to parse, process (geometry calculation) and import OpenFOAM mesh files into XCALibre.jl\nXCALibre.UNV3 Stand alone module to parse, process (geometry calculation) and import UNV (3D) mesh files into XCALibre.jl\nXCALibre.UNV2 Stand alone module to parse, process (geometry calculation) and import UNV (2D) mesh files into XCALibre.jl","category":"page"},{"location":"contributor_guide/#Key-types-and-structures","page":"Contributor Guide","title":"Key types and structures","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/#Mesh-type-and-format","page":"Contributor Guide","title":"Mesh type and  format","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The definitions of the data structures used to define Mesh3 objects is given below. Note that for succinctness only 3D structures are shown since all the 2D structures are identical. The type is only used for dispatching solvers to operate in 2D or 3D. ","category":"page"},{"location":"contributor_guide/#XCALibre.Mesh.Mesh3-contributor_guide","page":"Contributor Guide","title":"XCALibre.Mesh.Mesh3","text":"struct Mesh3{VC, VI, VF<:AbstractArray{<:Face3D}, VB, VN, SV3, UR} <: AbstractMesh\n    cells::VC           # vector of cells\n    cell_nodes::VI      # vector of indices to access cell nodes\n    cell_faces::VI      # vector of indices to access cell faces\n    cell_neighbours::VI # vector of indices to access cell neighbours\n    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )\n    faces::VF           # vector of faces\n    face_nodes::VI      # vector of indices to access face nodes\n    boundaries::VB      # vector of boundaries\n    nodes::VN           # vector of nodes\n    node_cells::VI      # vector of indices to access node cells\n    get_float::SV3      # store mesh float type\n    get_int::UR         # store mesh integer type\n    boundary_cellsID::VI # vector of indices of boundary cell IDs\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/#XCALibre.Mesh.Node-contributor_guide","page":"Contributor Guide","title":"XCALibre.Mesh.Node","text":"struct Node{SV3<:SVector{3,<:AbstractFloat}, UR<:UnitRange{<:Integer}}\n    coords::SV3     # node coordinates\n    cells_range::UR # range to access neighbour cells in Mesh3.node_cells\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/#XCALibre.Mesh.Face3D-contributor_guide","page":"Contributor Guide","title":"XCALibre.Mesh.Face3D","text":"struct Face3D{\n    F<:AbstractFloat, \n    SV2<:SVector{2,<:Integer},\n    SV3<:SVector{3,F}, \n    UR<:UnitRange{<:Integer}\n    }\n    \n    nodes_range::UR # range to access face nodes in Mesh3.face_nodes\n    ownerCells::SV2 # IDs of face owner cells (always 2)\n    centre::SV3     # coordinates of face centre\n    normal::SV3     # face normal unit vector\n    e::SV3          # unit vector in the direction between owner cells\n    area::F         # face area\n    delta::F        # distance between owner cells centres\n    weight::F       # linear interpolation weight\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/#XCALibre.Mesh.Cell-contributor_guide","page":"Contributor Guide","title":"XCALibre.Mesh.Cell","text":"struct Cell{F<:AbstractFloat, SV3<:SVector{3,F},UR<:UnitRange{<:Integer}}\n    centre::SV3     # coordinate of cell centroid\n    volume::F       # cell volume\n    nodes_range::UR # range to access cell nodes in Mesh3.cell_nodes\n    faces_range::UR # range to access cell faces info (faces, neighbours cells, etc.)\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/#XCALibre.Mesh.Boundary-contributor_guide","page":"Contributor Guide","title":"XCALibre.Mesh.Boundary","text":"struct Boundary{S<:Symbol, UR<:UnitRange{<:Integer}}\n    name::S         # Boundary patch name\n    IDs_range::UR   # range to access boundary info (faces and boundary_cellsID)\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"To fully characterise how mesh information is represented in XCALibre.jl, it is important to highlight the following \"contracts\" that are exploited throughout:","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Node, face and cell IDs correspond to the index where they are stored in their corresponding vector in the Mesh3 structure e.g. Mesh3.Faces[10] would return information for the face whose ID is 10. These vectors are 1-indexed as standard in Julia.\nFace normals at boundary faces is always pointing outside the domain e.g. they point in the direction expected in the FVM\nFace normals for internal faces is always pointing in the direction from the ownerCell with the smallest ID to the largest. Since the discretisation loop is cell based, for the cell with the highest ID the direction must be reversed. This information is tracked in Mesh3.nsign which stores 1 if the face normal is correctly aligned or -1 if the normal needs to be reversed.\nBoundary faces (e.g. patches) are stored consecutively in Mesh3.Faces starting at the beginning of the array followed by all the internal faces.\nBoundary faces are those connected only to 1 Cell, thus, for these faces the entry Face3D.ownerCells is a 2-element vector with a repeated index e.g. [3, 3]\nBoundary cells only store information for internal faces. This improves performance for the main discretisation loop (cell based) since it can always been assumed that none of the faces will be a boundary face, which are dealt with in a separate loop.","category":"page"},{"location":"contributor_guide/#Field-types","page":"Contributor Guide","title":"Field types","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"After the Mesh2 and Mesh3 objects, the most fundamental data structure in XCALibre.jl are fields used to represent the flow variables. In the current implementation, the prime field is the ScalarField for storing information at cell centres, and the corresponding FaceScalarField to store information at cell faces (normally fluxes). Internally, both are identical, therefore, the internal structure of the \"Face\" variants will not be discussed. ScalarFields have the following definition:","category":"page"},{"location":"contributor_guide/#XCALibre.Fields.ScalarField-contributor_guide","page":"Contributor Guide","title":"XCALibre.Fields.ScalarField","text":"struct ScalarField{VF,M,BC} <: AbstractScalarField\n    values::VF  # scalar values at cell centre\n    mesh::M     # reference to mesh\n    BCs::BC     # store user-provided boundary conditions\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Vector and tensors are represented internally by their individual components, as an illustration the VectorField type is shown below. Notice that each component of both vector and tensor fields are themselves represented by the same ScalarField type shown above. This has some implementation benefits, i.e. reducing duplication and allowing for rapid development. However, the performance of other means of storing these fields is being investigated. Thus, these internals may change if we identify performance gains.","category":"page"},{"location":"contributor_guide/#XCALibre.Fields.VectorField-contributor_guide","page":"Contributor Guide","title":"XCALibre.Fields.VectorField","text":"struct VectorField{S1<:ScalarField,S2,S3,M<:AbstractMesh,BC} <: AbstractVectorField\n    x::S1   # x-component is itself a `ScalarField`\n    y::S2   # y-component is itself a `ScalarField`\n    z::S3   # z-component is itself a `ScalarField`\n    mesh::M\n    BCs::BC\nend\n\n\n\n\n\n","category":"type"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"All fields behave (mostly) like regular arrays and can be indexed using the standard Julia syntax e.g. say U is a VectorField, then U[3] would return the vector stored in cell with ID = 3 (as a SVector{3} for improved performance).","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"note: Note\nThe implementation of broadcasting operations has been put on hold until a more thorough investigation of alternative data structures for vector and tensor fields has been completed. This is ongoing work. ","category":"page"},{"location":"contributor_guide/#Boundary-conditions","page":"Contributor Guide","title":"Boundary conditions","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"To implement a new boundary condition the following elements are required (see source code for Dirichlet, for example):","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"type definition: a structure containing the fields :ID and :value\nfixedValue function: used to check that user provided information is suitable for this boundary being implemented\nImplementation of the boundary face value: functor defining the boundary condition implementation, facilitated by a macro (see details below)\nScalar and vector face value interpolation: kernels to specify how to transfer cell information to the boundary. ","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Developers and contributors are encouraged to explore the source code for examples on existing implementations of boundary conditions. To ease their implementation the XCALibre.Discretise.@define_boundary is provided.","category":"page"},{"location":"contributor_guide/#XCALibre.Discretise.@define_boundary-contributor_guide","page":"Contributor Guide","title":"XCALibre.Discretise.@define_boundary","text":"macro define_boundary(boundary, operator, definition)\n    quote\n        @inline (bc::$boundary)(\n            term::Operator{F,P,I,$operator}, cellID, zcellID, cell, face, fID, i, component, time\n            ) where {F,P,I} = $definition\n    end |> esc\nend\n\nMacro to reduce boilerplate code when defining boundary conditions (implemented as functors) and provides access to key fields needed in the implementation of boundary conditions, such as the boundary cell and face objects (more details below)\n\nInput arguments\n\nboundary specifies the boundary type being defined\noperator specifies the operator to which the condition applies e.g. Laplacian\ndefinition provides the implementation details\n\nAvailable fields\n\nterm reference to operator on which the boundary applies (gives access to the field and mesh) \ncellID ID of the corresponding boundary cell\nzcellID sparse matrix linear index for the cell\ncell gives access to boundary cell object and corresponding information\nface gives access to boundary face object and corresponding information\nfID ID of the boundary face (to index Mesh2.faces vector)\ni local index of the boundary faces within a kernel or loop\ncomponent for vectors this specifies the components being evaluated (access as component.value). For scalars component = nothing\ntime provides the current simulation time. This only applies to time dependent boundary implementation defined as functions or neural networks.\n\nExample\n\nBelow the use of this macro is illustrated for the implementation of a  Dirichlet boundary condition acting on the Laplacian using the Linear scheme:\n\n@define_boundary Dirichlet Laplacian{Linear} begin\n    J = term.flux[fID]      # extract operator flux\n    (; area, delta) = face  # extract boundary face information\n    flux = J*area/delta     # calculate the face flux\n    ap = term.sign*(-flux)  # diagonal (cell) matrix coefficient\n    ap, ap*bc.value         # return `ap` and `an`\nend\n\nWhen called, this functor will return two values ap and an, where ap is the cell contribution for approximating the boundary face value, and an is the explicit part of the face value approximation i.e. ap contributes to the diagonal of the sparse matrix (left-hand side) and an is the explicit contribution assigned to the solution vector b on the right-hand of the linear system of equations Ax = b\n\n\n\n\n\n","category":"macro"},{"location":"contributor_guide/#Implementing-new-models","page":"Contributor Guide","title":"Implementing new models","text":"","category":"section"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributor_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The internal API for models is still somewhat experimental, thus, it is more instructive to explore the source code. Although not fully finalised, the implementation is reasonably straight forward to follow thanks to the abstractions that have been adopted, some of which are described above, as well as the use of descriptive names for internal functions. If you need help on any aspect of the internals, for now, it is recommended to contact us by opening an issue.","category":"page"},{"location":"user_guide/5_postprocessing/#Post-processing","page":"Post-processing","title":"Post-processing","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"Information about postprocessing XCALibre.jl results","category":"page"},{"location":"user_guide/5_postprocessing/#ParaView","page":"Post-processing","title":"ParaView","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"All solvers in XCALibre.jl will write simulation results in formats that can be loaded directly in ParaView, which is the leading open-source project for scientific visualisation and postprocessing. More information about how to use ParaView can be found in the resources page on their website.","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"XCALibre.jl can output simulation results to either VTK compliant formats or OpenFOAM format. XCALibre.jl uses two different VTK formats depending on the type of flow solver used. For 2D simulations, the results are written to file using the .vtk file format. 3D simulations are written using the unstructured VTK file format, .vtu. ","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"note: Note\nA limitation of the current VTK writers in XCALibre.jl is that boundary information is stored along with internal mesh cell information, and results are stored at cell centres only. Thus, care must be taken when visualising results at boundary faces. Boundary information for fixedValue boundaries is displayed corrently when the results are saved in the OpenFOAM format. ","category":"page"},{"location":"user_guide/5_postprocessing/#Available-functions","page":"Post-processing","title":"Available functions","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"Although ParaView offers considerable flexibility for postprocessing results, users may also wish to carry out more advanced or different analyses on their CFD results. At present XCALibre.jl offers a limited set of built-in runtime postprocessing functions, currently these include time averaging a scalar or vector field over a specified range of iterations, and also the root mean square (RMS) of the fluctuations of a field. ","category":"page"},{"location":"user_guide/5_postprocessing/#Example:-Calculate-time-averaged-field","page":"Post-processing","title":"Example: Calculate time averaged field","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"As an example, to average any Scalar or Vector field an instance of FieldAverage must be created.","category":"page"},{"location":"user_guide/5_postprocessing/#XCALibre.Postprocess.FieldAverage-user_guide-5_postprocessing","page":"Post-processing","title":"XCALibre.Postprocess.FieldAverage","text":"FieldAverage(\n#required arguments\nfield;\nname::String,\n\n#optional keyword arguments\nstart::Real,\nstop::Real,\nupdate_interval::Real)\n\nConstructor to allocate memory to store the time averaged field. Once created, should be passed to the Configuration object as an argument with keyword postprocess\n\nInput arguments\n\nfield the VectorField or ScalarField to be averaged, e.g , model.momentum.U.\nname::String the name of the field to be averaged, e.g \"U_mean\", this is used only when exporting to .vtk format\n\nOptional arguments\n\nstart::Real optional keyword which specifies the start time/iteration of the averaging window, for steady simulations, this is in iterations, for transient simulations it is in flow time.   \nstop::Real optional keyword which specifies the end iteration/time of the averaging window. Default value is the last iteration/timestep. \nupdate_interval::Real optional keyword which specifies how often the time average of the field is updated and stored (default value is 1 i.e RMS updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the write_interval in Configuration. \n\n\n\n\n\n","category":"type"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"Once created this is simply passed to the Configuration object as an extra argument with the keyword postprocess. For example to average the velocity field over the whole simulation, ","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"postprocess = FieldAverage(model.momentum.U; name=\"U_mean\")\nconfig = Configuration(solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs,postprocess=postprocess)","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"The rest of the case would remain exactly the same. ","category":"page"},{"location":"user_guide/5_postprocessing/#Example:-Calculate-field-RMS","page":"Post-processing","title":"Example: Calculate field RMS","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"The RMS of a Scalar of Vector field can be obtained in a similar way to the time averaged field, instead an instance of FieldRMS is created which has the following definition. ","category":"page"},{"location":"user_guide/5_postprocessing/#XCALibre.Postprocess.FieldRMS-user_guide-5_postprocessing","page":"Post-processing","title":"XCALibre.Postprocess.FieldRMS","text":"FieldRMS(\n#required arguments\nfield;\nname::String,\n\n#optional keyword arguments\nstart::Real,\nstop::Real,\nupdate_interval::Real)\n\nConstructor to allocate memory to store the root mean square of the fluctuations of a field over the averaging window (in terms of iterations). Once created, should be passed to the Configuration object as an argument with keyword postprocess\n\nInput arguments\n\nfield the VectorField or ScalarField, e.g , model.momentum.U.\nname::String the name/label of the field to be averaged, e.g \"U_rms\", this is used only when exporting to .vtk format\n\nOptional arguments\n\nstart::Real optional keyword which specifies the start of the RMS calculation window, for steady simulations, this is in iterations, for transient simulations it is in flow time.   \nstop::Real optional keyword which specifies the end iteration/time of the RMS calculation window. Default value is the last iteration/timestep. \nupdate_interval::Real optional keyword which specifies how often the RMS of the field is updated and stored (default value is 1 i.e RMS updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the write_interval in Configuration. \n\n\n\n\n\n","category":"type"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"The RMS of the velocity field can be easily calculated by creating an instance of FieldRMS and passing it to the Configuration object with the keyword postprocess, with the rest of the case remaining unchanged.","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"postprocess = FieldRMS(model.momentum.U; name=\"U_rms\")\nconfig = Configuration(solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs,postprocess=postprocess)","category":"page"},{"location":"user_guide/5_postprocessing/#Example:-Calculate-time-average-and-RMS-for-multiple-fields-at-a-time","page":"Post-processing","title":"Example: Calculate time average and RMS for multiple fields at a time","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"To post-process multiple fields as a time, a vector of FieldAverage and FieldRMS objects can be passed instead e.g. ","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"postprocess = [FieldRMS(model.momentum.U; name=\"U_rms\"), FieldAverage(model.momentum.U; name =\"U_mean\"), FieldAverage(model.momentum.p; name =\"p_mean\")]\nconfig = Configuration(solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs,postprocess=postprocess)","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"If more functionality is required, defining new custom postprocessing functions is reasonably straight-forward since these can be written in pure Julia. In this section, examples of postprocessing functions will be provided as an illustration. ","category":"page"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"note: Note\nAt present the postprocessing functions available in XCALibre.jl shown below will only execute on CPUs and should be considered experimental. Once we settle on a \"sensible\" (maintainable and extensible) API, we plan to offer a larger selection of postprocessing tools which are likely to include options for runtime postprocessing.","category":"page"},{"location":"user_guide/5_postprocessing/#Example:-Calculate-boundary-average","page":"Post-processing","title":"Example: Calculate boundary average","text":"","category":"section"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"In this example, a function is shown that can be used to calculate the average on a user-provided boundary. ","category":"page"},{"location":"user_guide/5_postprocessing/#XCALibre.Postprocess.boundary_average-user_guide-5_postprocessing","page":"Post-processing","title":"XCALibre.Postprocess.boundary_average","text":"function boundary_average(patch::Symbol, field, config; time=0)\n    # Extract mesh object\n    mesh = field.mesh\n\n    # Determine ID (index) of the boundary patch \n    ID = boundary_index(mesh.boundaries, patch)\n    @info \"calculating average on patch: $patch at index $ID\"\n    boundary = mesh.boundaries[ID]\n    (; IDs_range) = boundary\n\n    # Create face field of same type provided by user (scalar or vector)\n    sum = nothing\n    if typeof(field) <: VectorField \n        faceField = FaceVectorField(mesh)\n        sum = zeros(_get_float(mesh), 3) # create zero vector\n    else\n        faceField = FaceScalarField(mesh)\n        sum = zero(_get_float(mesh)) # create zero\n    end\n\n    # Interpolate CFD results to boundary\n    interpolate!(faceField, field, config)\n    correct_boundaries!(faceField, field, field.BCs, time, config)\n\n    # Calculate the average\n    for fID ∈ IDs_range\n        sum += faceField[fID]\n    end\n    ave = sum/length(IDs_range)\n\n    # return average\n    return ave\nend\n\n\n\n\n\n","category":"function"},{"location":"user_guide/5_postprocessing/","page":"Post-processing","title":"Post-processing","text":"To calculate pressure and viscous forces, the following functions are available:","category":"page"},{"location":"user_guide/5_postprocessing/#XCALibre.Postprocess.pressure_force-user_guide-5_postprocessing","page":"Post-processing","title":"XCALibre.Postprocess.pressure_force","text":"pressure_force(patch::Symbol, p::ScalarField, rho)\n\nFunction to calculate the pressure force acting on a given patch/boundary.\n\nInput arguments\n\npatch::Symbol name of the boundary of interest (as a Symbol)\np::ScalarField pressure field\nrho density. Set to 1 for incompressible solvers\n\n\n\n\n\n","category":"function"},{"location":"user_guide/5_postprocessing/#XCALibre.Postprocess.viscous_force-user_guide-5_postprocessing","page":"Post-processing","title":"XCALibre.Postprocess.viscous_force","text":"viscous_force(patch::Symbol, U::VectorField, rho, ν, νt)\n\nFunction to calculate the pressure force acting on a given patch/boundary.\n\nInput arguments\n\npatch::Symbol name of the boundary of interest (as a Symbol)\nU::VectorField pressure field\nrho density. Set to 1 for incompressible solvers\nν laminar viscosity of the fluid\nνt eddy viscosity from turbulence models. Pass ConstantScalar(0) for laminar flows\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#XCALibre.Mesh.Boundary","page":"Reference","title":"XCALibre.Mesh.Boundary","text":"struct Boundary{S<:Symbol, UR<:UnitRange{<:Integer}}\n    name::S         # Boundary patch name\n    IDs_range::UR   # range to access boundary info (faces and boundary_cellsID)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Mesh.Cell","page":"Reference","title":"XCALibre.Mesh.Cell","text":"struct Cell{F<:AbstractFloat, SV3<:SVector{3,F},UR<:UnitRange{<:Integer}}\n    centre::SV3     # coordinate of cell centroid\n    volume::F       # cell volume\n    nodes_range::UR # range to access cell nodes in Mesh3.cell_nodes\n    faces_range::UR # range to access cell faces info (faces, neighbours cells, etc.)\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Mesh.Face3D","page":"Reference","title":"XCALibre.Mesh.Face3D","text":"struct Face3D{\n    F<:AbstractFloat, \n    SV2<:SVector{2,<:Integer},\n    SV3<:SVector{3,F}, \n    UR<:UnitRange{<:Integer}\n    }\n    \n    nodes_range::UR # range to access face nodes in Mesh3.face_nodes\n    ownerCells::SV2 # IDs of face owner cells (always 2)\n    centre::SV3     # coordinates of face centre\n    normal::SV3     # face normal unit vector\n    e::SV3          # unit vector in the direction between owner cells\n    area::F         # face area\n    delta::F        # distance between owner cells centres\n    weight::F       # linear interpolation weight\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Mesh.Mesh3","page":"Reference","title":"XCALibre.Mesh.Mesh3","text":"struct Mesh3{VC, VI, VF<:AbstractArray{<:Face3D}, VB, VN, SV3, UR} <: AbstractMesh\n    cells::VC           # vector of cells\n    cell_nodes::VI      # vector of indices to access cell nodes\n    cell_faces::VI      # vector of indices to access cell faces\n    cell_neighbours::VI # vector of indices to access cell neighbours\n    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )\n    faces::VF           # vector of faces\n    face_nodes::VI      # vector of indices to access face nodes\n    boundaries::VB      # vector of boundaries\n    nodes::VN           # vector of nodes\n    node_cells::VI      # vector of indices to access node cells\n    get_float::SV3      # store mesh float type\n    get_int::UR         # store mesh integer type\n    boundary_cellsID::VI # vector of indices of boundary cell IDs\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Mesh.Node","page":"Reference","title":"XCALibre.Mesh.Node","text":"struct Node{SV3<:SVector{3,<:AbstractFloat}, UR<:UnitRange{<:Integer}}\n    coords::SV3     # node coordinates\n    cells_range::UR # range to access neighbour cells in Mesh3.node_cells\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.UNV2.UNV2D_mesh-Tuple{Any}","page":"Reference","title":"XCALibre.UNV2.UNV2D_mesh","text":"UNV2D_mesh(meshFile; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 2D UNV mesh file into XCALibre.jl\n\nInput\n\nmeshFile – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.UNV3.UNV3D_mesh-Tuple{Any}","page":"Reference","title":"XCALibre.UNV3.UNV3D_mesh","text":"UNV3D_mesh(unv_mesh; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 3D UNV mesh file into XCALibre.jl. Note that a limitation of the .unv mesh format is that it only supports the following 3D cells:\n\nTetahedrals\nPrisms\nHexahedrals\n\nInput\n\nunv_mesh – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.FoamMesh.FOAM3D_mesh-Tuple{Any}","page":"Reference","title":"XCALibre.FoamMesh.FOAM3D_mesh","text":"FOAM3D_mesh(mesh_file; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 3D OpenFOAM mesh file into XCALibre.jl. Note that, at present, it is not recommended to run 2D cases using meshes imported using this function.\n\nInput\n\nmesh_file – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Multithread.activate_multithread-Tuple{CPU}","page":"Reference","title":"XCALibre.Multithread.activate_multithread","text":"activate_multithread(backend::CPU; nthreads=1) = BLAS.set_num_threads(nthreads)\n\nConvenience function to set number of BLAS threads. \n\nInput arguments\n\nbackend is the only required input which must be CPU() from KernelAbstractions.jl\nnthreads can be used to set the number of BLAS cores (default nthreads=1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Fields.ScalarField","page":"Reference","title":"XCALibre.Fields.ScalarField","text":"struct ScalarField{VF,M,BC} <: AbstractScalarField\n    values::VF  # scalar values at cell centre\n    mesh::M     # reference to mesh\n    BCs::BC     # store user-provided boundary conditions\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Fields.VectorField","page":"Reference","title":"XCALibre.Fields.VectorField","text":"struct VectorField{S1<:ScalarField,S2,S3,M<:AbstractMesh,BC} <: AbstractVectorField\n    x::S1   # x-component is itself a `ScalarField`\n    y::S2   # y-component is itself a `ScalarField`\n    z::S3   # z-component is itself a `ScalarField`\n    mesh::M\n    BCs::BC\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Fields.initialise!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Fields.initialise!","text":"function initialise!(field, value) # dummy function for documentation\n    # Assign `value` to field in-place\n    nothing\nend\n\nThis function will set the given field to the value provided in-place. Useful for initialising fields prior to running a simulation.\n\nInput arguments\n\nfield specifies the field to be initialised. The field must be either a AbractScalarField or AbstractVectorField\nvalue defines the value to be set. This should be a scalar or vector (3 components) depending on the field to be modified e.g. for an AbstractVectorField we can specify as value=[10,0,0]\n\nNote: in most cases the fields to be modified are stored within a physics model i.e. a Physics object. Thus, the argument value must fully qualify the model. For example, if we have created a Physics model named mymodel to set the velocity field, U, we would set the argument field to mymodel.momentum.U. See the example below.\n\nExample\n\ninitialise!(mymodel.momentum.U, [2.5, 0, 0])\ninitialise!(mymodel.momentum.p, 1.25)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Discretise.Dirichlet","page":"Reference","title":"XCALibre.Discretise.Dirichlet","text":"Dirichlet <: AbstractDirichlet\n\nDirichlet boundary condition model.\n\nInputs\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue Scalar or Vector value for Dirichlet boundary condition\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.DirichletFunction","page":"Reference","title":"XCALibre.Discretise.DirichletFunction","text":"DirichletFunction(ID, value) <: AbstractDirichlet\n\nDirichlet boundary condition defined with user-provided function.\n\nInput\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue Custom function or struct (<:XCALibreUserFunctor) for Dirichlet boundary condition\nIDs_range Range of indices to access boundary patch faces\n\nFunction requirements\n\nThe function passed to this boundary condition must have the following signature:\n\nf(coords, time, index) = SVector{3}(ux, uy, uz)\n\nWhere, coords is a vector containing the coordinates of a face, time is the current time in transient simulations (and the iteration number in steady simulations), and index is the local face index (from 1 to N, where N is the number of faces in a given boundary). The function must return an SVector (from StaticArrays.jl) representing the velocity vector. \n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Empty","page":"Reference","title":"XCALibre.Discretise.Empty","text":"Empty <: AbstractPhysicalConstraint\n\nEmpty boundary condition model (currently only configured for zero gradient)\n\nFields\n\n'ID' – Boundary ID\nvalue – Scalar or Vector value for Empty boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Extrapolated","page":"Reference","title":"XCALibre.Discretise.Extrapolated","text":"Extrapolated <: AbstractNeumann\n\nThis boundary condition extrapolates the face value using the interior cell value. Equivalent to setting a zero gradient boundary condition (semi-implicitly). It applies to both scalar and vector fields.\n\nExample\n\nExtrapolated(:outlet)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.FixedTemperature","page":"Reference","title":"XCALibre.Discretise.FixedTemperature","text":"FixedTemperature(name::Symbol, model::Enthalpy; T::Number)\n\nFixed temperature boundary condition model, which allows the user to specify wall temperature that can be translated to the energy specific model, such as sensible enthalpy.\n\nInputs\n\nname: Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nT: keyword argument use to define the boundary temperature \nmodel: defines the underlying Energy model to be used (currently only Enthalpy is available)\n\nExample\n\nFixedTemperature(:inlet, T=300.0, Enthalpy(cp=cp, Tref=288.15))\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Neumann","page":"Reference","title":"XCALibre.Discretise.Neumann","text":"Neumann <: AbstractNeumann\n\nNeumann boundary condition model to set the gradient at the boundary explicitly (currently only configured for zero gradient)\n\nInputs\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue Scalar providing face normal gradient\n\nExample\n\nNeumann(:outlet, 0)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.NeumannFunction","page":"Reference","title":"XCALibre.Discretise.NeumannFunction","text":"NeumannFunction(ID, value) <: AbstractNeumann\n\nNeumann boundary condition defined with user-provided function.\n\nInput\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue Custom function defining the desired Neumann boundary condition.\n\nFunction requirements\n\nThe function passed to this boundary condition has not yet been implemented. However, users can pass a custom struct to specialise the internal implementations of many functions. By default, at present, this function will assign a zero gradient boundary condition.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Periodic","page":"Reference","title":"XCALibre.Discretise.Periodic","text":"struct Periodic{I,V,R<:UnitRange} <: AbstractPhysicalConstraint\n    ID::I\n    value::V\nend\n\nPeriodic boundary condition model.\n\nFields\n\nID is the name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue tuple containing information needed to apply this boundary\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.RotatingWall","page":"Reference","title":"XCALibre.Discretise.RotatingWall","text":"RotatingWall <: AbstractPhysicalConstraint\n\nRotatingWall boundary condition model for no-slip  for rotating RotatingWalls (rotating around an axis). It has been strictly implemented to work with vectors only. \n\nInputs\n\nrpm provides the rotating speed (internally converted to radian/second)\ncentre vector indicating the location of the rotation centre e.g. [0,0,0]\naxis unit vector indicating the rotation axis e.g. [1,0,0]\n\nExample\n\nRotatingWall(:inner_wall, rpm=100, centre=[0,0,0], axis=[0,0,1])\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Symmetry","page":"Reference","title":"XCALibre.Discretise.Symmetry","text":"Symmetry <: AbstractBoundary\n\nSymmetry boundary condition vector and scalar fields. Notice that for scalar fields, this boundary condition applies an explicit zero gradient condition. In some rare cases, the use of an Extrapolated condition for scalars may be beneficial (to assign a semi-implicit zero gradient condition)\n\nInput\n\nID Name of the boundary given as a symbol (e.g. :freestream). Internally it gets replaced with the boundary index ID\n\nExample\n\nSymmetry(:freestream)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Wall","page":"Reference","title":"XCALibre.Discretise.Wall","text":"Wall <: AbstractDirichlet\n\nWall boundary condition model for no-slip  or moving walls (linear motion). It should be applied to the velocity vector, and in most cases, its scalar variant should be applied to scalars.\n\nInputs\n\nID represents the name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\nvalue should be given as a vector for the velocity e.g. [10,0,0]. For scalar fields such as the pressure the value entry can be omitted or set to zero explicitly.\n\nExamples\n\nWall(:plate, [0, 0, 0]) # no-slip wall condition for velocity\nWall(:plate) # corresponding definition for scalars, e.g. pressure\nWall(:plate, 0) # alternative definition for scalars, e.g. pressure\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.Zerogradient","page":"Reference","title":"XCALibre.Discretise.Zerogradient","text":"Zerogradient <: AbstractNeumann\n\nZerogradient boundary condition model (explicitly applied to the boundary)\n\nInput\n\nID Name of the boundary given as a symbol (e.g. :inlet). Internally it gets replaced with the boundary index ID\n\nExample\n\nZerogradient(:inlet)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Discretise.construct_periodic-Tuple{Any, Any, Symbol, Symbol}","page":"Reference","title":"XCALibre.Discretise.construct_periodic","text":"construct_periodic(mesh, backend, patch1::Symbol, patch2::Symbol)\n\nFunction for construction of periodic boundary conditions.\n\nInput\n\nmesh – Mesh.\nbackend  – Backend configuraton.\npatch1  – Primary periodic patch ID.\npatch2   – Neighbour periodic patch ID.\n\nOutput\n\nperiodic::Tuple - tuple containing boundary defintions for patch1 and patch2 i.e. (periodic1, periodic2). The fields of periodic1 and periodic2 are \nID – Index to access boundary information in mesh object\nvalue represents a NamedTuple with the following keyword arguments:\nindex – ID used to find boundary geometry information in the mesh object\ndistance – perpendicular distance between the patches\nface_map – vector providing indeces to faces of match patch\nismaster – flat to identify one of the patch pairs as the main patch\n\nExample\n\n- `periodic = construct_periodic(mesh, CPU(), :top, :bottom)` - Example using CPU \nbackend with periodic boundaries named `top` and `bottom`.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Discretise.@define_boundary-Tuple{Any, Any, Any}","page":"Reference","title":"XCALibre.Discretise.@define_boundary","text":"macro define_boundary(boundary, operator, definition)\n    quote\n        @inline (bc::$boundary)(\n            term::Operator{F,P,I,$operator}, cellID, zcellID, cell, face, fID, i, component, time\n            ) where {F,P,I} = $definition\n    end |> esc\nend\n\nMacro to reduce boilerplate code when defining boundary conditions (implemented as functors) and provides access to key fields needed in the implementation of boundary conditions, such as the boundary cell and face objects (more details below)\n\nInput arguments\n\nboundary specifies the boundary type being defined\noperator specifies the operator to which the condition applies e.g. Laplacian\ndefinition provides the implementation details\n\nAvailable fields\n\nterm reference to operator on which the boundary applies (gives access to the field and mesh) \ncellID ID of the corresponding boundary cell\nzcellID sparse matrix linear index for the cell\ncell gives access to boundary cell object and corresponding information\nface gives access to boundary face object and corresponding information\nfID ID of the boundary face (to index Mesh2.faces vector)\ni local index of the boundary faces within a kernel or loop\ncomponent for vectors this specifies the components being evaluated (access as component.value). For scalars component = nothing\ntime provides the current simulation time. This only applies to time dependent boundary implementation defined as functions or neural networks.\n\nExample\n\nBelow the use of this macro is illustrated for the implementation of a  Dirichlet boundary condition acting on the Laplacian using the Linear scheme:\n\n@define_boundary Dirichlet Laplacian{Linear} begin\n    J = term.flux[fID]      # extract operator flux\n    (; area, delta) = face  # extract boundary face information\n    flux = J*area/delta     # calculate the face flux\n    ap = term.sign*(-flux)  # diagonal (cell) matrix coefficient\n    ap, ap*bc.value         # return `ap` and `an`\nend\n\nWhen called, this functor will return two values ap and an, where ap is the cell contribution for approximating the boundary face value, and an is the explicit part of the face value approximation i.e. ap contributes to the diagonal of the sparse matrix (left-hand side) and an is the explicit contribution assigned to the solution vector b on the right-hand of the linear system of equations Ax = b\n\n\n\n\n\n","category":"macro"},{"location":"reference/#XCALibre.Solve.JacobiSmoother","page":"Reference","title":"XCALibre.Solve.JacobiSmoother","text":"struct JacobiSmoother{L,F,V} <: AbstractSmoother\n    loops::L\n    omega::F\n    x_temp::V\nend\n\nStructure to hold information for using the weighted Jacobi smoother. \n\nFields\n\nloops represents the number of smoothing iterations.\nomega represents the relaxation weight, 1 corresponds to no weighting. Typically a weight of 2/3 is used to filter high frequencies in the residual field.\nx_temp is a vector used internally to store intermediate solutions.\n\nConstructors\n\nJacobiSmoother(mesh::AbstractMesh)\n\nThis constructor takes a mesh object as input to create the smoother. The number of cells in the mesh is used to allocate x_temp. The number of loops and smoother factor are set to 5 and 1, respectively.\n\nJacobiSmoother(; domain, loops, omega=2/3)\n\nAlternative constructor for JacobiSmoother.\n\nkeyword arguments\n\ndomain represents a mesh object of type AbstractMesh.\nloops is the number of iterations to be used\nomega represents the weighting factor, 1 does not relax the system, 2/3 is found to work well for smoothing high frequencies in the residual field\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Solve.Runtime-Union{Tuple{}, Tuple{N}, Tuple{I}} where {I<:Integer, N<:Number}","page":"Reference","title":"XCALibre.Solve.Runtime","text":"Runtime(; \n        # keyword arguments\n\n        iterations::I, \n        write_interval::I, \n        time_step::N\n    ) where {I<:Integer,N<:Number} = begin\n    \n    # returned Runtime struct\n    Runtime{I<:Integer,F<:AbstractFloat}\n        (\n            iterations=iterations, \n            dt=time_step, \n            write_interval=write_interval\n        )\nend\n\nThis is a convenience function to set the top-level runtime information. The inputs are all keyword arguments and provide basic information to flow solvers just before running a simulation.\n\nInput arguments\n\niterations::Integer: specifies the number of iterations in a simulation run.\nwrite_interval::Integer: defines how often simulation results are written to file (on the current working directory). The interval is currently based on number of iterations. Set to -1 to run without writing results to file.\ntime_step::AbstractFloat: the time step to use in the simulation. Notice that for steady solvers this is simply a counter and it is recommended to simply use 1.\n\nExample\n\nruntime = Runtime(iterations=2000, time_step=1, write_interval=2000)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solve.Schemes","page":"Reference","title":"XCALibre.Solve.Schemes","text":"Schemes(;\n    # keyword arguments and their default values\n    time=SteadyState,\n    divergence=Linear, \n    laplacian=Linear, \n    gradient=Gauss,\n    limiter=nothing) = begin\n\n    # Returns Schemes struct used to configure discretisation\n    \n    Schemes(\n        time=time,\n        divergence=divergence,\n        laplacian=laplacian,\n        gradient=gradient,\n        limiter=limiter\n    )   \nend\n\nThe Schemes struct is used at the top-level API to help users define discretisation schemes for every field solved.\n\nInputs\n\ntime: is used to set the time schemes (default is SteadyState)\ndivergence: is used to set the divergence scheme (default is Linear) \nlaplacian: is used to set the laplacian scheme (default is Linear)\ngradient:  is used to set the gradient scheme (default is Gauss)\nlimiter: is used to specify if gradient limiters should be used, currently supported limiters include FaceBased and MFaceBased (default is nothing)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Solve.SolverSetup-Union{Tuple{}, Tuple{I}, Tuple{PT}, Tuple{S2}, Tuple{S1}} where {S1, S2, PT, I}","page":"Reference","title":"XCALibre.Solve.SolverSetup","text":"SolverSetup(; \n        # required keyword arguments \n\n        solver::S, \n        preconditioner::PT, \n        convergence, \n        relax,\n\n        # optional keyword arguments\n\n        float_type=Float64,\n        smoother=nothing,\n        limit=nothing,\n        itmax::Integer=1000, \n        atol=(eps(_get_float(region)))^0.9,\n        rtol=_get_float(region)(1e-1)\n\n    ) where {S,PT<:PreconditionerType} = begin\n\n        return SolverSetup(kwargs...)  \nend\n\nThis function is used to provide solver settings that will be used internally in XCALibre.jl. It returns a SolverSetup object with solver settings that are used internally by the flow solvers. \n\nInput arguments\n\nsolver: solver object from Krylov.jl and it could be one of Bicgstab(), Cg(), Gmres() which are re-exported in XCALibre.jl\npreconditioner: instance of preconditioner to be used e.g. Jacobi()\nconvergence sets the stopping criteria of this field\nrelax: specifies the relaxation factor to be used e.g. set to 1 for no relaxation\nsmoother: specifies smoothing method to be applied before discretisation. JacobiSmoother: is currently the only choice (defaults to nothing)\nlimit: used in some solvers to bound the solution within these limits e.g. (min, max). It defaults to nothing\nitmax: maximum number of iterations in a single solver pass (defaults to 1000) \natol: absolute tolerance for the solver (default to eps(FloatType)^0.9)\nrtol: set relative tolerance for the solver (defaults to 1e-1)\nfloat_type: specifies the floating point type to be used by the solver. It is also used to estimate the absolute tolerance for the solver (defaults to Float64)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.Compressible","page":"Reference","title":"XCALibre.ModelPhysics.Compressible","text":"Compressible <: AbstractCompressible\n\nCompressible fluid model containing fluid field parameters for compressible flows with      constant parameters - ideal gas with constant viscosity.\n\nFields\n\n'nu'   – Fluid kinematic viscosity.\n'cp'   – Fluid specific heat capacity.\ngamma – Ratio of specific heats.\nPr   – Fluid Prantl number.\n\nExamples\n\nFluid{Compressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7) - Constructur with default values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Conduction","page":"Reference","title":"XCALibre.ModelPhysics.Conduction","text":"Conduction <: AbstractEnergyModel\n\nType that represents energy conduction model for solids.\n\nFields\n\nT Temperature scalar field on cells (ScalarField).\nTf Temperature scalar field on faces (FaceScalarField).\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Fluid","page":"Reference","title":"XCALibre.ModelPhysics.Fluid","text":"Fluid <: AbstractFluid\n\nAbstract fluid model type for constructing new fluid models.\n\nFields\n\n'args' – Model arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.HelmholtzFluidConstants","page":"Reference","title":"XCALibre.ModelPhysics.HelmholtzFluidConstants","text":"Stores all fluid-specific constants required for the Helmholtz Equation of State, ancillary equations, and associated property calculations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Incompressible","page":"Reference","title":"XCALibre.ModelPhysics.Incompressible","text":"Incompressible <: AbstractIncompressible\n\nIncompressible fluid model containing fluid field parameters for incompressible flows.\n\nFields\n\n'nu'   – Fluid kinematic viscosity.\n'rho'  – Fluid density.\n\nExamples\n\nFluid{Incompressible}(nu=0.001, rho=1.0) - Constructor with default values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.KEquation","page":"Reference","title":"XCALibre.ModelPhysics.KEquation","text":"KEquation <: AbstractTurbulenceModel\n\nKEquation LES model containing all Smagorinksy field parameters.\n\nFields\n\nnut – Eddy viscosity ScalarField.\nnutf – Eddy viscosity FaceScalarField.\ncoeffs – Model coefficients.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.KOmega","page":"Reference","title":"XCALibre.ModelPhysics.KOmega","text":"KOmega <: AbstractTurbulenceModel\n\nkOmega model containing all kOmega field parameters.\n\nFields\n\nk – Turbulent kinetic energy ScalarField.\nomega – Specific dissipation rate ScalarField.\nnut – Eddy viscosity ScalarField.\nkf – Turbulent kinetic energy FaceScalarField.\nomegaf – Specific dissipation rate FaceScalarField.\nnutf – Eddy viscosity FaceScalarField.\ncoeffs – Model coefficients.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.KOmegaLKE","page":"Reference","title":"XCALibre.ModelPhysics.KOmegaLKE","text":"KOmegaLKE <: AbstractTurbulenceModel\n\nkOmega model containing all kOmega field parameters.\n\nFields\n\nk – Turbulent kinetic energy ScalarField.\nomega – Specific dissipation rate ScalarField.\nkl – ScalarField.\nnut – Eddy viscosity ScalarField.\nkf – Turbulent kinetic energy FaceScalarField.\nomegaf – Specific dissipation rate FaceScalarField.\nklf – FaceScalarField.\nnutf – Eddy viscosity FaceScalarField.\ncoeffs – Model coefficients.\nTu – Freestream turbulence intensity for model.\ny – Near-wall distance for model.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.KOmegaSST","page":"Reference","title":"XCALibre.ModelPhysics.KOmegaSST","text":"KOmega <: AbstractTurbulenceModel\n\nkOmega model containing all kOmega field parameters.\n\nFields\n\n'k' – Turbulent kinetic energy ScalarField.\n'omega' – Specific dissipation rate ScalarField.\n'nut' – Eddy viscosity ScalarField.\n'kf' – Turbulent kinetic energy FaceScalarField.\n'omegaf' – Specific dissipation rate FaceScalarField.\n'nutf' – Eddy viscosity FaceScalarField.\n'coeffs' – Model coefficients.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.LES","page":"Reference","title":"XCALibre.ModelPhysics.LES","text":"LES <: AbstractLESModel\n\nAbstract LES model type for constructing LES models.\n\nFields\n\n'args' – Model arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Laminar","page":"Reference","title":"XCALibre.ModelPhysics.Laminar","text":"Laminar <: AbstractTurbulenceModel\n\nLaminar model definition for physics API.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Momentum","page":"Reference","title":"XCALibre.ModelPhysics.Momentum","text":"struct Momentum{V,S,SS} <: AbstractMomentumModel\n    U::V \n    p::S \n    sources::SS\nend\n\nMomentum model containing key momentum fields.\n\nFields\n\n'U'        – Velocity VectorField.\n'p'        – Pressure ScalarField.\n'sources'  – Momentum model sources.\n\nExamples\n\n`Momentum(mesh::AbstractMesh)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Physics","page":"Reference","title":"XCALibre.ModelPhysics.Physics","text":"struct Physics{T,F,SO,M,Tu,E,D,BI}\n    time::T\n    fluid::F\n    solid::SO\n    momentum::M \n    turbulence::Tu \n    energy::E\n    domain::D\n    boundary_info::BI\nend\n\nXCALibre's parametric Physics type for user-level API. Also used to dispatch flow solvers.\n\nFields\n\ntime::Union{Steady, Transient}   – User-provided time model.\nfluid::AbstractFluid  – User-provided Fluid` model.\nsolid::AbstractSolid  – User-provided Solid` model.\nmomentum  – Momentum model. Currently this is auto-generated by the Physics constructor\nturbulence::AbstractTurbulenceModel  – User-provided Turbulence` model.\nenergy:AbstractEnergyModel  – User-provided Energy model.\ndomain::AbstractMesh  – User-provided Mesh. Must be adapted to target device before constructing a Physics object.\nboundary_info::boundary_info  – Mesh boundary information.  Auto-generated by the Physics constructor\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Physics-Tuple{}","page":"Reference","title":"XCALibre.ModelPhysics.Physics","text":"Physics(; time, fluid, solid, turbulence, energy, domain)::Physics{T,F,SO,M,Tu,E,D,BI}\n\nPhysics constructor part of the top-level API. It can be used to define the Physics and models relevant to a simulation. This constructor uses keyword arguments to allow users to fine-tune their simulations, whilst some fields are auto-generated behind the scenes for convenience (Momentum and boundary_info). Where:\n\ntime - specified the time model (Steady or Transient)\nfluid - specifies the type of fluid (Incompressible, etc.)\nturbulence - specified the Turbulence model\nenergy - specifies the Energy treatment\ndomain - provides the mesh to used (must be adapted to the target backend device)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.RANS","page":"Reference","title":"XCALibre.ModelPhysics.RANS","text":"RANS <: AbstractRANSModel\n\nAbstract RANS model type for consturcting RANS models.\n\nFields\n\n'args' – Model arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Smagorinsky","page":"Reference","title":"XCALibre.ModelPhysics.Smagorinsky","text":"Smagorinsky <: AbstractTurbulenceModel\n\nSmagorinsky LES model containing all Smagorinksy field parameters.\n\nFields\n\nnut – Eddy viscosity ScalarField.\nnutf – Eddy viscosity FaceScalarField.\ncoeffs – Model coefficients.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Solid","page":"Reference","title":"XCALibre.ModelPhysics.Solid","text":"Solid <: AbstractSolid\n\nAbstract solid model type for constructing new solid models.\n\nFields\n\n'args' – Model arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Steady","page":"Reference","title":"XCALibre.ModelPhysics.Steady","text":"Steady\n\nSteady model for Physics model API.\n\nExamples\n\nSteady()\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.Transient","page":"Reference","title":"XCALibre.ModelPhysics.Transient","text":"Transient\n\nTransient model for Physics model API.\n\nExamples\n\nTransient()\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.WeaklyCompressible","page":"Reference","title":"XCALibre.ModelPhysics.WeaklyCompressible","text":"WeaklyCompressible <: AbstractCompressible\n\nWeakly compressible fluid model containing fluid field parameters for weakly compressible      flows with constant parameters - ideal gas with constant viscosity.\n\nFields\n\n'nu'   – Fluid kinematic viscosity.\n'cp'   – Fluid specific heat capacity.\ngamma – Ratio of specific heats.\nPr   – Fluid Prandtl number.\n\nExamples\n\nFluid{WeaklyCompressible}(; nu=1E-5, cp=1005.0, gamma=1.4, Pr=0.7) - Constructor with \n\ndefault values.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.ModelPhysics.EOS_wrapper-Union{Tuple{F}, Tuple{HelmholtzEnergyFluid, F, F, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.EOS_wrapper","text":"Main high-level wrapper. Determines the fluid phase (liquid, vapor, two-phase, or supercritical) and computes a comprehensive set of thermodynamic properties for the given state (T, P).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.Ttoh!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F<:AbstractCompressible, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.Ttoh!","text":"Ttoh!(model::Physics{T1,F,SO,M,Tu,E,D,BI}, T::ScalarField, h::ScalarField\n) where {T1,F<:AbstractCompressible,M,Tu,E,D,BI}\n\nFunction coverts temperature ScalarField to sensible enthalpy ScalarField.\n\nInput\n\nmodel  – Physics model defined by user.\nT      – Temperature ScalarField.\nh      – Sensible enthalpy ScalarField.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.beta_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.beta_calc","text":"Computes the isobaric expansion coefficient in 1/K.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.c_p-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.c_p","text":"Computes the isobaric (constant pressure) heat capacity in J/(mol*K).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.c_v-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.c_v","text":"Computes the isochoric (constant volume) heat capacity in J/(mol*K).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.change-Tuple{Physics, Any, Any}","page":"Reference","title":"XCALibre.ModelPhysics.change","text":"change(model::Physics, property, value) => updatedModel::Physics\n\nA convenience function to change properties of an exisitng Physics model.\n\nInput arguments\n\nmodel::Physics a Physics model to modify\nproperty is a symbol specifying the property to change \nvalue is the new setting for the specified property\n\nOutput\n\nThis function return a new Physics object\n\nExample\n\nTo change a model to run a transient simulation e.g. after converging in steady state\n\nmodelTransient = change(model, :time, Transient())\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.compute_pressure-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.compute_pressure","text":"Computes pressure (in Pa) for a given temperature (K) and molar density (mol/m^3).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.cv0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.cv0_calc","text":"Computes the ideal-gas isochoric heat capacity (Cv0) in J/(mol*K) at a given temperature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.dPsat_dT-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.dPsat_dT","text":"Calculates the derivative of saturation pressure with respect to temperature (dPsat/dT) using the ancillary equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.energy!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{XCALibre.ModelPhysics.SensibleEnthalpyModel, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 6}}} where {T1, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.energy!","text":"energy::SensibleEnthalpyModel, model::Physics{T1,F,SO,M,Tu,E,D,BI}, prev, mdotf, rho, mueff, time, config\n) where {T1,F,SO,M,Tu,E,D,BI,E1}\n\nRun energy transport equations.\n\nInput\n\nenergy: Energy model.\nmodel: Physics model defined by user.\nprev: Previous energy cell values.\nmdtof: Face mass flow.\nrho: Density ScalarField.\nmueff: Effective viscosity FaceScalarField.\ntime: Simulation runtime.\nconfig: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.enthalpy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.enthalpy_calc","text":"Computes the total enthalpy (ideal + residual) in J/mol.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.entropy_calc-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.entropy_calc","text":"Computes the total entropy (ideal + residual) in J/(mol*K).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.find_saturation_properties-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.find_saturation_properties","text":"Calculates saturation properties (pressure, liquid density, vapor density) at a given temperature. Uses a secant solver to find the pressure where the liquid and vapor Gibbs free energies are equal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.find_saturation_temperature-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.find_saturation_temperature","text":"Iteratively solves for the saturation temperature (in K) for a given pressure (Pa) using the ancillary equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.gibbs_free_energy-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.gibbs_free_energy","text":"Computes the Gibbs free energy in J/mol for a given state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.h0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.h0_calc","text":"Computes the ideal-gas enthalpy (h0) in J/mol at a given temperature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.htoT!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{Physics{T1, F, SO, M, Tu, E, D, BI}, ScalarField, ScalarField}} where {T1, F<:AbstractCompressible, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.htoT!","text":"htoT!(model::Physics{T1,F,SO,M,Tu,E,D,BI}, h::ScalarField, T::ScalarField\n) where {T1,F<:AbstractCompressible,M,Tu,E,D,BI}\n\nFunction coverts sensible enthalpy ScalarField to temperature ScalarField.\n\nInput\n\nmodel  – Physics model defined by user.\nh      – Sensible enthalpy ScalarField.\nT      – Temperature ScalarField.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T1}, Tuple{SensibleEnthalpy, Physics{T1, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T1, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(energy::SensibleEnthalpy, model::Physics{T1,F,SO,M,Tu,E,D,BI}, mdotf, rho, peqn, config\n) where {T1,F,SO,M,Tu,E,D,BI})\n\nInitialisation of energy transport equations.\n\nInput\n\nenergy: Energy model.\nmodel: Physics model defined by user.\nmdtof: Face mass flow.\nrho: Density ScalarField.\npeqn: Pressure equation.\nconfig: Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\nOutput\n\nSensibleEnthalpyModel: Energy model struct containing energy equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KEquation, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(turbulence::KEquation, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n) where {T,F,SO,M,Tu,E,D,BI}\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence – turbulence model.\nmodel  – Physics model defined by user.\nmdtof  – Face mass flow.\npeqn   – Pressure equation.\nconfig – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.\n\nOutput\n\nKEquationModel(       turbulence,        Δ,        magS,        ModelState((), false)   )  – Turbulence model structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmega, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(turbulence::KOmega, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n) where {T,F,SO,M,Tu,E,D,BI}\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence – turbulence model.\nmodel  – Physics model defined by user.\nmdtof  – Face mass flow.\npeqn   – Pressure equation.\nconfig – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.\n\nOutput\n\nKOmegaModel(       turbulence,       k_eqn,        ω_eqn,       state       )  – Turbulence model structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaLKE, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(turbulence::KOmegaLKE, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n) where {T,F,SO,M,Tu,E,D,BI}\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence – turbulence model.\nmodel  – Physics model defined by user.\nmdtof  – Face mass flow.\npeqn   – Pressure equation.\nconfig – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.\n\nOutput\n\nKOmegaLKEModel(       turbulence,       k_eqn,       ω_eqn,       kl_eqn,       nueffkLS,       nueffkS,       nueffωS,       nuL,       nuts,       Ω,       γ,       fv,       normU,       Reυ,       ∇k,       ∇ω,        state   )  – Turbulence model structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{KOmegaSST, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(turbulence::KOmega, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n) where {T,F,SO,M,Tu,E,D,BI}\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence – turbulence model.\nmodel  – Physics model defined by user.\nmdtof  – Face mass flow.\npeqn   – Pressure equation.\nconfig – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.\n\nOutput\n\nKOmegaModel(k_eqn, ω_eqn)  – Turbulence model structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Laminar, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"function initialise(\n    turbulence::Laminar, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n    ) where {T,F,SO,M,Tu,E,D,BI}\nreturn LaminarModel(), config\n\nend\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence – turbulence model.\nmodel  – Physics model defined by user.\nmdtof  – Face mass flow.\npeqn   – Pressure equation.\nconfig – Configuration structure defined by user with solvers, schemes, runtime and          hardware structures set.\n\nOutput\n\nLaminarModel()  – Turbulence model structure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.initialise-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Smagorinsky, Physics{T, F, SO, M, Tu, E, D, BI}, Any, Any, Any}} where {T, F, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.initialise","text":"initialise(turbulence::Smagorinsky, model::Physics{T,F,SO,M,Tu,E,D,BI}, mdotf, peqn, config\n) where {T,F,SO,M,Tu,E,D,BI}\n\nInitialisation of turbulent transport equations.\n\nInput\n\nturbulence: turbulence model.\nmodel: Physics model defined by user.\nmdtof: Face mass flow.\npeqn: Pressure equation.\nconfig: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.\n\nOutput\n\nReturns a structure holding the fields and data needed for this model\n\nSmagorinskyModel(\n    turbulence, \n    Δ, \n    ModelState((), false)\n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.internal_energy_calc-Union{Tuple{F}, Tuple{F, F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.internal_energy_calc","text":"Computes the total internal energy (ideal + residual) in J/mol.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.k_T-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.k_T","text":"Computes the isothermal compressibility in 1/Pa (required for thermal conductivity computation).\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.params_computation-Union{Tuple{F}, Tuple{F, F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.params_computation","text":"Computes a set of key thermodynamic properties from molar density and temperature, and converts them from molar to mass-specific units.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, FaceScalarField, Any}} where {T, F<:AbstractCompressible, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.thermo_Psi!","text":"thermo_Psi!(model::Physics{T,F,SO,M,Tu,E,D,BI}, Psif::FaceScalarField) \nwhere {T,F<:AbstractCompressible,M,Tu,E,D,BI}\n\nFunction updates the value of Psi.\n\nInput\n\nmodel  – Physics model defined by user.\nPsif    – Compressibility factor FaceScalarField.\n\nAlgorithm\n\nWeakly compressible currently uses the ideal gas equation for establishing the compressibility factor where rho = p * Psi. Psi is calculated from the sensible  enthalpy, reference temperature and fluid model specified C_p and R value where  R is calculated from C_p and gamma specified in the fluid model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.thermo_Psi!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, ScalarField}} where {T, F<:AbstractCompressible, SO, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.thermo_Psi!","text":"thermo_Psi!(model::Physics{T,F,SO,M,Tu,E,D,BI}, Psi::ScalarField) \nwhere {T,F<:AbstractCompressible,M,Tu,E,D,BI}\n\nModel updates the value of Psi.\n\nInput\n\nmodel  – Physics model defined by user.\nPsi    – Compressibility factor ScalarField.\n\nAlgorithm\n\nWeakly compressible currently uses the ideal gas equation for establishing the compressibility factor where rho = p * Psi. Psi is calculated from the sensible  enthalpy, reference temperature and fluid model specified C_p and R value where  R is calculated from C_p and gamma specified in the fluid model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Turb}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaLKEModel, Physics{T, F, SO, M, Turb, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Turb<:AbstractTurbulenceModel, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(rans::KOmegaLKEModel, model::Physics{T,F,SO,M,Turb,E,D,BI}, S, prev, time, config     ) where {T,F,SO,M,Turb<:AbstractTurbulenceModel,E,D,BI}\n\nRun turbulence model transport equations.\n\nInput\n\nrans::KOmegaLKEModel – KOmega turbulence model.\nmodel  – Physics model defined by user.\nS   – Strain rate tensor.\nprev  – Previous field.\ntime   – \nconfig – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KEquationModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu<:AbstractTurbulenceModel, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(les::KEquationModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, S2, prev, time, config\n) where {T,F,SO,M,Tu<:AbstractTurbulenceModel,E,D,BI}\n\nRun turbulence model transport equations.\n\nInput\n\nles::KEquationModel – KEquation LES turbulence model.\nmodel  – Physics model defined by user.\nS   – Strain rate tensor.\nS2  – Square of the strain rate magnitude.\nprev  – Previous field.\ntime   – \nconfig – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu<:AbstractTurbulenceModel, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(rans::KOmegaModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config\n) where {T,F,SO,M,Tu<:AbstractTurbulenceModel,E,D,BI}\n\nRun turbulence model transport equations.\n\nInput\n\nrans::KOmegaModel – KOmega turbulence model.\nmodel  – Physics model defined by user.\nS   – Strain rate tensor.\nprev  – Previous field.\ntime   – \nconfig – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.LaminarModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu<:AbstractTurbulenceModel, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(rans::LaminarModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config\n) where {T,F,SO,M,Tu<:Laminar,E,D,BI}\n\nRun turbulence model transport equations.\n\nInput\n\nrans::LaminarModel – Laminar turbulence model.\nmodel  – Physics model defined by user.\nS   – Strain rate tensor.\nprev  – Previous field.\ntime   – \nconfig – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.SmagorinskyModel, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu<:AbstractTurbulenceModel, E, D, BI}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(les::SmagorinskyModel, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, S2, prev, time, config\n) where {T,F,SO,M,Tu<:AbstractTurbulenceModel,E,D,BI}\n\nRun turbulence model transport equations.\n\nInput\n\nles::SmagorinskyModel: Smagorinsky LES turbulence model.\nmodel: Physics model defined by user.\nS: Strain rate tensor.\nS2: Square of the strain rate magnitude.\nprev: Previous field.\ntime: current simulation time \nconfig: Configuration structure defined by user with solvers, schemes, runtime and hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.turbulence!-Union{Tuple{S1}, Tuple{E2}, Tuple{E1}, Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{XCALibre.ModelPhysics.KOmegaSSTModel{E1, E2, S1}, Physics{T, F, SO, M, Tu, E, D, BI}, Vararg{Any, 4}}} where {T, F, SO, M, Tu<:AbstractTurbulenceModel, E, D, BI, E1, E2, S1}","page":"Reference","title":"XCALibre.ModelPhysics.turbulence!","text":"turbulence!(rans::KOmegaModel{E1,E2,S1}, model::Physics{T,F,SO,M,Tu,E,D,BI}, S, prev, time, config\n) where {T,F,SO,M,Tu<:KOmega,E,D,BI,E1,E2,S1}\n\nRun turbulence model transport equations.\n\nInput\n\nrans::KOmegaModel{E1,E2,S1} – KOmega turbulence model.\nmodel  – Physics model defined by user.\nS   – Strain rate tensor.\nprev  – Previous field.\ntime   – \nconfig – Configuration structure defined by user with solvers, schemes, runtime and              hardware structures set.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.u0_calc-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.u0_calc","text":"Computes the ideal-gas internal energy (u0) in J/mol at a given temperature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.ModelPhysics.vapour_pressure_ancillary-Union{Tuple{F}, Tuple{F, Any, Any}} where F<:AbstractFloat","page":"Reference","title":"XCALibre.ModelPhysics.vapour_pressure_ancillary","text":"Calculates the saturation pressure (in Pa) for a given temperature using a simplified ancillary equation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Simulate.Configuration","page":"Reference","title":"XCALibre.Simulate.Configuration","text":"@kwdef struct Configuration{SC,SL,RT,HW,PP}\n    schemes::SC\n    solvers::SL\n    runtime::RT\n    hardware::HW\n    postprocess::PP = nothing\nend\n\nThe Configuration type is passed to all flow solvers and provides all the relevant information to run a simulation. \n\nInputs\n\nschemes::NamedTuple this keyword argument is used to pass distretisation scheme information to flow solvers. See Numerical setup for details.\nsolvers::NamedTuple this keyword argument is used to pass the configurations for the linear solvers for each field information to flow solvers. See Runtime and solvers for details.\nruntime::NamedTuple this keyword argument is used to pass runtime information to the flow solvers. See Runtime and solvers for details.\nhardware::NamedTuple this keyword argument is used to pass the hardware configuration and backend settings to the flow solvers. See Pre-processing for details.\n\nOptional keywords\n\npostprocess this keyword argument is used to pass any fields that need to be post-processed. See Post-processing for details.\n\nExample\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Simulate.Hardware","page":"Reference","title":"XCALibre.Simulate.Hardware","text":"hardware = Hardware(backend, workgroup)\n\nStruct used to configure the backend.\n\nInputs\n\nbackend: used to specify the backend e.g. CPU(), CUDABackend() or other backends supported by KernelAbstraction.jl\nworkgroup::Int this is an integer specifying the number of workers that cooperate in a parallel run. For GPUs this could be set to the size of the device's warp e.g. workgroup = 32. On CPUs, the default value in KernelAbstractions.jl is currently workgroup = 1024.\n\nOutput\n\nThis function returns a Hardware object with the fields backend and workgroup which are accessed by internally in XCALibre.jl to execute a given kernel in the target backend.\n\n\n\n\n\n","category":"type"},{"location":"reference/#XCALibre.Solvers.cpiso!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Solvers.cpiso!","text":"cpiso!(model, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)\n\nCompressible and transient variant of the PISO algorithm with a sensible enthalpy transport equation for the energy. \n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nUx Vector of x-velocity residuals for each iteration.\nUy Vector of y-velocity residuals for each iteration.\nUz Vector of y-velocity residuals for each iteration.\np Vector of pressure residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.csimple!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Solvers.csimple!","text":"csimple!(\n    model_in, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n)\n\nCompressible variant of the SIMPLE algorithm with a sensible enthalpy transport equation for the energy. \n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nUx Vector of x-velocity residuals for each iteration.\nUy Vector of y-velocity residuals for each iteration.\nUz Vector of y-velocity residuals for each iteration.\np Vector of pressure residuals for each iteration.\ne Vector of energy residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.laplace!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Solvers.laplace!","text":"laplace!(model_in, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)\n\nTop-level entry point for solving the Laplace (heat conduction) equation on model.domain.   Optionally runs in steady or transient mode and can call Conduction energy model for high fidelity (k and cp are recomputed at each iteration).\n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nT Vector of T residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.piso!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Solvers.piso!","text":"cpiso!(model, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)\n\nIncompressible and transient variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations. \n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nUx Vector of x-velocity residuals for each iteration.\nUy Vector of y-velocity residuals for each iteration.\nUz Vector of y-velocity residuals for each iteration.\np Vector of pressure residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Tuple{}","page":"Reference","title":"XCALibre.Solvers.run!","text":"function run!(\n    model::Physics, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    )\n\n    # here an internal function is used for solver dispatch\n    return residuals\nend\n\nThis is the top level API function to initiate a simulation. It uses the user-provided model defined as a Physics object to dispatch to the appropriate solver.\n\nDispatched flow solvers\n\nSteady incompressible (SIMPLE algorithm for coupling)\nTransient incompressible (PISO algorithm for coupling)\nSteady weakly compressible (SIMPLE algorithm for coupling)\nTransient weakly compressible (PISO algorithm for coupling)\n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux). The fields available within the returned residuals tuple depend on the solver used. For example, for an incompressible solver, a x-momentum equation residual can be retrieved accessing the Ux field i.e. residuals.Ux. Look at reference guide for each dispatch method to find out which fields are available.\n\nExample\n\nresiduals = run!(model, config) \n\n# to access the pressure residual\n\nresiduals.p \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T<:Steady, F<:Incompressible, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.Solvers.run!","text":"run!(\n    model::Physics{T,F,M,Tu,E,D,BI}, config;\n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    ) where{T<:Steady,F<:Incompressible,M,Tu,E,D,BI} = \nbegin\n    residuals = simple!(model, config, pref=pref)\n    return residuals\nend\n\nCalls the incompressible steady solver using the SIMPLE algorithm.\n\nInput\n\nmodel represents the Physics model defined by user.\nconfig Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nUx  - Vector of x-velocity residuals for each iteration.\nUy  - Vector of y-velocity residuals for each iteration.\nUz  - Vector of y-velocity residuals for each iteration.\np   - Vector of pressure residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T<:Steady, F<:WeaklyCompressible, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.Solvers.run!","text":"run!(\n    model::Physics{T,F,M,Tu,E,D,BI}, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    ) where{T<:Steady,F<:WeaklyCompressible,M,Tu,E,D,BI} = \nbegin\n    residuals = csimple!(model, config, pref=pref); #, pref=0.0)\n    return residuals\nend\n\nCalls the compressible steady solver using the SIMPLE algorithm for weakly compressible fluids.\n\nInput\n\nmodel represents the Physics model defined by user.\nconfig Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nUx  - Vector of x-velocity residuals for each iteration.\nUy  - Vector of y-velocity residuals for each iteration.\nUz  - Vector of y-velocity residuals for each iteration.\np   - Vector of pressure residuals for each iteration.\ne   - Vector of energy residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T<:Transient, F<:Incompressible, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.Solvers.run!","text":"run!(\n    model::Physics{T,F,M,Tu,E,D,BI}, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    ) where{T<:Transient,F<:Incompressible,M,Tu,E,D,BI} = \nbegin\n    residuals = piso!(model, config, pref=pref); #, pref=0.0)\n    return residuals\nend\n\nCalls the incompressible transient solver using the PISO algorithm.\n\nInput\n\nmodel represents the Physics model defined by user.\nconfig Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nUx  - Vector of x-velocity residuals for each iteration.\nUy  - Vector of y-velocity residuals for each iteration.\nUz  - Vector of y-velocity residuals for each iteration.\np   - Vector of pressure residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, M, Tu, E, D, BI}, Any}} where {T<:Transient, F<:WeaklyCompressible, M, Tu, E, D, BI}","page":"Reference","title":"XCALibre.Solvers.run!","text":"run!(\n    model::Physics{T,F,M,Tu,E,D,BI}; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    ) where{T<:Transient,F<:WeaklyCompressible,M,Tu,E,D,BI} = \nbegin\n    residuals = cpiso!(model, config)\n    return residuals\nend\n\nCalls the compressible transient solver using the PISO algorithm for weakly compressible fluids.\n\nInput\n\nmodel represents the Physics model defined by user.\nconfig Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nUx  - Vector of x-velocity residuals for each iteration.\nUy  - Vector of y-velocity residuals for each iteration.\nUz  - Vector of y-velocity residuals for each iteration.\np   - Vector of pressure residuals for each iteration.\ne   - Vector of energy residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.run!-Union{Tuple{BI}, Tuple{D}, Tuple{E}, Tuple{Tu}, Tuple{M}, Tuple{SO}, Tuple{F}, Tuple{T}, Tuple{Physics{T, F, SO, M, Tu, E, D, BI}, Any}} where {T, F, SO, M, Tu, E<:Conduction, D, BI}","page":"Reference","title":"XCALibre.Solvers.run!","text":"run!(\n    model::Physics{T,F,SO,M,Tu,E,D,BI}, config;\n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0\n    ) where{T,F,SO<:Uniform,M,Tu,E,D,BI} = \nbegin\n    residuals = laplace!(model, config, pref=pref)\n    return residuals\nend\n\nTop-level entry point for solving the Laplace (heat conduction) equation on model.domain.   Optionally runs in steady or transient mode and can call CryogenicConduction energy model for high fidelity (k and cp are recomputed at each iteration).\n\nInput\n\nmodel represents the Physics model defined by user.\nconfig Configuration structure defined by user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM() (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only.\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nT   - (Vector?) of temperature residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Solvers.simple!-Tuple{Any, Any}","page":"Reference","title":"XCALibre.Solvers.simple!","text":"simple!(model_in, config; \n    output=VTK(), pref=nothing, ncorrectors=0, inner_loops=0)\n\nIncompressible variant of the SIMPLE algorithm to solving coupled momentum and mass conservation equations.\n\nInput arguments\n\nmodel reference to a Physics model defined by the user.\nconfig Configuration structure defined by the user with solvers, schemes, runtime and hardware structures configuration details.\noutput select the format used for simulation results from VTK() or OpenFOAM (default = VTK())\npref Reference pressure value for cases that do not have a pressure defining BC. Incompressible solvers only (default = nothing)\nncorrectors number of non-orthogonality correction loops (default = 0)\ninner_loops number to inner loops used in transient solver based on PISO algorithm (default = 0)\n\nOutput\n\nThis function returns a NamedTuple for accessing the residuals (e.g. residuals.Ux) with the following entries:\n\nUx Vector of x-velocity residuals for each iteration.\nUy Vector of y-velocity residuals for each iteration.\nUz Vector of y-velocity residuals for each iteration.\np Vector of pressure residuals for each iteration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Postprocess.FieldAverage-Tuple{Any}","page":"Reference","title":"XCALibre.Postprocess.FieldAverage","text":"FieldAverage(\n#required arguments\nfield;\nname::String,\n\n#optional keyword arguments\nstart::Real,\nstop::Real,\nupdate_interval::Real)\n\nConstructor to allocate memory to store the time averaged field. Once created, should be passed to the Configuration object as an argument with keyword postprocess\n\nInput arguments\n\nfield the VectorField or ScalarField to be averaged, e.g , model.momentum.U.\nname::String the name of the field to be averaged, e.g \"U_mean\", this is used only when exporting to .vtk format\n\nOptional arguments\n\nstart::Real optional keyword which specifies the start time/iteration of the averaging window, for steady simulations, this is in iterations, for transient simulations it is in flow time.   \nstop::Real optional keyword which specifies the end iteration/time of the averaging window. Default value is the last iteration/timestep. \nupdate_interval::Real optional keyword which specifies how often the time average of the field is updated and stored (default value is 1 i.e RMS updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the write_interval in Configuration. \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Postprocess.FieldRMS-Tuple{Any}","page":"Reference","title":"XCALibre.Postprocess.FieldRMS","text":"FieldRMS(\n#required arguments\nfield;\nname::String,\n\n#optional keyword arguments\nstart::Real,\nstop::Real,\nupdate_interval::Real)\n\nConstructor to allocate memory to store the root mean square of the fluctuations of a field over the averaging window (in terms of iterations). Once created, should be passed to the Configuration object as an argument with keyword postprocess\n\nInput arguments\n\nfield the VectorField or ScalarField, e.g , model.momentum.U.\nname::String the name/label of the field to be averaged, e.g \"U_rms\", this is used only when exporting to .vtk format\n\nOptional arguments\n\nstart::Real optional keyword which specifies the start of the RMS calculation window, for steady simulations, this is in iterations, for transient simulations it is in flow time.   \nstop::Real optional keyword which specifies the end iteration/time of the RMS calculation window. Default value is the last iteration/timestep. \nupdate_interval::Real optional keyword which specifies how often the RMS of the field is updated and stored (default value is 1 i.e RMS updates every timestep/iteration). Note that the frequency of writing the post-processed fields is specified by the write_interval in Configuration. \n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Postprocess.boundary_average-Tuple{Symbol, Any, Any, Any}","page":"Reference","title":"XCALibre.Postprocess.boundary_average","text":"function boundary_average(patch::Symbol, field, config; time=0)\n    # Extract mesh object\n    mesh = field.mesh\n\n    # Determine ID (index) of the boundary patch \n    ID = boundary_index(mesh.boundaries, patch)\n    @info \"calculating average on patch: $patch at index $ID\"\n    boundary = mesh.boundaries[ID]\n    (; IDs_range) = boundary\n\n    # Create face field of same type provided by user (scalar or vector)\n    sum = nothing\n    if typeof(field) <: VectorField \n        faceField = FaceVectorField(mesh)\n        sum = zeros(_get_float(mesh), 3) # create zero vector\n    else\n        faceField = FaceScalarField(mesh)\n        sum = zero(_get_float(mesh)) # create zero\n    end\n\n    # Interpolate CFD results to boundary\n    interpolate!(faceField, field, config)\n    correct_boundaries!(faceField, field, field.BCs, time, config)\n\n    # Calculate the average\n    for fID ∈ IDs_range\n        sum += faceField[fID]\n    end\n    ave = sum/length(IDs_range)\n\n    # return average\n    return ave\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Postprocess.pressure_force-Tuple{Symbol, ScalarField, Any}","page":"Reference","title":"XCALibre.Postprocess.pressure_force","text":"pressure_force(patch::Symbol, p::ScalarField, rho)\n\nFunction to calculate the pressure force acting on a given patch/boundary.\n\nInput arguments\n\npatch::Symbol name of the boundary of interest (as a Symbol)\np::ScalarField pressure field\nrho density. Set to 1 for incompressible solvers\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Postprocess.viscous_force-Tuple{Symbol, VectorField, Vararg{Any, 4}}","page":"Reference","title":"XCALibre.Postprocess.viscous_force","text":"viscous_force(patch::Symbol, U::VectorField, rho, ν, νt)\n\nFunction to calculate the pressure force acting on a given patch/boundary.\n\nInput arguments\n\npatch::Symbol name of the boundary of interest (as a Symbol)\nU::VectorField pressure field\nrho density. Set to 1 for incompressible solvers\nν laminar viscosity of the fluid\nνt eddy viscosity from turbulence models. Pass ConstantScalar(0) for laminar flows\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Preprocess.setField_Box!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F<:AbstractFloat, V<:(AbstractVector)}","page":"Reference","title":"XCALibre.Preprocess.setField_Box!","text":"setField_Box!(; mesh, field, value::F, min_corner::V, max_corner::V) where {F <: AbstractFloat, V <: AbstractVector}\n\nSets field values equal to value argument only for cells located within a box defined by min and max corners\n\nInput arguments\n\nmesh reference to domain inside a Physics model defined by the user.\nfield field to be modified.\nvalue new values for the chosen field.\nmin_corner minimum coordinate values of the box in the format of [x, y, z].\nmax_corner maximum coordinate values of the box in the format of [x, y, z].\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Preprocess.setField_Circle2D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F<:AbstractFloat, V<:(AbstractVector)}","page":"Reference","title":"XCALibre.Preprocess.setField_Circle2D!","text":"setField_Circle2D!(mesh, field, value::F, centre::V, radius::F) where {F <: AbstractFloat, V <: AbstractVector}\n\nSets field values equal to value argument only for cells located within a 2D circle defined by its centre and radius\n\nInput arguments\n\nmesh reference to domain inside a Physics model defined by the user.\nfield field to be modified.\nvalue new values for the chosen field.\ncentre coordinate of centre of the circle in the format of [x, y].\nradius length of the radius of the circle.\n\n\n\n\n\n","category":"method"},{"location":"reference/#XCALibre.Preprocess.setField_Sphere3D!-Union{Tuple{}, Tuple{V}, Tuple{F}} where {F<:AbstractFloat, V<:(AbstractVector)}","page":"Reference","title":"XCALibre.Preprocess.setField_Sphere3D!","text":"setField_Sphere3D!(mesh, field, value::F, centre::V, radius::F) where {F <: AbstractFloat, V <: AbstractVector}\n\nSets field values equal to value argument only for cells located within a 3D sphere defined by its centre and radius\n\nInput arguments\n\nmesh reference to domain inside a Physics model defined by the user.\nfield field to be modified.\nvalue new values for the chosen field.\ncentre coordinate of centre of the sphere in the format of [x, y, z].\nradius length of the radius of the sphere.\n\n\n\n\n\n","category":"method"},{"location":"theory_guide/introduction/#Introduction","page":"Theory Guide","title":"Introduction","text":"","category":"section"},{"location":"theory_guide/introduction/","page":"Theory Guide","title":"Theory Guide","text":"","category":"page"},{"location":"user_guide/1_preprocessing/#Pre-processing","page":"Pre-processing","title":"Pre-processing","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"First steps required to set up a simulation","category":"page"},{"location":"user_guide/1_preprocessing/#Mesh-generation-and-requirements","page":"Pre-processing","title":"Mesh generation and requirements","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"As with all CFD solvers, defining a suitable mesh is one of the most important steps. XCALibre.jl does not provides mesh generation utilities (yet). Thus, the user will have to generate the grids using external mesh generation tools. However, XCALibre.jl does provide a number of mesh conversion tools to allow user to import their grids. ","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"XCALibre.jl is an unstructured Finite Volume Method (FVM) library, therefore, we are able to support grids of arbitrary polyhedral cells. In XCALibre.jl a cell-centred FVM approach has been implemented, which is popular since it allows the representation of complex geometries and it is used by most commercial and many open source CFD solvers.","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"units: Units\nXCALIbre.jl does not enforce units strictly. Units are implicitly provided by the mesh. You can use the scale keyword when importing a mesh to control the units used e.g. if the mesh file was created in millimetres, set scale=0.001 to work in metres. Thus, it is important to ensure that consistent units are used through all configuration entries. It is highly recommended that SI units are used. ","category":"page"},{"location":"user_guide/1_preprocessing/#Mesh-conversion","page":"Pre-processing","title":"Mesh conversion","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"XCALibre.jl at present supports .unv mesh formats (which can be generated using SALOME) for simulations in 2D and 3D domains. XCALibre.jl also supports the OpenFOAM mesh format for simulations in 3D only (for now). ","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"note: Note\nCurrently, XCALibre.jl only supports loading mesh files stored in ASCII format. Please ensure that when saving grid files they are not saved in binary format. Most mesh generation programmes offer the option to export in ASCII (text-based) formats.","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"The following functions are provided for importing mesh files:","category":"page"},{"location":"user_guide/1_preprocessing/#XCALibre.UNV2.UNV2D_mesh-user_guide-1_preprocessing","page":"Pre-processing","title":"XCALibre.UNV2.UNV2D_mesh","text":"UNV2D_mesh(meshFile; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 2D UNV mesh file into XCALibre.jl\n\nInput\n\nmeshFile – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"function"},{"location":"user_guide/1_preprocessing/#XCALibre.UNV3.UNV3D_mesh-user_guide-1_preprocessing","page":"Pre-processing","title":"XCALibre.UNV3.UNV3D_mesh","text":"UNV3D_mesh(unv_mesh; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 3D UNV mesh file into XCALibre.jl. Note that a limitation of the .unv mesh format is that it only supports the following 3D cells:\n\nTetahedrals\nPrisms\nHexahedrals\n\nInput\n\nunv_mesh – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"function"},{"location":"user_guide/1_preprocessing/#XCALibre.FoamMesh.FOAM3D_mesh-user_guide-1_preprocessing","page":"Pre-processing","title":"XCALibre.FoamMesh.FOAM3D_mesh","text":"FOAM3D_mesh(mesh_file; scale=1, integer_type=Int64, float_type=Float64)\n\nRead and convert 3D OpenFOAM mesh file into XCALibre.jl. Note that, at present, it is not recommended to run 2D cases using meshes imported using this function.\n\nInput\n\nmesh_file – path to mesh file.\n\nOptional arguments\n\nscale – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling\ninteger_type - select interger type to use in the mesh (Int32 may be useful on GPU runs) \nfloat_type - select interger type to use in the mesh (Float32 may be useful on GPU runs) \n\n\n\n\n\n","category":"function"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"These conversion functions will read mesh information and generate a mesh object (Mesh2 or Mesh3 depending on whether the mesh is 2D or 3D, respectively) with the following properties:","category":"page"},{"location":"user_guide/1_preprocessing/#XCALibre.Mesh.Mesh3-user_guide-1_preprocessing","page":"Pre-processing","title":"XCALibre.Mesh.Mesh3","text":"struct Mesh3{VC, VI, VF<:AbstractArray{<:Face3D}, VB, VN, SV3, UR} <: AbstractMesh\n    cells::VC           # vector of cells\n    cell_nodes::VI      # vector of indices to access cell nodes\n    cell_faces::VI      # vector of indices to access cell faces\n    cell_neighbours::VI # vector of indices to access cell neighbours\n    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )\n    faces::VF           # vector of faces\n    face_nodes::VI      # vector of indices to access face nodes\n    boundaries::VB      # vector of boundaries\n    nodes::VN           # vector of nodes\n    node_cells::VI      # vector of indices to access node cells\n    get_float::SV3      # store mesh float type\n    get_int::UR         # store mesh integer type\n    boundary_cellsID::VI # vector of indices of boundary cell IDs\nend\n\n\n\n\n\n","category":"type"},{"location":"user_guide/1_preprocessing/#Mesh-limitations-and-requirements","page":"Pre-processing","title":"Mesh limitations and requirements","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"In this section we summarise the key limitations of the mesh loaders presented above, and we also highlight specific requirements. ","category":"page"},{"location":"user_guide/1_preprocessing/#UNV-mesh-files","page":"Pre-processing","title":"UNV mesh files","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Only ASCII files are supported\nFor 2D simulations the mesh must be contained in the X-Y plane only\nIn 3D only hex, tet and prism elements are supported","category":"page"},{"location":"user_guide/1_preprocessing/#OpenFOAM-mesh-files","page":"Pre-processing","title":"OpenFOAM mesh files","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Only ASCII files are supported\nBoundary groups are not supported (must be deleted manually or the conversion may fail)\nBoundary information is not preserved (walls, symmetry, etc)\n2D setups are not currently supported (but will be)","category":"page"},{"location":"user_guide/1_preprocessing/#Backend-selection","page":"Pre-processing","title":"Backend selection","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"In XCALibre.jl the mesh object is very important, as it will not only provide geometry information about the simulation/s, but it is also used to automatically dispatch methods to run on the appropriate backend. Therefore, users must first select the backend they wish to use for the simulations, and then \"adapt\" the mesh to use the correct backend. ","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"XCALIbre.jl aims to work with all the backends supported by KernelAbstractions.jl. However, since internally XCALibre.jl uses sparse arrays to reduce its memory footprint, some GPU backends are not currently supported since this functionality is not yet available. Thus, currently only a subset of backends are supported:","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"CPU (multithreaded and tested)\nNVidia GPUs (tested)\nAMD GPUs (not tested - feedback welcome)","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Selecting a given backend is straight-forward. The examples below show how to assign a backend (CPU or GPU) to the symbol backend and converting the mesh object to run a simulation on the corresponding backend. The converted mesh is assigned to the symbol mesh_dev for clarity.","category":"page"},{"location":"user_guide/1_preprocessing/#CPU-backend","page":"Pre-processing","title":"CPU backend","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Selecting the CPU backend is straight-forward. See the example below. Notice that CPU() is a backend type provided by KernelAbstractions.jl which we re-export for convenience.","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"CPU Example ","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh\nbackend = CPU()\nmesh_dev = mesh # dummy reference to emphasise the mesh in on our chosen dev (or backend)","category":"page"},{"location":"user_guide/1_preprocessing/#GPU-backends","page":"Pre-processing","title":"GPU backends","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"To execute the code on GPUS, the process is also quite simple, but does require a few additional steps.","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Install the corresponding Julia library that supports your hardware. For NVidia GPUs, the CUDA.jl package is required. For AMD GPUs, the AMDGPU.jl package is needed.\nMove the mesh object to the backend device using the adapt method, which for convenience we re-export from Adapt.jl","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Example for Nvidia GPU","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh\nbackend = CUDABackend()\nmesh_dev = adapt(backend, mesh) # make mesh object backend compatible and move to GPU","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"Example for AMD GPU","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh\nbackend = ROCBackend()\nmesh_dev = adapt(backend, mesh) # make mesh object backend compatible and move to GPU","category":"page"},{"location":"user_guide/1_preprocessing/#Hardware-configuration","page":"Pre-processing","title":"Hardware configuration","text":"","category":"section"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"","category":"page"},{"location":"user_guide/1_preprocessing/","page":"Pre-processing","title":"Pre-processing","text":"In order to configure the backend the Hardware function can be used. ","category":"page"},{"location":"user_guide/1_preprocessing/#XCALibre.Simulate.Hardware-user_guide-1_preprocessing","page":"Pre-processing","title":"XCALibre.Simulate.Hardware","text":"hardware = Hardware(backend, workgroup)\n\nStruct used to configure the backend.\n\nInputs\n\nbackend: used to specify the backend e.g. CPU(), CUDABackend() or other backends supported by KernelAbstraction.jl\nworkgroup::Int this is an integer specifying the number of workers that cooperate in a parallel run. For GPUs this could be set to the size of the device's warp e.g. workgroup = 32. On CPUs, the default value in KernelAbstractions.jl is currently workgroup = 1024.\n\nOutput\n\nThis function returns a Hardware object with the fields backend and workgroup which are accessed by internally in XCALibre.jl to execute a given kernel in the target backend.\n\n\n\n\n\n","category":"type"},{"location":"release_notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The format used for this changelog is based on Keep a Changelog, and this project adheres to Semantic Versioning. Notice that until the package reaches version v1.0.0 minor releases are likely to be breaking. Starting from version v0.3.1 breaking changes will be recorded here. ","category":"page"},{"location":"release_notes/#Version-[v0.5.2](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.5.2)-2025-XX-XX","page":"Release notes","title":"Version v0.5.2 - 2025-XX-XX","text":"","category":"section"},{"location":"release_notes/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Initial support for mixed precision (UNV meshes only) #67\nNew solver for simulating conduction in solids #65\nNew LES turbulent kinetic energy one equation model (KEquation) #71\nSurface tension model for fluids #72\nHigh fidelity viscosity models for H2 and N2 #72\nHigh fidelity thermal conductivity models for H2 and N2 #72\nSetFields utility that allows to set a field to desired value within a box / circle / sphere #73\nHelmholtz Energy equation of state and supporting framework for it for H2 and N2 #75\nTime-average and RMS of Vector and Scalar fields #78\nAdded RotatingWall velocity boundary condition #81\nAdded KOmegaSST turbulence model #82","category":"page"},{"location":"release_notes/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The UNV3D_mesh reader has been updated to ensure that the ordering of face nodes is determined in a more robust manner. This resolves some issues when loading a UNV mesh that is later used to store simulation results in the OpenFOAM format #64\nIn the construction of a Physics object, the boundary_map function returned a boundary_info struct which was incorrectly using an abstract type Integer. This resulted in a failure to convert a Physics object to the cpu and back to the gpu #67\nFixed calculation of interpolation weights for 2D UNV grids #68\nAdded method for boundary interpolation when using LUST and DirichletFunction#68\nFixed boundary_interpolation for DirichletFunction when a function is passed #79","category":"page"},{"location":"release_notes/#Changed","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The constructors for ScalarField and FaceScalarField now include a store_mesh keyword argument to request a reference of the mesh to be stored (default) or not (setting store_mesh=false). This can be used to not include references to the mesh for each field in VectorFields and TensorFields. This has improved compile times and decreased simulation times (particularly on the GPU - perhaps due to freeing registers used to carry unnecessary type information) #69\nInternally, the calculation of interpolation weights and other geometric properties are calculated using the same function (defined in the Mesh module) #69\nThe default discretisation for laplacian terms uses the over-relaxed formulation by default. This will have no effect on orthogonal grids, but tends to be more robust in complex geometries at the expense of accuracy, which can be recovered by adding additional orthogonal correction loops (using the key word argument ncorrectors in the run! function) #73\nCleaned code for all solvers and improved stability of incompressible solver by removing the update of the mass flow based on the velocity field from the previous iteration. The mass flow is now corrected directly from the latest pressure solution #76","category":"page"},{"location":"release_notes/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.5.1](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.5.1)-2025-07-03","page":"Release notes","title":"Version v0.5.1 - 2025-07-03","text":"","category":"section"},{"location":"release_notes/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New Empty boundary condition allowing 2D simulations with OpenFOAM 2D-compatible grids#63\nTests for the Smagorinsky LES model have been included #63","category":"page"},{"location":"release_notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No fixes included","category":"page"},{"location":"release_notes/#Changed-2","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Transient simulation results for VTK and VTU files use the format time_<iteration> #63","category":"page"},{"location":"release_notes/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-2","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-2","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.5.0](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.5.0)-2025-06-28","page":"Release notes","title":"Version v0.5.0 - 2025-06-28","text":"","category":"section"},{"location":"release_notes/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New boundary conditions Extrapolated and Zerogradient have been added. Both assign a zero gradient boundary condition, however, their implementation differs. Extrapolated assigns the zero gradient condition semi-implicitly (using the cell centre unknown and the cell centre value from the previous iteration). Zerogradient assigns the gradient in the boundary faces explicitly #61\nThe workgroup size for the CPU backend can now be automatically chosen when workgroup=AutoTune(). This uses a simple ceiling division internally where the number of elements in the kernel are divided by the number of available threads. This results in a small 10% performance gain #61","category":"page"},{"location":"release_notes/#Fixed-3","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed the implementation for the calculation of the wall distance to work on GPUs #49\nThe new approach for handling user-provided boundary conditions now allows extracting the wall velocity specified by the user for the Wall boundary condition #61","category":"page"},{"location":"release_notes/#Changed-3","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"In the calculation of wall function properties the user-provided wall velocity is now used, instead of hard-coded to no-slip #49\nThe functions set_production!, set_cell_value! and correct_nut_wall!, in RANS_functions.jl have been updated, removing conditional branch used in the generated calling them. Now these functions use multiple dispatch to allow specialising the wall function framework to ease the development of new wall functions #57\nNew NeumannFunction has been created, mirroring the DirichletFunction, providing a Neumann boundary condition defined with a user-provided struct (a generic framework accepting a function to set the gradient at the boundary is not yet available) #57\nupdate_user_boundary function, extension has been reverted, overwriting the changes made to expose the ModelEquation type to it in #55\nUser-provided boundary conditions are no longer stored within fields, instead a NamedTuple is constructed using the function assign, which is passed to solvers using the Configuration struct. \nConfiguration setting provided by the user at the top-level API are now stored in predefined structs, instead of using NamedTuples, this change should put less pressure on the compiler #61\nInternally, kernel launches have been updated to use a static NDrange. This resulted in a 20% speed improvement on GPU backends (only NVidia GPUs tested) #61","category":"page"},{"location":"release_notes/#Breaking-3","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The definition of Krylov solvers in the previous API used types exported directly from Krylov.jl. Now solvers are defined using instances of types defined in XCALibre.jl. As an example, previously the CG solver was defined using the type CgSolver now this solver is defined using the instance Cg() where the suffix \"Solver\" has been dropped. This applies to all previously available solver choices #60\nThe Green-Gauss method for calculating the gradient is now Gauss which is more descriptive than the previous name Orthogonal\nThe internals for handling user-provided boundary conditions have been updated in preparation for extending the code for handling multiple regions. Thus, the syntax for assigning boundary conditions has changed. The most noticeable change is the removal of the the @assign! macro, replaced by the function assign. See the documentation for details #61\nThe set_solver, set_hardware and set_runtime top-level functions have been replaced with SolverSetup, Hardware and Runtime structures. This allowed storing user-provided setup information in structs instead of NamedTuples to reduce the burden on the compiler #61\nThe implementation of the FixedTemperature boundary condition has been simplified, resulting in a breaking change. The definition of the boundary condition now requires users to provide an Enthalphy model. This interface should make it easier to extend the current implementation to new forms of the energy equation #61","category":"page"},{"location":"release_notes/#Deprecated-3","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-3","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The functions set_solver, set_runtime, set_hardware and the macro @assign! have been removed/replaced #61","category":"page"},{"location":"release_notes/#Version-[v0.4.2](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.4.2)-2025-04-02","page":"Release notes","title":"Version v0.4.2 - 2025-04-02","text":"","category":"section"},{"location":"release_notes/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"A very simple 2D block mesh generator has been added (not ready for general use as it needs to be documented)#41\nImplementation of Wall boundary conditions specialised for ScalarField #45\nSimulation results can now be written to VTK and OpenFOAM formats. The format can be selected using the output keyword argument in the run! function. The formats available are VTK() and OpenFOAM() #47","category":"page"},{"location":"release_notes/#Fixed-4","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed the implementation for the calculation of the wall distance #45","category":"page"},{"location":"release_notes/#Changed-4","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"In preparation for hybrid RANS/LES models, the object Turbulence is now passed to the TurbulenceModel object to allow for a more general call of turbulence!. This changes the implementation of turbulence! for all models slightly #46\nImproved stability on meshes with warped faces by changing how face normals are calculated. XCALibre now uses an area-weighted face normal calculation based on the decomposition of faces into triangles #47\nRemoved VTK module and moved functionality to a new IOFormats module #47\nInternally the function model2vtk has been replaced with save_output within all solvers. The specialisation for writing ModelPhysics models to file has also changed to save_output. The arguements pass to this function have also changed, the name of the file is not passed to the function, instead, the current runtime variable time is required #47\nThe Momentum object, part of the ModelPhysics object, now includes the FaceScalarField and FaveVectorField in addition to existing fields in preparation for non-uniform boundary definition when using the OpenFOAM output format #47","category":"page"},{"location":"release_notes/#Breaking-4","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-4","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-4","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.4.1](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.4.1)-2025-03-06","page":"Release notes","title":"Version v0.4.1 - 2025-03-06","text":"","category":"section"},{"location":"release_notes/#Added-5","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No new functionality has been added","category":"page"},{"location":"release_notes/#Fixed-5","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Remove fragile precompile statements of the form var\"#*#*\" causing errors in Julia v1.12 #40","category":"page"},{"location":"release_notes/#Changed-5","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"In preparation for implementation of hybrid models e.g. DES, the signature of the turbulence! function has been updated to use the AbstractTurbulenceModel #39\nNew semi-implicit implementation for periodic boundary conditions (implicit treatment of laplacian terms)#40","category":"page"},{"location":"release_notes/#Breaking-5","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-5","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-5","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.4.0](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.4.0)-2025-02-17","page":"Release notes","title":"Version v0.4.0 - 2025-02-17","text":"","category":"section"},{"location":"release_notes/#Added-6","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Implementation of Symmetry boundary condition for ScalarField types #30\nNew macro to help define boundary conditions that will dispatch to Scalar or VectorField types #30\nAdded eltype method for both Scalar and VectorField types to simplify the development of new kernels where type information is needed #30\nNew gradient limiters FaceBased and MFaceBased for limiting gradients based on cell faces, where MFaceBased is a multidimensional version, and it is generally recommended over FaceBased #30\nSupport for INTEL hardware #32","category":"page"},{"location":"release_notes/#Fixed-6","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Calling JacobiSmoother now works on the GPU #30\nImplemented SparseXCSR as wrapper for SparseMatrixCSR on the CPU to resolve display/print errors #30\nThe convergence criteria for solvers is used consistently to stop/control simulation runtime #36\nConsistent display of residuals on screen during simulations #36\nFixed calculation of wall distance and apply_boundary_conditions! arguments for LKE model #36","category":"page"},{"location":"release_notes/#Changed-6","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The calculation of gradients has been improved by merging computations into a single kernel, improving performance of gradient kernels by around 10-30%, most noticable for vector gradients #30\nImproved calculation of non-orthogonal calculation (more tests are still needed), although tests have proven to be stable #30\nImproved documentation/readme on supported GPU backends/hardware and make users aware of potential F32 limitation on some hardware","category":"page"},{"location":"release_notes/#Breaking-6","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The top level API for all solvers no longer takes the keyword argument limit_gradient for activating gradient limiter. New gradient limiters have been added and can be selected/configured when assigning numerical schemes with the Schemes function #30","category":"page"},{"location":"release_notes/#Deprecated-6","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-6","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.3.3](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.3.3)-2024-12-24","page":"Release notes","title":"Version v0.3.3 - 2024-12-24","text":"","category":"section"},{"location":"release_notes/#Added-7","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added experimental support for NVIDIA ILU0 and IC0 preconditioners #23\nAdded JacobiSmoother that can be used with all linear solvers (improving initial guess) #23\nNew function activate_multithread is available to set up matrix-vector multiplication in parallel on the CPU\nInitial benchmark added in the documentation","category":"page"},{"location":"release_notes/#Fixed-7","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No fixes","category":"page"},{"location":"release_notes/#Changed-7","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Internally the sparse matrix format has been changed to CSR. This has improved performance by 2x-4x (case dependent)\nMultithreaded sparse matrix vector multiplication is now functional #23\nPrecompilation errors on Julia v1.11 addressed by bringing code from ThreadedSparseCSR.jl #24\nUpdate compat entry for Atomix.jl to v1.0,0 #24\nDILU preconditioner is now implemented to work with sparse matrices in CSR format and uses a hybrid approach (running on CPU) to allow working when using GPU backends (further work needed) #26\nThe implementation of RANS models and wall functions has been improved for consistency (resulting in some computational gains). The calculation of yPlusLam is only done once when constructing the wall function objects. The calculation of the velocity gradient is now only done within the turbulence model main function (turbulence!) #28","category":"page"},{"location":"release_notes/#Breaking-7","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-7","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-7","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The ILU0 and LDL preconditioners has been temporarily removed #23","category":"page"},{"location":"release_notes/#Version-[v0.3.2](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.3.2)-2024-11-08","page":"Release notes","title":"Version v0.3.2 - 2024-11-08","text":"","category":"section"},{"location":"release_notes/#Added-8","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Added support for CI testing, Dependabot, and CompatHelper","category":"page"},{"location":"release_notes/#Fixed-8","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Fixed tests for mesh conversion and standardised tolerances for test checks of incompressible solvers #16","category":"page"},{"location":"release_notes/#Changed-8","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No changes","category":"page"},{"location":"release_notes/#Breaking-8","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-8","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-8","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.3.1](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.3.1)-2024-10-18","page":"Release notes","title":"Version v0.3.1 - 2024-10-18","text":"","category":"section"},{"location":"release_notes/#Added-9","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Vastly improved documentation with new examples provided #12\nChangelog added to record changes more clearly. Record kept in Release notes","category":"page"},{"location":"release_notes/#Fixed-9","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"The calculation of gradients can be limited for stability. This functionality can be activated by passing the key work argument limit_gradient to the run! function. The implementation has been improved for robustness #12\nRemoved face information being printed when Mesh objects are created to stop printing a ERROR: Scalar indexing is disallowed message #13","category":"page"},{"location":"release_notes/#Changed-9","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Master branch protected and requires PRs to push changes","category":"page"},{"location":"release_notes/#Breaking-9","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No breaking changes","category":"page"},{"location":"release_notes/#Deprecated-9","page":"Release notes","title":"Deprecated","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functions deprecated","category":"page"},{"location":"release_notes/#Removed-9","page":"Release notes","title":"Removed","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"No functionality has been removed","category":"page"},{"location":"release_notes/#Version-[v0.3.0](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.3.0)-2024-09-21","page":"Release notes","title":"Version v0.3.0 - 2024-09-21","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New name - XCALibre.jl - which is now registered in the General Julia registry\nCan do 3D and GPU accelerated simulations\nCan read .unv and OpenFOAM mesh files (3D)\nCan do incompressible and compressible simulations\nRANS and LES models available\nUser-provided functions or neural networks for boundary conditions\nReasonably complete \"user\" documentation now provided\nMade repository public (in v0.2 the work was kept in a private repository and could only do 2D simulations)\nTidy up mesh type definitions by @mberto79 in #5\nAdapt code base to work with new mesh format by @mberto79 in #6\nMesh boundary struct changes PR by @TomMazin in #7\nMesh boundary struct changes PR fix by @TomMazin in #8","category":"page"},{"location":"release_notes/#Version-[v0.2.0](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.2.0)-2023-01-23","page":"Release notes","title":"Version v0.2.0 - 2023-01-23","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"New mesh format and type implemented that are GPU friendly.\nNo functionality changes","category":"page"},{"location":"release_notes/#Version-[v0.1.0](https://github.com/github.com/mberto79/XCALibre.jl/releases/tag/v0.1.0)-2023-01-23","page":"Release notes","title":"Version v0.1.0 - 2023-01-23","text":"","category":"section"},{"location":"release_notes/#Initial-release","page":"Release notes","title":"Initial release","text":"","category":"section"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"2D implementation of classic incompressible solvers for laminar and turbulent flows:","category":"page"},{"location":"release_notes/","page":"Release notes","title":"Release notes","text":"Framework for equation definition\nSIMPLE nad PISO algorithms\nRead UNV meshes in 2D\nCapability for RANS models\nVarious discretisation schemes available\nPlanned extension to 3D and GPU acceleration!","category":"page"},{"location":"examples/06_2d-laplace-solver/#Validation:-Laplace-Solver-in-2D-Solid-Medium","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/#Introduction","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Introduction","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"This tutorial introduces laplace solver that can operate in either steady-state or transient mode, and supports both constant material properties across the domain (Uniform) and spatially varying properties (NonUniform).","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"The example simulation below consist of a simple 2D square domain with two Dirichlet walls and two Neumann 0 flux walls. It is expected to produce a diagonal line of constant value when solving laplace/heat equation.","category":"page"},{"location":"examples/06_2d-laplace-solver/#Mesh","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Mesh","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"The mesh used in this tutorial is a structured 2D grid (the mesh files laplace_2d_mesh.unv or finer_mesh_laplace.unv can be found in the examples directory). The mesh represents a rectangular region with four boundaries:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":":left_wall\n:right_wall\n:bottom_wall\n:upper_wall","category":"page"},{"location":"examples/06_2d-laplace-solver/#Boundary-Conditions","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Boundary Conditions","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"Boundary name Field Boundary condition\n:left_wall T Dirichlet (0.0 K)\n:right_wall T Zero-gradient\n:bottom_wall T Dirichlet (1.0 K)\n:upper_wall T Zero-gradient","category":"page"},{"location":"examples/06_2d-laplace-solver/#Simulation-Setup-File","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Simulation Setup File","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"using XCALibre\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"laplace_2d_mesh.unv\"\nmesh_file = joinpath(grids_dir, grid)\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\nbackend = CPU(); workgroup = 1024; activate_multithread(backend)\nhardware = Hardware(backend=backend, workgroup=workgroup)\nmesh_dev = adapt(backend, mesh)\n\nmodel = Physics(\n    time = Steady(),\n    solid = Solid{Uniform}(k=10.0),\n    energy = Energy{Conduction}(),\n    domain = mesh_dev\n)\n\nleft_wall_temp = 0.0\nbottom_wall_temp = 1.0\n\nBCs = assign(\n    region = mesh_dev,\n    (\n        T = [     \n            Dirichlet(:left_wall, left_wall_temp),\n            Zerogradient(:right_wall),\n            Dirichlet(:bottom_wall, bottom_wall_temp),\n            Zerogradient(:upper_wall)\n        ],\n    )\n)\n\nsolvers = (\n    T = SolverSetup(\n        solver         = Cg(),\n        preconditioner = Jacobi(),\n        convergence    = 1e-8,\n        relax          = 0.8,\n        rtol           = 1e-4,\n        atol           = 1e-5\n    )\n)\n\nschemes = (\n    T = Schemes(laplacian = Linear)\n)\n\nruntime = Runtime(\n    iterations=10,\n    write_interval=10,\n    time_step=1\n)\n\nconfig = Configuration(\n    solvers=solvers,\n    schemes=schemes,\n    runtime=runtime,\n    hardware=hardware,\n    boundaries=BCs\n)\n\nGC.gc(true)\n\nresiduals = run!(model, config)\n","category":"page"},{"location":"examples/06_2d-laplace-solver/#Results","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Results","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"The temperature field shows diagonal line of constant temperature of 0.5 K, as expected: (Image: Uniform Case Result)","category":"page"},{"location":"examples/06_2d-laplace-solver/#Material-Properties","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Material Properties","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"If time term is set to be transient, the solver expects not only conductivity k, but also density ρ and specific heat c_p values to be passed. Example:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"Property Value Units\nk (conductivity) 54.0 W/m·K\nρ (density) 7850.0 kg/m³\nc_p (specific heat) 480.0 J/kg·K","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"solid = Solid{Uniform}(k=54.0, rho=7850.0, cp=480.0)","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"For higher fidelity simulations, NonUniform regime is recommended. It requires density and predefined material to be passed:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"solid = Solid{NonUniform}(material=Aluminium(), rho=2700.0)","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"This will ensure that the solver computes k and cp for each cell as a function of temperature.   The general form of the equation for both coefficients is:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"log(k) = a + blog(T) + c log(T)^2 + d log(T)^3 + e log(T)^4 + f log(T)^5 + g log(T)^6 + h log(T)^7 + i log(T)^8","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"where a, b, c, d, e, f, g, h, and i are the fitted coefficients, and T is the temperature of a cell.","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"Currently, 3 material models are pre-defined: Steel(), Aluminium(), and Copper(). The coefficients for those materials were taken from Cryogenic Material Properties Database by Marquardt (2002), and work well for temperatures between 4 and 300 Kelvin. A custom material can also be defined:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"# Define your custom coefficient vectors for k and cp:\nk_coeffs = MaterialCoefficients(\n    c1=-1.4087, c2=1.3982, c3=0.2543, c4=-0.6260, c5=0.2334,\n    c6=0.4256, c7=-0.4658, c8=0.1650, c9=-0.0199\n)\ncp_coeffs = MaterialCoefficients(\n    c1=22.0061, c2=-127.5528, c3=303.6470, c4=-381.0098, c5=274.0328,\n    c6=-112.9212, c7=24.7593, c8=-2.239153, c9=0.0\n)\n\n# Pass them instead of `material`:\nsolid = Solid{NonUniform}(k=k_coeffs, cp=cp_coeffs, rho=7850.0),","category":"page"},{"location":"examples/06_2d-laplace-solver/#NonUniform-Results","page":"Validation: Laplace Solver in 2D Solid Medium","title":"NonUniform Results","text":"","category":"section"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"The following settings were changed for this NonUniform configuration:","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"grid = \"finer_mesh_laplace.unv\"\n\nmodel = Physics(\n    time = Transient(),\n    solid = Solid{NonUniform}(material=Aluminium(), rho=2700.0),\n    energy = Energy{Conduction}(),\n    domain = mesh_dev\n    )\n\nleft_wall_temp = 10.0\nbottom_wall_temp = 20.0","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"(Image: NonUniform Case Result)","category":"page"},{"location":"examples/06_2d-laplace-solver/","page":"Validation: Laplace Solver in 2D Solid Medium","title":"Validation: Laplace Solver in 2D Solid Medium","text":"The difference compared to Uniform solution with constant properties can be clearly seen. Temperature distribution in cryogenic range is more complex and becomes increasingly non-linear the lower you go. In fact, setting boundary conditions to 0 and 1 Kelvin as in previous case would result in divergence, which is a more realistic result considering that 0 K boundary would violate the third law of thermodynamics.","category":"page"},{"location":"#XCALibre.jl","page":"Home","title":"XCALibre.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XPU CFD Algorithms and libraries","category":"page"},{"location":"#What-is-XCALibre.jl?","page":"Home","title":"What is XCALibre.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"XCALibre.jl (pronounced as the mythical sword Excalibur) is a general purpose Computational Fluid Dynamics (CFD) library for 2D and 3D simulations on structured/unstructured grids using the finite volume method. XCALibre.jl has been designed to act as a platform for developing, testing and using XPU CFD Algorithms and Libraries to give researchers in both academia and industry alike a tool that can be used to test out ideas easily within a framework that offers acceptable performance. To this end, XCALibre.jl has been implemented to offer both CPU multi-threaded capabilities or GPU acceleration using the same codebase (thanks to the unified programming framework provided by KernelAbstractions.jl). XCALibre.jl also offers a friendly API for those users who are interested in running CFD simulations with the existing solvers and models built into XCALibre.jl. ","category":"page"},{"location":"#Why-XCALibre.jl?","page":"Home","title":"Why XCALibre.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"For CFD researchers whose research involves developing new numerical methods, turbulence models, or novel CFD methodologies, the development process can be taxing when using commercial packages and their imagination might be constrained by having to adhere to either limited access to internal code functionality or exhausted as they reformulate their ideas to fit within any interfaces provided by the code. There are excellent open source CFD packages where access to functionality or internals is available, however, they are either written in static languages such as C/C++ or dynamic languages such as Python. In static languages, the resulting code is likely highly performant but implementation can be slow and often has a high learning curve (especially if the developer/researcher has no prior knowledge of the language). On the other hand, dynamic languages such as Python can offer a nice development experience at the cost of low runtime or reduced performance. The development of XCALibre.jl was motivated when we discovered the Julia programming language, which promises an interactive and enjoyable implementation experience whilst being able to generate performant code. Thanks to the tools available in the Julia ecosystems (see Main dependencies) it is also possible to generate CPU and GPU code using Julia. As an added bonus, XCALibre.jl can also link readily with the entire Julia ecosystem, including machine learning frameworks such as Flux.jl, Lux.jl, Knet.jl, etc. Thanks to a user-friendly API, ultimately, we hope that XCALibre.jl can be useful to anyone who has an interest in CFD. Enjoy and give us feedback.","category":"page"},{"location":"#Main-features","page":"Home","title":"Main features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Multiple-backends","page":"Home","title":"Multiple backends","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XCALibre.jl embraces parallelism out-of-the-box on all the compute backends supported by KernelAbstractions.jl. That is,","category":"page"},{"location":"","page":"Home","title":"Home","text":"GPU acceleration on Nvidia, AMD and Intel hardware (Apple hardware is not supported yet)\nMulti-threaded runs on CPUs","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nGPU functionality has only been tested on Nvidia hardware due to availability. However, AMD and INTEL GPUs should also work correctly. Please open an issue if this is not the case so we can investigate. Apple hardware is currently not supported since sparse matrices have not yet been implemented in Metal.jl. Notice that some hardware may only support Float32 operations, in such cases, the mesh should be loaded using the keyword argument float_type=Float32 (please refer to the Pre-processing section in the user guide). ","category":"page"},{"location":"#Mesh-formats","page":"Home","title":"Mesh formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XCALibre.jl uses its own mesh format to allow the geometry and boundary information to be stored in a format that is suitable for both CPU and GPU calculations. XCALibre.jl does not yet provide mesh generation tools. Therefore, some mesh conversion tools for the following mesh formats are provided:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenFOAM meshes for 3D simulations (ascii only)\nUNV meshes for 2D simulations (ascii only)\nUNV meshes for 3D simulations (ascii only)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nAlthough the mesh conversion tools for the OpenFOAM format can import grids designed for 2D simulations, it is not possible to use OpenFOAM grids for 2D cases (at present, support for 2D OpenFOAM grids is in progress). Instead, use a 2D grid generated in the .unv format. Also for 2D grids some requirements must be met when defining the geometry (see Mesh generation and requirements)","category":"page"},{"location":"#Solvers","page":"Home","title":"Solvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XCALibre.jl ships with fluid solvers for steady and transient simulations, based on the SIMPLE and PISO algorithms. Currently, the following flow solvers are provided:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Steady incompressible flows\nSteady weakly compressible flows\nTransient incompressible flows\nTransient weakly compressible flows","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nA solver for highly compressible flows (shock capturing) is currently in testing and will be available in the next major release. Currently the compressible solvers use a sensible energy approach for the energy equation.","category":"page"},{"location":"#Turbulence-and-energy-models","page":"Home","title":"Turbulence and energy models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The list of turbulence models available is expected to expand. The following turbulence models are already available in XCALibre.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reynolds-Averaged Navier-Stokes (RANS)\nk-omega - available in low-Reynolds (wall-resolving) and in high-Reynolds (wall functions) mode\nk-omega LKE - transitional model using the Laminar Kinetic Energy concept to model transition onset\nLarge Eddy Simulation (LES with implicit filtering)\nSmagorinsky - classic eddy-viscosity sub-grid scale Smagorinsky model","category":"page"},{"location":"#Boundary-conditions","page":"Home","title":"Boundary conditions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"User defined functions\nNeural network defined BCs","category":"page"},{"location":"#Numerical-schemes","page":"Home","title":"Numerical schemes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linear - second order schemes for gradients, laplacian and divergence terms\nUpwind - first order upwind-biased scheme for divergence terms\nLUST (divergence) - mixed order upwind-biased scheme for divergence terms\nMidpoint - skew-corrected scheme for gradient calculations\nSteadyState - dummy scheme used to dispatch solvers for operation in steady mode\nEuler - first order semi-implicit time scheme","category":"page"},{"location":"#Simple-API-for-transport-equations","page":"Home","title":"Simple API for transport equations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Code example","category":"page"},{"location":"","page":"Home","title":"Home","text":"U_eqn = (\n          Time{schemes.U.time}(U)\n        + Divergence{schemes.U.divergence}(mdotf, U) \n        - Laplacian{schemes.U.laplacian}(nueff, U) \n        == \n        -Source(∇p.result)\n\n      ) → VectorEquation(mesh)","category":"page"},{"location":"#Planned-development","page":"Home","title":"Planned development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Capabilities,-solvers,-algorithms,-models,-etc.","page":"Home","title":"Capabilities, solvers, algorithms, models, etc.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solver for highly compressible flows (including shockwaves)\nImplement multithreaded sparse-matrix multiply for better multithreaded performance (done in v0.3.3)\nConjugate heat transfer\nk-epsilon turbulence model\nImplement parallel versions of more efficient preconditioners","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pass boundary conditions as a separate object. The current approach results in some internal methods/objects not being fully compatible with GPU kernels, and results is some performance degradation (due to unnecessary data transfer between GPU and host device when boundary condition information is needed/applied). A separation of boundary conditions from field data (scalar and vector fields primarily) would address both of these issues.\nThere are no immediate plans for changing the user API\nFine-tuning of the public API expected based on of user feedback","category":"page"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Overhaul of field data. Currently, both vectors and tensors are built on the primitive scalar field object. Whilst this was convenient during the early development stage, the package has reached a level of maturity that makes this approach hard to maintain, adding unneeded complexity when working with tensors. We plan to define separate internals (how tensors are defined and stored in memory). It is anticipated that this will ease the implementation of models working with tensors, give some performance gains and allow all fields to participate in Julia's broadcasting framework.","category":"page"},{"location":"#Main-dependencies","page":"Home","title":"Main dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"XCALibre.jl is possible (and relies) on the functionality provided by other packages in the Julia ecosystem. For a full list of direct dependencies please refer to the Project.toml file included with this repository. We are thankful to the teams that have helped develop and maintain every single of our dependencies. Major functionally is provided by the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"KernelAbstractions.jl - provides a unified parallel programming framework for CPUs and GPUs\nKrylov.jl - provide solvers for linear systems at the heart of XCALibre.jl\nLinearOperators.jl - wrappers for matrices and linear operators\nAtomix.jl - enable atomix operations to ensure race conditions are avoided in parallel kernels\nCUDA.jl, AMD.jl, Metal.jl and OneAPI.jl - not direct dependencies but packages enable GPU usage in Julia","category":"page"},{"location":"#Related-projects","page":"Home","title":"Related projects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other wonderful fluid simulation packages available in the Julia ecosystem (please let us know if we missed any):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oceananigans.jl \nWaterlilly.jl \nTrixi.jl","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Advanced:-2D-Aerofoil-inflow-optimisation","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Introduction","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Introduction","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"Here, a simple optimisation is performed on a 2D NACA0012 aerofoil case. The optimal angle of attack for maximum lift-to-drag ratio is found using BayesianOptimization.jl. This example serves to illustrate both how XCALibre.jl can easily integrate with the Julia ecosystem, and the ease with which post-processing functions can be written.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Optimisation-Setup","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Optimisation Setup","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"For those interested in running this example, the optimisation can be replicated by following these steps.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Install-and-load-modules","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Install and load modules","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"To be able to run this example the following modules need to be installed. This can be done by entering into package mode (using \"]\" in the REPL) and typing the following:","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"add Plots, Distributions, LinearAlgebra, GaussianProcesses, BayesianOptimization","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"This will download and install the required packages. Note that \"CUDA\" must also be added for GPU acceleration. Once installed, the packages can be loaded as follows:","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"using Pkg; # hide\ninstalled = \"Flux\" ∈ keys(Pkg.project().dependencies) # hide\ninstalled && Pkg.rm(\"Flux\", io=devnull) #hide\nPkg.add(\"BayesianOptimization\", io=devnull) # hide\n\nusing XCALibre, BayesianOptimization, Plots\nusing LinearAlgebra, GaussianProcesses, Distributions\n# using CUDA # uncomment to run on GPU\n\"done\"\nnothing # hide","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Define-post-processing-functions","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Define post processing functions","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"In order to calculate the lift-to-drag ratio, the pressure and viscous forces over the aerofoil must be calculated and summed. The lift and drag components can then be calculated (noting the rotated inflow vector to allow for different aerofoil angles of attack with the same mesh). A function returning the coefficients of lift and drag (not specifically needed for this example) is also presented for convenience.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"# Lift to drag ratio calculation\nlift_to_drag(patch::Symbol, model, ρ, nu, α) = begin\n    Fp = pressure_force(patch, model.momentum.p, ρ)\n    Fv = viscous_force(patch, model.momentum.U, ρ, nu, model.turbulence.nut)\n    Ft = Fp + Fv\n    Ft = [cos(-α*π/180) -sin(-α*π/180) 0; sin(-α*π/180) cos(-α*π/180) 0; 0 0 1]*Ft # Rotation matrix to account for rotated inflow\n    aero_eff = Ft[2]/Ft[1]\n    print(\"Aerofoil L/D: \",round(aero_eff,sigdigits = 4))\n    return aero_eff\nend \n\n# Aerodynamic coefficient calculation\naero_coeffs(patch::Symbol, chord, velocity, model, ρ, nu, α) = begin\n    Fp = pressure_force(patch, model.momentum.p, ρ)\n    Fv = viscous_force(patch, model.momentum.U, ρ, nu, model.turbulence.nut)\n    Ft = Fp + Fv\n    Ft = [cos(-α*π/180) -sin(-α*π/180) 0; sin(-α*π/180) cos(-α*π/180) 0; 0 0 1]*Ft # Rotation matrix to account for rotated inflow\n    C_l = 2Ft[2]/(ρ*(velocity[1]^2)*chord*0.001)\n    C_d = 2Ft[1]/(ρ*(velocity[1]^2)*chord*0.001)\n    print(\"Lift Coefficient: \",round(C_l,sigdigits = 4))\n    print(\"\\nDrag Coefficient: \",round(C_d,sigdigits = 4))\n    return C_l,C_d\nend ","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Import-2D-aerofoil-mesh","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Import 2D aerofoil mesh","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"Next, the aerofoil mesh .unv file must be imported. It must also be adapted to work with the GPU, if desired.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"grids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"NACAMesh.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\nmesh_dev = mesh # running on CPU \n# mesh_dev = adapt(CUDABackend(), mesh) # uncomment to run on GPU","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Setup-the-CFD-simulation-as-a-function-to-be-optimised","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Setup the CFD simulation as a function to be optimised","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"The BayesianOptimization.jl package can optimise a Julia function that is passed to it. To interface with XCALibre.jl, the entire CFD simulation setup must simply be wrapped within a function, which can then be passed to the optimiser. The function must take the variable to be changed (angle of attack, in this case) as its input, and must return the desired output (lift-to-drag ratio). Therefore, the post-processing step to calculate lift-to-drag ratio is also wrapped in the same function.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"function foil_optim(α::Vector{Float64})\n    println(\"\\nSelected α value: $(α[1])\")\n\n    # Parameters\n    chord = 250.0\n    Re = 500000\n    nu, ρ = 1.48e-5, 1.225\n    Umag = (Re*nu)/(chord*0.001) # Calculate velocity magnitude for given Reynolds number\n    velocity = [Umag*cos(α[1]*π/180), Umag*sin(α[1]*π/180), 0.0] # Velocity calculation\n    νR = 10\n    Tu = 0.025\n    k_inlet = 3/2*(Tu*norm(velocity))^2\n    ω_inlet = k_inlet/(νR*nu)\n\n    # Boundary Conditions\n    noSlip = [0.0, 0.0, 0.0]\n\n    model = Physics(\n        time = Steady(),\n        fluid = Fluid{Incompressible}(nu = nu),\n        turbulence = RANS{KOmega}(),\n        energy = Energy{Isothermal}(),\n        domain = mesh_dev\n        )\n\n    BCs = assign(\n        region=mesh_dev,\n        (\n            U = [\n                XCALibre.Dirichlet(:inlet, velocity),\n                XCALibre.Dirichlet(:bottom, velocity),\n                Extrapolated(:outlet, 0.0),\n                Extrapolated(:top, 0.0),\n                Wall(:foil, noSlip)\n            ],\n            p = [\n                Extrapolated(:inlet, 0.0),\n                Extrapolated(:bottom, 0.0),\n                XCALibre.Dirichlet(:outlet, 0.0),\n                XCALibre.Dirichlet(:top, 0.0),\n                Extrapolated(:foil, 0.0)\n            ],\n            k = [\n                XCALibre.Dirichlet(:inlet, k_inlet),\n                Extrapolated(:outlet, 0.0),\n                Extrapolated(:top, 0.0),\n                Extrapolated(:bottom, 0.0),\n                XCALibre.Dirichlet(:foil, 1e-15)\n            ],\n            omega = [\n                XCALibre.Dirichlet(:inlet, ω_inlet),\n                Extrapolated(:outlet, 0.0),\n                Extrapolated(:top, 0.0),\n                Extrapolated(:bottom, 0.0),\n                OmegaWallFunction(:foil)\n            ],\n            nut = [\n                Extrapolated(:inlet, 0.0),\n                Extrapolated(:outlet, 0.0),\n                Extrapolated(:top, 0.0),\n                Extrapolated(:bottom, 0.0), \n                XCALibre.Dirichlet(:foil, 0.0)\n            ]\n        )\n    )\n\n    schemes = (\n        U = Schemes(divergence=Upwind, gradient=Midpoint),\n        p = Schemes(divergence=Upwind),\n        k = Schemes(divergence=Upwind, gradient=Midpoint),\n        omega = Schemes(divergence=Upwind, gradient=Midpoint)\n    )\n\n    solvers = (\n        U = SolverSetup(\n            region = mesh_dev,\n            solver = Bicgstab(), # Bicgstab(), Gmres()\n            preconditioner = Jacobi(), # Jacobi\n            convergence = 1e-7,\n            relax = 0.6,\n            rtol = 1e-1,\n        ),\n        p = SolverSetup(\n            region = mesh_dev,\n            solver = Gmres(), # change to Bicgstab() for GPU runs\n            preconditioner = Jacobi(), # change to Jacobi() for GPU runs\n            convergence = 1e-7,\n            relax = 0.2,\n            rtol = 1e-2,\n        ),\n        k = SolverSetup(\n            region = mesh_dev,\n            solver = Bicgstab(),\n            preconditioner = Jacobi(),\n            convergence = 1e-7,\n            relax = 0.6,\n            rtol = 1e-1,\n        ),\n        omega = SolverSetup(\n            region = mesh_dev,\n            solver      = Bicgstab(),\n            preconditioner = Jacobi(), \n            convergence = 1e-7,\n            relax       = 0.6,\n            rtol = 1e-1,\n        )\n    )\n\n    runtime = Runtime(iterations=500, write_interval=500, time_step=1)\n    runtime = Runtime(iterations=20, write_interval=-1, time_step=1) # hide\n\n    hardware = Hardware(backend=CPU(), workgroup=1024)\n    # hardware = Hardware(backend=CUDABackend(), workgroup=32) # uncomment to run on GPU\n\n    config = Configuration(solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\n    GC.gc()\n\n    initialise!(model.momentum.U, velocity)\n    initialise!(model.momentum.p, 0.0)\n    initialise!(model.turbulence.k, k_inlet)\n    initialise!(model.turbulence.omega, ω_inlet)\n    initialise!(model.turbulence.nut, k_inlet/ω_inlet)\n\n    residuals = run!(model, config)\n\n    # Residuals Graph\n    let\n        iterations = 1:length(residuals.Ux)\n        plot(; xlims=(0,runtime.iterations), ylims=(1e-10,0))\n        plot!(iterations, residuals.Ux, yscale=:log10, label=\"Ux\")\n        plot!(iterations, residuals.Uy, yscale=:log10, label=\"Uy\")\n        plot!(iterations, residuals.p, yscale=:log10, label=\"p\")\n    end\n\n    aero_eff = lift_to_drag(:foil, model, ρ, nu, α[1]) # Calculates lift-to-drag ratio\n\n    # relocate XCALibre.jl vtk output files\n    aero_eff_out = round(aero_eff,digits=3)\n    α_out = round(α[1],digits=3)\n    vtk_files = filter(x->endswith(x,\".vtk\"), readdir())\n    for file ∈ vtk_files\n        dest = \"vtk_results/LD_Ratio = $(aero_eff_out), Alpha = $(α_out).vtk\"\n        mv(file, dest, force=true)\n    end\n\n    return aero_eff\nend","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"Note that this code saves a single .vtk file of the last CFD iteration each time the optimiser samples the function. This .vtk file is then automatically renamed with that sample's results, and sorted into a /vtk_results subfolder (which must be created before the optimisation is run).","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Configure-and-run-the-Bayesian-optimisation","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Configure and run the Bayesian optimisation","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"Finally, the Bayesian optimiser must be configured before the optimisation can be performed. This example follows the BayesianOptimization.jl default configuration for the Gaussian process surrogate model, limiting input dimensions to 1 (the angle of attack). The surrogate model is then set to be optimised every 10 iterations. The inputs are limited to between 0 and 15 degrees. The problem is configured as a maximisation problem, with an initial sample period of 10 iterations and 50 maximum allowed iterations. The final line of the following code block is then run to perform the optimisation.","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"# Bayesian Optimisation (using BayesianOptimization.jl)\nisdir(\"vtk_results\") || mkdir(\"vtk_results\")\n\n# Initialises the Gaussian process surrogate model\nmodel = ElasticGPE(1, #1 input dimension (α)\n                   mean = MeanConst(0.0),\n                   kernel = SEArd([0.0], 5.0),\n                   capacity = 3000)\nset_priors!(model.mean, [Normal(1, 2)])\n\nmodeloptimizer = MAPGPOptimizer(every = 10, maxeval = 40) # Optimises the Gaussian process every 10 iterations\n\n# Optimisation Case Setup\nopt = BOpt(foil_optim, # Function to be optimised - encloses the CFD case\n            model, # Gaussian process surrogate model defined above\n            UpperConfidenceBound(),\n            modeloptimizer, # Model optimiser defined above\n            [0.0], [15.0], # Minimum and maximum α constraints       \n            repetitions = 1, # No repititions as CFD data is not noisy\n            maxiterations = 50, # Maximum iterations\n            sense = Max, # Maximisation problem\n            initializer_iterations = 10, # No. of initial random samples\n            verbosity = Progress)\n\nopt = BOpt(foil_optim, # hide\n            model, # hide\n            UpperConfidenceBound(),\n            modeloptimizer, # hide\n            [0.0], [15.0], # hide      \n            repetitions = 1, # hide\n            maxiterations = 5, # hide\n            sense = Max, # hide\n            initializer_iterations = 2, # hide\n            verbosity = Progress) # hide\n\nresult = boptimize!(opt) # Runs the optimisation procedure\n\nusing Pkg; Pkg.rm(\"BayesianOptimization\", io=devnull) # hide\n\nnothing # hide\n\"done\"","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/#Example-Optimisation-Results","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Example Optimisation Results","text":"","category":"section"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"using Plots\n\nalpha_in = [2.8125, 10.3125, 14.0625, 6.5625, 4.6875, 12.1875, 8.4375, 0.9375, 1.40625, 8.90625, 6.779625965220729, 6.77968472431049, 6.7797314426495054, 6.77976068608606, 6.779786764662929, 6.7798083933298825, 6.779824452011973, 6.779839305833187, 6.779851985125758, 6.779864532650939, 6.7799660687298875, 6.7799701746255465, 6.779970295228141, 6.77997431759257, 6.779983415563036, 6.7799837395243685, 6.779983935151504, 6.779987648165338, 6.779990776177305, 6.779984858208577, 6.779969245384916, 6.779974853301299, 6.77996639334403, 6.779975137863877, 6.77996588653741, 6.7799787767924995, 6.779980463194295, 6.779982645115559, 6.779984123782711, 6.779985756585738, 6.780065815803057, 6.780066942543943, 6.780081725020423, 6.780063344501922, 6.780112623430458, 6.780065445290062, 6.780112028947505, 6.780088979322628, 6.78008982572309, 6.780090816324224, 6.852129317102274, 15.0, 6.755034985210623, 6.761466922699926, 6.766457867346942, 6.7701094609872365, 6.772562674953314, 6.774340290374087, 6.775562986686579, 6.776273742423618, 13.474012044415156, 12.361866906130413, 8.195985025525076, 5.334843671454779, 4.308592858166856, 2.6894603132241217, 2.858340694577276, 3.9867902638528654, 9.814658247047763, 1.932233467710785, 14.719640732627886, 9.682863385862596, 10.90134524899545, 12.877578634990728, 4.343344626917736]\n\naeroeff_out = [12.28662476568946, 15.996066573412422, 12.086660285887401, 18.095030718054726, 16.684759975625713, 14.101557983835567, 17.514651235093766, 4.6215245234556415, 6.787202918357864, 17.203294519181156, 18.1170435016882, 18.116757960309155, 18.117178450363166, 18.116980351431625, 18.116775418289507, 18.117332562156935, 18.116999501527403, 18.116946514089875, 18.11690912331511, 18.117181857003985, 18.117047847973517, 18.117081881041535, 18.117198176532845, 18.1172141350244, 18.117151423600156, 18.11701162747253, 18.117196229004325, 18.117302063623146, 18.117642349199684, 18.117122449593182, 18.11704990315254, 18.11745842192904, 18.1171359979369, 18.117344466780477, 18.117133217540022, 18.117057989337816, 18.116782216736464, 18.11721596351545, 18.117119958415003, 18.117170377304056, 18.117352502260307, 18.117163143088185, 18.117300338277143, 18.117066185177936, 18.11722389239519, 18.11713622798166, 18.116993107467152, 18.116991271960444, 18.117083277331048, 18.11714354615574, 18.097362115270933, 11.114298598972901, 18.108943497471795, 18.108780485320025, 18.108790519425263, 18.109037299059956, 18.108833040375593, 18.108767451351685, 18.1084445814309, 18.10857933786505, 12.690741887963036, 9.845212599830074, 17.636745115382112, 17.47574058124154, 16.058798546800677, 11.877430534208012, 12.4272778301407, 15.41709457750829, 16.462303743958294, 9.053215612096695, 11.382140258128832, 16.578166324395593, 15.519321514686421, 13.356080135399708, 16.116845772757824]\n\niteration = [1:25;]\n\nscatter(\n    alpha_in[1:25],aeroeff_out[1:25],xlabel=\"Angle of Attack, α [°]\", ylabel=\"Aerodynamic Efficiency, Cl/Cd [-]\",label=\"\",\n    legend=true,\n    # marker=(:cross,4),\n    zcolor=iteration,\n    c=:linear_ternary_red_0_50_c52_n256,\n    colorbar_title=\"Optimiser Iteration\",\n    xlims=[0,15.15], ylims=[0,20], clim=(0,25),\n    frame_style=:box\n    )\n\nmax_exp_alpha = ([6.479310344827586,6.479310344827586],[0,19])\n\nplot!(max_exp_alpha,line=(:dash,:black),label=\"\")\n\nplot!(\n    sort(alpha_in[1:50]), aeroeff_out[sortperm(alpha_in[1:50])],\n    label=\"\", line=(:solid,:black,0.5)\n    )\nannotate!(8.25, 2.5, Plots.text(\"Experimental\\noptimum α\", 10))\nsavefig(\"optimisation_iterations_vs_experiment.svg\"); nothing # hide\nnothing\n\nfig1 = scatter(\n    iteration[1:15],aeroeff_out[1:15],xlabel=\"Optimiser Iteration [-]\", ylabel=\"Aerodynamic Efficiency, Cl/Cd [-]\",label=\"\",\n    ylim = (0,20),\n    legend=true,# marker=(:cross,4,:black)\n    ) #L/D against iteration number graph\n\nfig2 = scatter(iteration[1:15],alpha_in[1:15],xlabel=\"Optimiser Iteration [-]\", ylabel=\"Angle of Attack, α [°]\",label=\"\",\nylim = (0,15),\nlegend=true, #marker=(:cross,4,:black)\n) #α against iteration number graph\n\n\n# exp_alpha = [0.1724137931034484, 2.068965517241379, 4.482758620689655, 6.479310344827586, 8.441064638783269, 10.344827586206897, 11.206896551724139, 12.551020408163264, 14.13793103448276]\n# exp_aeroeff = [8.872377622377625, 36.656207598371786, 52.94361173623201, 53.41160498793243, 53.10395622895623, 50.95347249317206, 48.78298051001016, 4.906565656565657, 3.354085331846068]\n# fig2 = scatter(exp_alpha,exp_aeroeff,xlabel=\"Angle of Attack, α [°]\", ylabel=\"Aerodynamic Efficiency, Cl/Cd [-]\",title=\"Experimental Data (NACA0012, Re=500,000)\",\n# legend=false,marker=(:circle,4,:black)) #Experimental data\n\nplot(fig1, fig2, frame_style=:box)\n\nsavefig(\"optimisation_vs_iteration.svg\"); nothing # hide\nnothing\n\n# output\n","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"(Image: )","category":"page"},{"location":"examples/05_2d-aerofoil-inflow-optimisation/","page":"Advanced: 2D Aerofoil inflow optimisation","title":"Advanced: 2D Aerofoil inflow optimisation","text":"(Image: )","category":"page"},{"location":"examples/02_2d-incompressible-transient-cylinder/#Verification:-2D-Unsteady-incompressible-cylinder","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"","category":"section"},{"location":"examples/02_2d-incompressible-transient-cylinder/#Introduction","page":"Verification: 2D Unsteady incompressible cylinder","title":"Introduction","text":"","category":"section"},{"location":"examples/02_2d-incompressible-transient-cylinder/","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"","category":"page"},{"location":"examples/02_2d-incompressible-transient-cylinder/","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"To verify the correct implementation of the laminar flow solver, a simulation of a transient, laminar and incompressible cylinder was carried out and compared with OpenFOAM. The results show that the solver in XCALibre.jl generates similar results compared to the laminar solver in OpenFOAM. Simulation set up, grid and OpenFOAM case will all be made available here.","category":"page"},{"location":"examples/02_2d-incompressible-transient-cylinder/#Results","page":"Verification: 2D Unsteady incompressible cylinder","title":"Results","text":"","category":"section"},{"location":"examples/02_2d-incompressible-transient-cylinder/","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"(Image: vorticity comparison with OpenFOAM)","category":"page"},{"location":"examples/02_2d-incompressible-transient-cylinder/#Simulation-setup","page":"Verification: 2D Unsteady incompressible cylinder","title":"Simulation setup","text":"","category":"section"},{"location":"examples/02_2d-incompressible-transient-cylinder/","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"For those interested in running this case, this simulation can be replicated as follows.","category":"page"},{"location":"examples/02_2d-incompressible-transient-cylinder/","page":"Verification: 2D Unsteady incompressible cylinder","title":"Verification: 2D Unsteady incompressible cylinder","text":"\nusing XCALibre\n# using CUDA # uncomment to run on GPU\n\ngrids_dir = pkgdir(XCALibre, \"examples/0_GRIDS\")\ngrid = \"cylinder_d10mm_5mm.unv\"\nmesh_file = joinpath(grids_dir, grid)\n\nmesh = UNV2D_mesh(mesh_file, scale=0.001)\n\nmesh_dev = mesh\n# mesh_dev = adapt(CUDABackend(), mesh) # uncomment to run on GPU\n\n# Inlet conditions\nvelocity = [0.5, 0.0, 0.0]\nnoSlip = [0.0, 0.0, 0.0]\nnu = 1e-3\nRe = (0.2*velocity[1])/nu\n\nmodel = Physics(\n    time = Transient(),\n    fluid = Fluid{Incompressible}(nu = nu),\n    turbulence = RANS{Laminar}(),\n    energy = Energy{Isothermal}(),\n    domain = mesh_dev\n    )\n\nBCs = assign(\n    region=mesh_dev,\n    (\n        U = [\n                Dirichlet(:inlet, velocity),\n                Extrapolated(:outlet),\n                Wall(:cylinder, noSlip),\n                Extrapolated(:bottom),\n                Extrapolated(:top)\n        ],\n        p = [\n                Extrapolated(:inlet),\n                Dirichlet(:outlet, 0.0),\n                Wall(:cylinder),\n                Extrapolated(:bottom),\n                Extrapolated(:top)\n        ]\n    )\n)\n\nsolvers = (\n    U = SolverSetup(\n        solver      = Bicgstab(), # Bicgstab(), Gmres()\n        preconditioner = Jacobi(),\n        convergence = 1e-7,\n        relax       = 1.0,\n        rtol = 1e-4,\n        atol = 1e-5\n    ),\n    p = SolverSetup(\n        solver      = Cg(), # Bicgstab(), Gmres()\n        preconditioner = Jacobi(), #NormDiagonal(),\n        convergence = 1e-7,\n        relax       = 0.8,\n        rtol = 1e-4,\n        atol = 1e-5\n    )\n)\n\nschemes = (\n    U = Schemes(time=Euler, divergence=LUST, gradient=Gauss),\n    p = Schemes(time=Euler, gradient=Gauss)\n)\n\n\nruntime = Runtime(iterations=1000, write_interval=50, time_step=0.005) \nruntime = Runtime(iterations=1, write_interval=-1, time_step=0.005) # hide\n\n\nhardware = Hardware(backend=CPU(), workgroup=1024)\n# hardware = Hardware(backend=CUDABackend(), workgroup=32) # uncomment to run on GPU\n\nconfig = Configuration(\n    solvers=solvers, schemes=schemes, runtime=runtime, hardware=hardware, boundaries=BCs)\n\nGC.gc(true)\n\ninitialise!(model.momentum.U, velocity)\ninitialise!(model.momentum.p, 0.0)\n\nresiduals = run!(model, config)","category":"page"}]
}
