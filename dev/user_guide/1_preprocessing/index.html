<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pre-processing · XCALibre.jl</title><meta name="title" content="Pre-processing · XCALibre.jl"/><meta property="og:title" content="Pre-processing · XCALibre.jl"/><meta property="twitter:title" content="Pre-processing · XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../../examples/04_2d-inflow-using-Flux/">Advanced: 2D inflow using <code>Flux.jl</code></a></li><li><a class="tocitem" href="../../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../0_introduction_and_workflow/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Pre-processing</a><ul class="internal"><li><a class="tocitem" href="#Mesh-generation-and-requirements"><span>Mesh generation and requirements</span></a></li><li><a class="tocitem" href="#Backend-selection"><span>Backend selection</span></a></li><li><a class="tocitem" href="#Hardware-configuration"><span>Hardware configuration</span></a></li></ul></li><li><a class="tocitem" href="../2_physics_and_models/">Physics and models</a></li><li><a class="tocitem" href="../3_numerical_setup/">Numerical setup</a></li><li><a class="tocitem" href="../4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../../contributor_guide/">Contributor Guide</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Pre-processing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Pre-processing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/user_guide/1_preprocessing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Pre-processing"><a class="docs-heading-anchor" href="#Pre-processing">Pre-processing</a><a id="Pre-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-processing" title="Permalink"></a></h1><p><em>First steps required to set up a simulation</em></p><h2 id="Mesh-generation-and-requirements"><a class="docs-heading-anchor" href="#Mesh-generation-and-requirements">Mesh generation and requirements</a><a id="Mesh-generation-and-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-generation-and-requirements" title="Permalink"></a></h2><hr/><p>As with all CFD solvers, defining a suitable mesh is one of the most important steps. XCALibre.jl does not provides mesh generation utilities (yet). Thus, the user will have to generate the grids using external mesh generation tools. However, XCALibre.jl does provide a number of mesh conversion tools to allow user to import their grids. </p><p>XCALibre.jl is an unstructured Finite Volume Method (FVM) library, therefore, we are able to support grids of arbitrary polyhedral cells. In XCALibre.jl a cell-centred FVM approach has been implemented, which is popular since it allows the representation of complex geometries and it is used by most commercial and many open source CFD solvers.</p><div class="admonition is-category-units"><header class="admonition-header">Units</header><div class="admonition-body"><p>XCALIbre.jl does not enforce units strictly. Units are implicitly provided by the mesh. You can use the <code>scale</code> keyword when importing a mesh to control the units used e.g. if the mesh file was created in millimetres, set <code>scale=0.001</code> to work in metres. Thus, it is important to ensure that consistent units are used through all configuration entries. It is highly recommended that SI units are used. </p></div></div><h3 id="Mesh-conversion"><a class="docs-heading-anchor" href="#Mesh-conversion">Mesh conversion</a><a id="Mesh-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-conversion" title="Permalink"></a></h3><p>XCALibre.jl at present supports <code>.unv</code> mesh formats (which can be generated using <a href="https://www.salome-platform.org/">SALOME</a>) for simulations in 2D and 3D domains. XCALibre.jl also supports the <a href="https://openfoam.org/">OpenFOAM</a> mesh format for simulations in 3D only (for now). </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, XCALibre.jl only supports loading mesh files stored in ASCII format. Please ensure that when saving grid files they are not saved in binary format. Most mesh generation programmes offer the option to export in ASCII (text-based) formats.</p></div></div><p>The following functions are provided for importing mesh files:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.UNV2.UNV2D_mesh-user_guide-1_preprocessing" href="#XCALibre.UNV2.UNV2D_mesh-user_guide-1_preprocessing"><code>XCALibre.UNV2.UNV2D_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UNV2D_mesh(meshFile; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 2D UNV mesh file into XCALibre.jl</p><p><strong>Input</strong></p><ul><li><code>meshFile</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/52db86596bc3101f119e0a7f754153a0afcaec9d/src/UNV2/UNV2_3_builder.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.UNV3.UNV3D_mesh-user_guide-1_preprocessing" href="#XCALibre.UNV3.UNV3D_mesh-user_guide-1_preprocessing"><code>XCALibre.UNV3.UNV3D_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UNV3D_mesh(unv_mesh; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D UNV mesh file into XCALibre.jl. Note that a limitation of the .unv mesh format is that it only supports the following 3D cells:</p><ul><li>Tetahedrals</li><li>Prisms</li><li>Hexahedrals</li></ul><p><strong>Input</strong></p><ul><li><code>unv_mesh</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/52db86596bc3101f119e0a7f754153a0afcaec9d/src/UNV3/UNV3_2_builder.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.FoamMesh.FOAM3D_mesh-user_guide-1_preprocessing" href="#XCALibre.FoamMesh.FOAM3D_mesh-user_guide-1_preprocessing"><code>XCALibre.FoamMesh.FOAM3D_mesh</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FOAM3D_mesh(mesh_file; scale=1, integer_type=Int64, float_type=Float64)</code></pre><p>Read and convert 3D OpenFOAM mesh file into XCALibre.jl. Note that, at present, it is not recommended to run 2D cases using meshes imported using this function.</p><p><strong>Input</strong></p><ul><li><code>mesh_file</code> – path to mesh file.</li></ul><p><strong>Optional arguments</strong></p><ul><li><p><code>scale</code> – used to scale mesh file e.g. scale=0.001 will convert mesh from mm to metres defaults to 1 i.e. no scaling</p></li><li><p><code>integer_type</code> - select interger type to use in the mesh (Int32 may be useful on GPU runs) </p></li><li><p><code>float_type</code> - select interger type to use in the mesh (Float32 may be useful on GPU runs) </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/52db86596bc3101f119e0a7f754153a0afcaec9d/src/FoamMesh/FoamMesh_5_build.jl#L3-L20">source</a></section></article><p>These conversion functions will read mesh information and generate a mesh object (<code>Mesh2</code> or <code>Mesh3</code> depending on whether the mesh is 2D or 3D, respectively) with the following properties:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Mesh.Mesh3-user_guide-1_preprocessing" href="#XCALibre.Mesh.Mesh3-user_guide-1_preprocessing"><code>XCALibre.Mesh.Mesh3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Mesh3{VC, VI, VF&lt;:AbstractArray{&lt;:Face3D}, VB, VN, SV3, UR} &lt;: AbstractMesh
    cells::VC           # vector of cells
    cell_nodes::VI      # vector of indices to access cell nodes
    cell_faces::VI      # vector of indices to access cell faces
    cell_neighbours::VI # vector of indices to access cell neighbours
    cell_nsign::VI      # vector of indices to with face normal correction (1 or -1 )
    faces::VF           # vector of faces
    face_nodes::VI      # vector of indices to access face nodes
    boundaries::VB      # vector of boundaries
    nodes::VN           # vector of nodes
    node_cells::VI      # vector of indices to access node cells
    get_float::SV3      # store mesh float type
    get_int::UR         # store mesh integer type
    boundary_cellsID::VI # vector of indices of boundary cell IDs
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/52db86596bc3101f119e0a7f754153a0afcaec9d/src/Mesh/Mesh_0_types.jl#L150-L166">source</a></section></article><h3 id="Mesh-limitations-and-requirements"><a class="docs-heading-anchor" href="#Mesh-limitations-and-requirements">Mesh limitations and requirements</a><a id="Mesh-limitations-and-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-limitations-and-requirements" title="Permalink"></a></h3><p>In this section we summarise the key limitations of the mesh loaders presented above, and we also highlight specific requirements. </p><h4 id="UNV-mesh-files"><a class="docs-heading-anchor" href="#UNV-mesh-files">UNV mesh files</a><a id="UNV-mesh-files-1"></a><a class="docs-heading-anchor-permalink" href="#UNV-mesh-files" title="Permalink"></a></h4><ul><li>Only ASCII files are supported</li><li>For 2D simulations the mesh must be contained in the X-Y plane only</li><li>In 3D only hex, tet and prism elements are supported</li></ul><h4 id="OpenFOAM-mesh-files"><a class="docs-heading-anchor" href="#OpenFOAM-mesh-files">OpenFOAM mesh files</a><a id="OpenFOAM-mesh-files-1"></a><a class="docs-heading-anchor-permalink" href="#OpenFOAM-mesh-files" title="Permalink"></a></h4><ul><li>Only ASCII files are supported</li><li>Boundary groups are not supported (must be deleted manually or the conversion may fail)</li><li>Boundary information is not preserved (walls, symmetry, etc)</li><li>2D setups are not currently supported (but will be)</li></ul><h2 id="Backend-selection"><a class="docs-heading-anchor" href="#Backend-selection">Backend selection</a><a id="Backend-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-selection" title="Permalink"></a></h2><hr/><p>In XCALibre.jl the mesh object is very important, as it will not only provide geometry information about the simulation/s, but it is also used to automatically dispatch methods to run on the appropriate backend. Therefore, users must first select the backend they wish to use for the simulations, and then &quot;adapt&quot; the mesh to use the correct backend. </p><p><code>XCALIbre.jl</code> aims to work with all the backends supported by <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/">KernelAbstractions.jl</a>. However, since internally <code>XCALibre.jl</code> uses sparse arrays to reduce its memory footprint, some GPU backends are not currently supported since this functionality is not yet available. Thus, currently only a subset of backends are supported:</p><ul><li>CPU (multithreaded and tested)</li><li>NVidia GPUs (tested)</li><li>AMD GPUs (not tested - feedback welcome)</li></ul><p>Selecting a given backend is straight-forward. The examples below show how to assign a backend (CPU or GPU) to the symbol <code>backend</code> and converting the mesh object to run a simulation on the corresponding backend. The converted mesh is assigned to the symbol <code>mesh_dev</code> for clarity.</p><h3 id="CPU-backend"><a class="docs-heading-anchor" href="#CPU-backend">CPU backend</a><a id="CPU-backend-1"></a><a class="docs-heading-anchor-permalink" href="#CPU-backend" title="Permalink"></a></h3><p>Selecting the CPU backend is straight-forward. See the example below. Notice that <code>CPU()</code> is a backend type provided by <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/">KernelAbstractions.jl</a> which we re-export for convenience.</p><p>CPU Example </p><pre><code class="language-julia hljs">mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh
backend = CPU()
mesh_dev = mesh # dummy reference to emphasise the mesh in on our chosen dev (or backend)</code></pre><h3 id="GPU-backends"><a class="docs-heading-anchor" href="#GPU-backends">GPU backends</a><a id="GPU-backends-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-backends" title="Permalink"></a></h3><p>To execute the code on GPUS, the process is also quite simple, but does require a few additional steps.</p><ul><li>Install the corresponding Julia library that supports your hardware. For NVidia GPUs, the <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> package is required. For AMD GPUs, the <a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a> package is needed.</li><li>Move the mesh object to the backend device using the <code>adapt</code> method, which for convenience we re-export from <a href="https://github.com/JuliaGPU/Adapt.jl">Adapt.jl</a></li></ul><p>Example for Nvidia GPU</p><pre><code class="language-julia hljs">mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh
backend = CUDABackend()
mesh_dev = adapt(backend, mesh) # make mesh object backend compatible and move to GPU</code></pre><p>Example for AMD GPU</p><pre><code class="language-julia hljs">mesh = # call function to load mesh e.g. UNV2_mesh, UNV3_mesh or FOAM3D_mesh
backend = ROCBackend()
mesh_dev = adapt(backend, mesh) # make mesh object backend compatible and move to GPU</code></pre><h2 id="Hardware-configuration"><a class="docs-heading-anchor" href="#Hardware-configuration">Hardware configuration</a><a id="Hardware-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Hardware-configuration" title="Permalink"></a></h2><hr/><p>In order to configure the backend the <code>set_hardware</code> function can be used. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.Simulate.set_hardware-user_guide-1_preprocessing" href="#XCALibre.Simulate.set_hardware-user_guide-1_preprocessing"><code>XCALibre.Simulate.set_hardware</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hardware = set_hardware(backend, workgroup)</code></pre><p>Function used to configure the backend.</p><p><strong>Inputs</strong></p><ul><li><code>backend</code> named tuple used to specify the backend e.g. <code>CPU()</code>, <code>CUDABackend()</code> or other backends supported by <code>KernelAbstraction.jl</code></li><li><code>workgroup::Int</code> this is an integer specifying the number of workers that cooperate in a parallel run. For GPUs this could be set to the size of the device&#39;s warp e.g. <code>workgroup = 32</code>. On CPUs, the default value in <code>KernelAbstractions.jl</code> is currently <code>workgroup = 1024</code>.</li></ul><p><strong>Output</strong></p><p>This function returns a <code>NamedTuple</code> with the fields <code>backend</code> and <code>workgroup</code> which are accessed by internally in <code>XCALibre.jl</code> to execute a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/52db86596bc3101f119e0a7f754153a0afcaec9d/src/Simulate/Simulate_0_types.jl#L37-L50">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../0_introduction_and_workflow/">« Introduction</a><a class="docs-footer-nextpage" href="../2_physics_and_models/">Physics and models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 11 November 2024 20:02">Monday 11 November 2024</span>. Using Julia version 1.10.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
