<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Physics and models · XCALibre.jl</title><meta name="title" content="Physics and models · XCALibre.jl"/><meta property="og:title" content="Physics and models · XCALibre.jl"/><meta property="twitter:title" content="Physics and models · XCALibre.jl"/><meta name="description" content="Documentation for XCALibre.jl."/><meta property="og:description" content="Documentation for XCALibre.jl."/><meta property="twitter:description" content="Documentation for XCALibre.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">XCALibre.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/01_2d-isothermal-backward-facing-step/">Verification: 2D incompressible backward-facing step</a></li><li><a class="tocitem" href="../../examples/02_2d-incompressible-transient-cylinder/">Verification: 2D Unsteady incompressible cylinder</a></li><li><a class="tocitem" href="../../examples/03_2d-constant-temperature-flat-plate/">Validation: 2D Constant temperature flat plate</a></li><li><a class="tocitem" href="../../examples/04_2d-inflow-using-Flux/">Advanced: Inflow condition using Machine Learning (<code>Flux.jl</code>)</a></li><li><a class="tocitem" href="../../examples/05_2d-aerofoil-inflow-optimisation/">Advanced: 2D Aerofoil inflow optimisation</a></li><li><a class="tocitem" href="../../examples/06_2d-laplace-solver/">Validation: Laplace Solver in 2D Solid Medium</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../0_introduction_and_workflow/">Introduction</a></li><li><a class="tocitem" href="../1_preprocessing/">Pre-processing</a></li><li class="is-active"><a class="tocitem" href>Physics and models</a><ul class="internal"><li><a class="tocitem" href="#Physics-model-definition"><span>Physics model definition</span></a></li><li><a class="tocitem" href="#Time-models"><span>Time models</span></a></li><li><a class="tocitem" href="#Fluid-types"><span>Fluid types</span></a></li><li><a class="tocitem" href="#Turbulence-models"><span>Turbulence models</span></a></li><li><a class="tocitem" href="#Energy-models"><span>Energy models</span></a></li><li><a class="tocitem" href="#Domain-definition"><span>Domain definition</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li></ul></li><li><a class="tocitem" href="../3_numerical_setup/">Numerical setup</a></li><li><a class="tocitem" href="../4_runtime_and_solvers/">Runtime and solvers</a></li><li><a class="tocitem" href="../5_postprocessing/">Post-processing</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../contributor_guide/">Contributor Guide</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../release_notes/">Release notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Physics and models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Physics and models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mberto79/XCALibre.jl/blob/main/docs/src/user_guide/2_physics_and_models.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Physics-and-models"><a class="docs-heading-anchor" href="#Physics-and-models">Physics and models</a><a id="Physics-and-models-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-and-models" title="Permalink"></a></h1><p><em>Information about setting up a <code>Physics</code> object and boundary conditions to represent the flow physics</em></p><h2 id="Physics-model-definition"><a class="docs-heading-anchor" href="#Physics-model-definition">Physics model definition</a><a id="Physics-model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Physics-model-definition" title="Permalink"></a></h2><hr/><p>The <code>Physics</code> object is part of the highest level API in <code>XCALibre.jl</code>. <code>Physics</code> objects are a means for users to set up the physics and models that are relevant to their particular CFD simulation. Internally, the <code>Physics</code> model created is passed to solvers and is used for dispatch (solvers, algorithms and models). Thus, it is important to ensure that the information provided to this object is correct and representative of the user&#39;s intentions. <code>Physics</code> models consist of a struct with the  fields shown below. All fields must be provided to the solvers otherwise the construction of the object will fail.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Physics-user_guide-2_physics_and_models" href="#XCALibre.ModelPhysics.Physics-user_guide-2_physics_and_models"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Physics{T,F,SO,M,Tu,E,D,BI}
    time::T
    fluid::F
    solid::SO
    momentum::M 
    turbulence::Tu 
    energy::E
    domain::D
    boundary_info::BI
end</code></pre><p>XCALibre&#39;s parametric Physics type for user-level API. Also used to dispatch flow solvers.</p><p><strong>Fields</strong></p><ul><li><code>time::Union{Steady, Transient}</code>   – User-provided time model.</li><li><code>fluid::AbstractFluid</code>  – User-provided <code>Fluid</code>` model.</li><li><code>solid::AbstractSolid</code>  – User-provided <code>Solid</code>` model.</li><li><code>momentum</code>  – Momentum model. Currently this is auto-generated by the <code>Physics</code> constructor</li><li><code>turbulence::AbstractTurbulenceModel</code>  – User-provided <code>Turbulence</code>` model.</li><li><code>energy:AbstractEnergyModel</code>  – User-provided <code>Energy</code> model.</li><li><code>domain::AbstractMesh</code>  – User-provided <code>Mesh</code>. Must be adapted to target device before constructing a Physics object.</li><li><code>boundary_info::boundary_info</code>  – Mesh boundary information.  Auto-generated by the <code>Physics</code> constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/443ad7d5558842ea6c157a55992e0c2494c026bb/src/ModelPhysics/0_type_definition.jl#L7-L31">source</a></section></article><p>For convenience, <code>XCALibre.jl</code> provides a more user-friendly constructor that will automatically take care of the construction of derived fields.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XCALibre.ModelPhysics.Physics-Tuple{}-user_guide-2_physics_and_models" href="#XCALibre.ModelPhysics.Physics-Tuple{}-user_guide-2_physics_and_models"><code>XCALibre.ModelPhysics.Physics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Physics(; time, fluid, solid, turbulence, energy, domain)::Physics{T,F,SO,M,Tu,E,D,BI}</code></pre><p><code>Physics</code> constructor part of the top-level API. It can be used to define the Physics and models relevant to a simulation. This constructor uses keyword arguments to allow users to fine-tune their simulations, whilst some fields are auto-generated behind the scenes for convenience (<code>Momentum</code> and <code>boundary_info</code>). Where:</p><ul><li><code>time</code> - specified the time model (Steady or Transient)</li><li><code>fluid</code> - specifies the type of fluid (Incompressible, etc.)</li><li><code>turbulence</code> - specified the Turbulence model</li><li><code>energy</code> - specifies the Energy treatment</li><li><code>domain</code> - provides the mesh to used (must be adapted to the target backend device)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mberto79/XCALibre.jl/blob/443ad7d5558842ea6c157a55992e0c2494c026bb/src/ModelPhysics/0_type_definition.jl#L107-L118">source</a></section></article><p>At this point, it is worth reminding users that one of the benefits of working with <code>Julia</code> is its dynamic nature. This means that objects can be dynamically interrogated. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using XCALibre</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(Physics)</code><code class="nohighlight hljs ansi" style="display:block;">(:time, :fluid, :solid, :momentum, :turbulence, :energy, :domain, :boundary_info)</code></pre><p>This will provide users with all the fields that make up the <code>Physics</code> object. This is a nice way to explore the makeup of any object in <code>Julia</code> (and by extension <code>XCALibre.jl</code>). The rest of this page will provide details of the physics models available in XCALibre.jl, including:</p><ul><li><a href="#Time-models">Time models</a></li><li><a href="#Fluid-types">Fluid types</a></li><li><a href="#Turbulence-models">Turbulence models</a></li><li><a href="#Energy-models">Energy models</a></li></ul><div class="admonition is-warning" id="Warning-85e9a82e2882c371"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-85e9a82e2882c371" title="Permalink"></a></header><div class="admonition-body"><p>The mesh provided to the <code>domain</code> field must already be adapted to the required backend device. See <a href="../1_preprocessing/#Backend-selection">Backend selection</a> for detail. </p></div></div><div class="admonition is-info" id="Note-fce12c513b307258"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-fce12c513b307258" title="Permalink"></a></header><div class="admonition-body"><p>In the next version of XCALibre.jl the field <code>boundary_info</code> will be likely removed outside of the Physics object in order to improve on the current performance (avoiding unnecessary memory movement between GPU backends and the host devices).</p></div></div><h2 id="Time-models"><a class="docs-heading-anchor" href="#Time-models">Time models</a><a id="Time-models-1"></a><a class="docs-heading-anchor-permalink" href="#Time-models" title="Permalink"></a></h2><hr/><p>Earlier in this section, the dynamic nature of Julia was mentioned in the context of extracting fields for the <code>Physics</code> model used in XCALibre.jl. In the following sections this benefit of using Julia will be exploited further. XCALibre.jl takes advantage of Julia&#39;s rich type system and we define <code>Abstract</code> types to organise major functionality. For example, time models are subtypes of the abstract type <code>AbstractTimeModel</code>. Therefore, out-of-the-box we get for free a means to explore implemented features in XCALibre.jl. For example, to identify the time models implemented, we simply need to type the following in the REPL:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using XCALibre</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using InteractiveUtils # Load from standard library</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Main.subtypes(AbstractTimeModel)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Any}:
 Steady
 Transient</code></pre><p>From the output it can be seen that there are two time models in XCALibre.jl for <code>Steady</code> or <code>Transient</code> simulations. These are singleton types and contain (at present) no internal fields or data. They are largely used by XCALibre.jl to dispatch either steady or transient solvers. We are starting to get a picture of how the <code>Physics</code> object is constructed. For example, to specify a Steady simulation</p><p>The time model can be specified as <code>Steady</code> as follows:</p><pre><code class="language-julia hljs">Physics(
    time = Steady()
    ...
)</code></pre><h2 id="Fluid-types"><a class="docs-heading-anchor" href="#Fluid-types">Fluid types</a><a id="Fluid-types-1"></a><a class="docs-heading-anchor-permalink" href="#Fluid-types" title="Permalink"></a></h2><hr/><p>Following from the idea of using Julia&#39;s dynamic features to explore the types available in XCALibre.jl, in this section we will explore the fluid types available. This time, we will use a helper package <code>AbstractTrees</code> (which can be installed in the usual way, by entering into package mode in the REPL and typing <code>add AbstractTrees</code>). In XCALibre.jl all fluid types are subtypes of <code>AbstractFluid</code>. The types available are shown in the example below:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; begin
           # Note: this code snippet will not be shown later for succinctness
           using XCALibre
           using InteractiveUtils # Load from standard library
           # using Pkg; Pkg.add(&quot;AbstractTrees&quot;) # run to install AbstractTrees
           using AbstractTrees
           AbstractTrees.children(d::DataType) = Main.subtypes(d)
           print_tree(AbstractFluid)
       end</code><code class="nohighlight hljs ansi" style="display:block;">AbstractFluid
├─ AbstractCompressible
│  ├─ Compressible
│  └─ WeaklyCompressible
└─ AbstractIncompressible
   └─ Incompressible</code></pre><p>From the subtype tree above, we can see that XCALibre.jl offers 2 major abstract fluid types, <code>AbstractIncompressible</code> and <code>AbstractCompressible</code>. There are 3 concrete fluid types:</p><ul><li><code>Incompressible</code> - for simulations were the fluid density does not change with pressure</li><li><code>WeaklyCompressible</code> - for simulation were the fluid density is allowed to change (no shockwaves)</li><li><code>Compressible</code> - for simulations were discontinuities may appear (not available for general use yet)</li></ul><p>To specify a given fluid type, the <code>Fluid</code> wrapper type is used as a general constructor which is specialised depending depending on the fluid type from the list above provided by the user. The constructors require the following inputs:</p><p>For incompressible fluid flow</p><pre><code class="language-julia hljs">Fluid{Incompressible}(; nu, rho=1.0) </code></pre><p>For compressible fluids (weak formulation)</p><pre><code class="language-julia hljs">Fluid{WeaklyCompressible}(; nu, cp, gamma, Pr)</code></pre><p>where the input variables represent the following:</p><ul><li><code>nu</code> - kinematic viscosity</li><li><code>rho</code> - fluid density</li><li><code>gamma</code> - specific heat ratio</li><li><code>Pr</code> - Prandlt number</li><li><code>cp</code> - specific heat at constant pressure</li></ul><p>For example, an incompressible fluid can be specified as follows</p><pre><code class="language-julia hljs">Physics(
    time = Steady(),
    fluid = Fluid{Incompressible}(nu=1e-5),
    ...
)</code></pre><h2 id="Turbulence-models"><a class="docs-heading-anchor" href="#Turbulence-models">Turbulence models</a><a id="Turbulence-models-1"></a><a class="docs-heading-anchor-permalink" href="#Turbulence-models" title="Permalink"></a></h2><hr/><p>Below is a representation of the <code>AbstractTurbulenceModel</code> inheritance tree. It shows turbulence models available. Turbulence models are defined using the <code>RANS</code> and <code>LES</code> constructors and passing a specific turbulence model type. As it will be illustrated in the flowing sections.</p><pre><code class="nohighlight hljs ansi" style="display:block;">AbstractTurbulenceModel
├─ AbstractLESModel
│  ├─ KEquation
│  └─ Smagorinsky
└─ AbstractRANSModel
   ├─ KOmega
   ├─ KOmegaLKE
   └─ Laminar</code></pre><h3 id="RANS-models-constructors"><a class="docs-heading-anchor" href="#RANS-models-constructors">RANS models constructors</a><a id="RANS-models-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#RANS-models-constructors" title="Permalink"></a></h3><p>Laminar model: no user input is required. This is a dummy model that does not contribute to the momentum equation.</p><pre><code class="language-julia hljs">RANS{Laminar}() # only constructor needed</code></pre><p>KOmega model: the standard 2 equation Wilcox model coefficients are passed by default. This model solves 2 transport equations for the turbulent kinetic energy and the specific dissipation rate,  <code>k</code> and <code>omega</code>, respectively. Subsequently, <code>k</code> and <code>omega</code> are used to update the turbulent eddy viscosity, <code>nut</code>. These 3 fields must be provided with boundary conditions. </p><pre><code class="language-julia hljs">RANS{KOmega}() # will set the default coefficient values shown below
RANS{KOmega}(; β⁺=0.09, α1=0.52, β1=0.072, σk=0.5, σω=0.5) # set defaults
RANS{KOmega}(β1=0.075) # user can choose to change a single coefficient</code></pre><p>KOmegaLKE model: the user must provide a reference turbulence intensity (<code>Tu</code>) and a tuple of symbols specifying wall boundaries. This model uses 3 equations (<code>k</code>, <code>kl</code>, <code>omega</code>) to update the eddy viscosity (<code>nut</code>). These fields must be provided with boundary conditions.</p><pre><code class="language-julia hljs">RANS{KOmegaLKE}(; Tu::Number, walls::Tuple) # no defaults defined
RANS{KOmegaLKE}(Tu = 0.01, walls=(:cylinder,)) # user should provide information for Tu and walls</code></pre><p>For example, a steady, incompressible simulation using the <code>KOmega</code> model can be specified as</p><pre><code class="language-julia hljs">Physics(
    time = Steady(),
    fluid = Fluid{Incompressible}(nu=1e-5),
    turbulence = RANS{KOmega}(),
    ...
)</code></pre><h3 id="LES-models"><a class="docs-heading-anchor" href="#LES-models">LES models</a><a id="LES-models-1"></a><a class="docs-heading-anchor-permalink" href="#LES-models" title="Permalink"></a></h3><p>Laminar model: no user input is required. This is a dummy model that does not contribute to the momentum equation. It can be used to carry out LES simulations of laminar flows. For sufficiently refined grids, this model can be used for DNS simulations. Since <code>XCALibre.jl</code> is a Finite Volume Method solver, for complex geometries the simulation should be regarded as a quasi-DNS simulation. For second order accurate DNS simulations very high quality hex grids should be used.</p><pre><code class="language-julia hljs">LES{Laminar}() # only constructor needed</code></pre><p>Smagorinsky model: the standard model constant is passed by default. Boundary conditions for <code>nut</code> must be provided, generally zero gradient conditions work well. No special wall functions for <code>nut</code> in LES mode are available.</p><pre><code class="language-julia hljs">LES{Smagorinsky}() # default constructor will use value below
LES{Smagorinsky}(; C=0.15) # default value provided by default
LES{Smagorinsky}(C=0.1) # user selected value</code></pre><p>For example, an incompressible LES simulation with the <code>Smagorinsky</code> model can be specified as</p><pre><code class="language-julia hljs">Physics(
    time = Transient(),
    fluid = Fluid{Incompressible}(nu=1e-5),
    turbulence = LES{Smagorinsky}(),
)</code></pre><div class="admonition is-info" id="Note-244621391190a20f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-244621391190a20f" title="Permalink"></a></header><div class="admonition-body"><p>In the specification above the time model was set as <code>Transient</code> since <code>LES</code> models are strictly time-resolving. A simulation might run when the <code>Steady</code> model is chosen, but the results would likely not be reliable. <code>XCALibre.jl</code> by design offers flexibility for users to customise their setup, the consequence is that it falls on users to define a combination of models that is appropriate. Likewise, in the example above an <code>Isothermal</code> energy model would have to be selected. See <a href="#Energy-models">Energy models</a></p></div></div><h2 id="Energy-models"><a class="docs-heading-anchor" href="#Energy-models">Energy models</a><a id="Energy-models-1"></a><a class="docs-heading-anchor-permalink" href="#Energy-models" title="Permalink"></a></h2><hr/><p>Currently, XCALibre.jl offers two options to model the energy equation. A tree of the <code>AbstractEnergyModel</code> is shown below. The top-level constructor for energy models is the <code>Energy</code> type. Specific constructor signatures are also illustrated below.</p><pre><code class="nohighlight hljs ansi" style="display:block;">AbstractEnergyModel
├─ Conduction
├─ Isothermal
└─ SensibleEnthalpy</code></pre><p>Isothermal model: assumes temperature effects are negligible. Used for incompressible solvers.</p><pre><code class="language-julia hljs">Energy{Isothermal}() # default constructor</code></pre><p>SensibleEnthalpy model: uses the sensible enthalpy model for the energy equation. Required for the compressible solvers.</p><pre><code class="language-julia hljs">Energy{SensibleEnthalpy}(; Tref)  # constructor definition. No default values given to Tref keyword
Energy{SensibleEnthalpy}(Tref=300)  # Users must provide a referent temperature value</code></pre><p>For example, a steady, compressible <code>RANS</code> simulation with the <code>KOmegaLKE</code> model can be specified as</p><pre><code class="language-julia hljs">Physics(
    time = Steady(),
    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),
    turbulence = RANS{KOmegaLKE}(),
    energy = Energy{SensibleEnthalpy}(Tref=300),
    ...
)</code></pre><h2 id="Domain-definition"><a class="docs-heading-anchor" href="#Domain-definition">Domain definition</a><a id="Domain-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Domain-definition" title="Permalink"></a></h2><p>The final step when defining a <code>Physics</code> model is to specify the domain on which the various models will be used. This is simply a reference to the mesh object.</p><p>Continuing from the previous example, a steady, compressible <code>RANS</code> simulation with the <code>KOmegaLKE</code> model can be specified as</p><pre><code class="language-julia hljs">Physics(
    time = Steady(),
    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),
    turbulence = RANS{KOmegaLKE}(),
    energy = Energy{SensibleEnthalpy}(Tref=300),
    domain = mesh_dev
)</code></pre><div class="admonition is-warning" id="Warning-6da85899e3dff56"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6da85899e3dff56" title="Permalink"></a></header><div class="admonition-body"><p>When passing the mesh objective to complete the definition of the <code>Physics</code> object, the mesh must be adapted to the target device where the computation will be performed. See <a href="../1_preprocessing/#Backend-selection">Backend selection</a> for more details.</p></div></div><p>Notice that the transfer to the target compute backend can also be done inline. For example,</p><pre><code class="language-julia hljs">Physics(
    time = Steady(),
    fluid = Fluid{WeaklyCompressible}(nu=1e-5, cp=1005, gamma=1.4, Pr=0.7),
    turbulence = RANS{KOmegaLKE}(),
    energy = Energy{SensibleEnthalpy}(Tref=300),
    domain = adapt(CUDABackend(), mesh) # for Nvidia GPUs
)</code></pre><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><hr/><p>The final step to completely capture the physics for the simulation is to define boundary conditions in order to find a concrete solution of the model equations being solved. XCALibre.jl offers a range of boundary conditions. As before, boundary conditions are specified by type and the are classified under the <code>AbstractBoundary</code> type and subdivided into 4 additional abstract types <code>AbstractDirichlet</code>, <code>AbstractNeumann</code>, <code>AbstractPhysicalConstraint</code> and <code>AbstractWallFunction</code>. The complete abstract tree is illustrated below.</p><pre><code class="nohighlight hljs ansi" style="display:block;">AbstractBoundary
├─ AbstractDirichlet
│  ├─ Dirichlet
│  ├─ DirichletFunction
│  └─ FixedTemperature
├─ AbstractNeumann
│  ├─ Extrapolated
│  ├─ Neumann
│  ├─ NeumannFunction
│  └─ Zerogradient
├─ AbstractPhysicalConstraint
│  ├─ Empty
│  ├─ Symmetry
│  ├─ Wall
│  └─ AbstractPeriodic
│     ├─ Periodic
│     └─ PeriodicParent
└─ AbstractWallFunction
   ├─ KWallFunction
   ├─ NutWallFunction
   └─ OmegaWallFunction</code></pre><p>Philosophically, the four subtypes represent different physical types of boundary conditions:</p><ul><li><code>AbstractDirichlet</code> boundary conditions are used to assign a concrete value to field at the boundary.</li><li><code>AbstractNeumann</code> boundaries are used to fix the field gradient at the boundary.</li><li><code>AbstractPhysicalConstraint</code> boundaries represent physical constraints imposed on the domain.</li><li><code>AbstractWallFunction</code> represent models for treating flow or turbulence quantities in wall regions.</li></ul><h3 id="AbstractDirichlet-conditions"><a class="docs-heading-anchor" href="#AbstractDirichlet-conditions"><code>AbstractDirichlet</code> conditions</a><a id="AbstractDirichlet-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractDirichlet-conditions" title="Permalink"></a></h3><pre><code class="language-julia hljs">Dirichlet(name, value)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li><li><code>value</code> is a vector or scalar defining desired value at the boundary</li></ul><pre><code class="language-julia hljs">FixedTemperature(name; T, model::EnergyModel&lt;:AbstractEnergyModel)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li><li><code>T</code> is a keyword argument to define the temperate value to be assigned at the boundary</li><li><code>model</code> is a keyword argument that expects an instance of the energy model to be used e.g. <code>SensibleEnergy</code></li></ul><pre><code class="language-julia hljs">DirichletFunction(name, func)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li><li><code>func</code> is a function identifier. <code>func</code> is a user-defined function (but can also be a neural network) that returns a scalar or vector as a function of time and space.</li><li><code>func</code> must adhere to an internal contract. See <a href="../../reference/#XCALibre.Discretise.DirichletFunction"><code>XCALibre.Discretise.DirichletFunction</code></a> for more details.</li></ul><h3 id="AbstractNeumann-conditions"><a class="docs-heading-anchor" href="#AbstractNeumann-conditions"><code>AbstractNeumann</code> conditions</a><a id="AbstractNeumann-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractNeumann-conditions" title="Permalink"></a></h3><pre><code class="language-julia hljs">Extrapolated(name, value)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li><li><code>value</code> is a scalar defining the gradient normal to the boundary</li></ul><div class="admonition is-warning" id="Warning-ef6a2e75633e4482"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ef6a2e75633e4482" title="Permalink"></a></header><div class="admonition-body"><p>At present the Extrapolated boundary should be treated as providing a zero gradient condition only. Internally, a zero gradient value is hard-coded. This behaviour will be extended in the near future to allow arbitrary gradients to be defined.</p></div></div><h3 id="AbstractPhysicalConstraint-conditions"><a class="docs-heading-anchor" href="#AbstractPhysicalConstraint-conditions"><code>AbstractPhysicalConstraint</code> conditions</a><a id="AbstractPhysicalConstraint-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractPhysicalConstraint-conditions" title="Permalink"></a></h3><p><code>Wall</code> boundary conditions can be used to provide a boundary with a wall constraint. This boundary type, at present, can only be used to define vectors. For scalar quantities in wall regions a <code>Extrapolated</code> (zero gradient) should be imposed.</p><pre><code class="language-julia hljs">Wall(name, value)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li><li><code>value</code> is a vector defining wall velocity e.g. [0, 0, 0]</li></ul><div class="admonition is-info" id="Note-3b03b51921586f5e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3b03b51921586f5e" title="Permalink"></a></header><div class="admonition-body"><p>Currently, the value provided at the wall is not used internally. This mean that this boundary condition currently acts as a no slip boundary. This will be extended to allow slip boundaries or moving walls.</p></div></div><p><code>Symmetry</code> boundary condition can be used to assign a symmetry constraint to a given boundary patch in the domain. It can be used for both vector and scalar quantities.</p><pre><code class="language-julia hljs">Symmetry(name)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li></ul><p><code>Periodic</code> boundaries consist of a pair of boundary patches that behave as if they are physically connected. The periodic boundary essentially provides a mapping between these patches and helps in calculating the face values at the interface. The construction of periodic boundaries is different to other boundary conditions because the addressing between each face for the patch pair needs to be calculated and stored. Periodic boundary can be constructed as follows:</p><pre><code class="language-julia hljs">periodic::Tuple = construct_periodic(mesh, backend, patch1::Symbol, patch2::Symbol)</code></pre><ul><li><code>mesh</code> is a reference to the mesh object</li><li><code>backend</code> defines the expected backend e.g. CPU(), CUDABackend, etc.</li><li><code>patch1</code> and <code>patch2</code> symbols of the two patch pair we would like to flag as periodic</li></ul><p>The output is a tuple containing two <code>Periodic</code> boundary types with information relevant to each boundary patch pair and it can be used directly to assign a periodic boundary for both patches (by splatting into the assignment macro e.g. <code>periodic...</code>)</p><h3 id="AbstractWallFunction-conditions"><a class="docs-heading-anchor" href="#AbstractWallFunction-conditions"><code>AbstractWallFunction</code> conditions</a><a id="AbstractWallFunction-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractWallFunction-conditions" title="Permalink"></a></h3><p><code>KWallFunction</code> provides a turbulent kinetic energy boundary condition for high-Reynolds models.</p><pre><code class="language-julia hljs">KWallFunction(name)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li></ul><p><code>OmegaWallFunction</code> provides a value for the specific dissipation rate for both low- and high-Reynolds model.</p><pre><code class="language-julia hljs">OmegaWallFunction(name)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li></ul><p><code>NutWallFunction</code> provides a value for the eddy viscosity for high-Reynolds models</p><pre><code class="language-julia hljs">NutWallFunction(name)</code></pre><ul><li><code>name</code> is a symbol providing the boundary name</li></ul><h3 id="Assigning-conditions-(macro)"><a class="docs-heading-anchor" href="#Assigning-conditions-(macro)">Assigning conditions (macro)</a><a id="Assigning-conditions-(macro)-1"></a><a class="docs-heading-anchor-permalink" href="#Assigning-conditions-(macro)" title="Permalink"></a></h3><p>XCALibre.jl requires that a boundary condition is assigned to every single patch in the domain (as defined within the mesh object) for every field that is part of the solution. To facilitate this process, XCALibre.jl provides the <code>@assign</code> macro for convenience. The <code>@assign</code> macro has the following signature:</p><pre><code class="language-julia hljs">@assign! model::Physics &lt;physical model&gt; &lt;field&gt; (
    &lt;patch1 boudary&gt;, 
    &lt;patch2 boundary&gt;, 
    ...
    )</code></pre><p>For example, for a laminar incompressible simulation, only the momentum equation is being solved. Therefore, users need to provide conditions for every patch for the <code>U</code> and  <code>p</code> fields in the momentum model:</p><pre><code class="language-julia hljs">using XCALibre

grids_dir = pkgdir(XCALibre, &quot;examples/0_GRIDS&quot;)
grid = &quot;backwardFacingStep_10mm.unv&quot;
mesh_file = joinpath(grids_dir, grid)
mesh = UNV2D_mesh(mesh_file, scale=0.001)

backend = CPU() #  run on CPU
hardware = Hardware(backend=backend, workgroup=4)
mesh_dev = mesh # dummy assignment 

# Flow conditions
velocity = [1.5, 0.0, 0.0]
nu = 1e-3
Re = velocity[1]*0.1/nu # Reynolds number

# Physics models
model = Physics(
    time = Steady(),
    fluid = Fluid{Incompressible}(nu = nu),
    turbulence = RANS{Laminar}(),
    energy = Energy{Isothermal}(),
    domain = mesh_dev
    )

# Define boundary conditions
BCs = assign(
    region=mesh_dev,
    (
        U = [
            Dirichlet(:inlet, velocity),
            Extrapolated(:outlet),
            Wall(:wall, [0.0, 0.0, 0.0]),
            Wall(:top, [0.0, 0.0, 0.0])
        ], 
        p = [
            Extrapolated(:inlet),
            Dirichlet(:outlet, 0.0),
            Wall(:wall), # scalar wall - set up as zero gradient
            Wall(:top)   # scalar wall - set up as zero gradient
        ]
    )
)</code></pre><div class="admonition is-category-hint" id="Hint-efbfaaa1770b5afc"><header class="admonition-header">Hint<a class="admonition-anchor" href="#Hint-efbfaaa1770b5afc" title="Permalink"></a></header><div class="admonition-body"><p>Julia is a dynamic language and objects can be interrogated on the fly (dynamically). Say you created a <code>Physics</code> model named <code>mymodel</code>, you can interrogate the contents of any of the fields in the <code>Physics</code> structure using the <code>fieldnames</code> function, e.g. <code>fieldnames(mymodel.momentum)</code>, to find which fields need to be provided with boundary conditions. Any fields not ending in <code>f</code> should be set. </p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1_preprocessing/">« Pre-processing</a><a class="docs-footer-nextpage" href="../3_numerical_setup/">Numerical setup »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 4 September 2025 21:00">Thursday 4 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
